<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://jaynewho.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://jaynewho.com/" rel="alternate" type="text/html" /><updated>2020-07-04T00:45:59+09:00</updated><id>http://jaynewho.com/</id><title type="html">Jayne.who();</title><subtitle>shinjayne`s Developer Blog. 신재인의 개발 블로그. Web / Deep Learning / Android / etc ...</subtitle><entry><title type="html">[사설 #3] IT 기술 회사에서 업의 본질</title><link href="http://jaynewho.com/post/48" rel="alternate" type="text/html" title="[사설 #3] IT 기술 회사에서 업의 본질" /><published>2020-07-03T22:34:50+09:00</published><updated>2020-07-03T22:34:50+09:00</updated><id>http://jaynewho.com/post/48</id><content type="html" xml:base="http://jaynewho.com/post/48">&lt;p&gt;최근 이회사 저회사 대표님이나 이사님 개발자님들을 만나고 다니면서 자주 하게된 이야기 주제가 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“하시려는 업의 본질은 무엇입니까?”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;“업의 본질에 도달하는 데에 기술이 정말 필요합니까?”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://apps.apple.com/kr/app/%EC%8A%A4%ED%83%80%EC%9D%BC%EC%89%90%EC%96%B4/id458165974&quot;&gt;스타일쉐어&lt;/a&gt; 라는 서비스가 있다. 스타일쉐어는 훌륭한 패션 서비스이다. 패션을 좋아하는 유저들에게 좋은 커뮤니티와 커머스를 제공한다. 물론 이러한 서비스를 하기 위해서는 앱과 서버, 웹사이트로 구성된 프로덕트가 있어야 한다.&lt;/p&gt;

&lt;p&gt;하지만 그것이 반드시 스타일쉐어 업의 본질을 추구하기 위해 기술이 필요하다는 이야기는 아니다. 업의 본질을 무엇으로 정의하느냐에 따라서 기술이 아예 필요가 없을 수도 있고, 혹은 업의 본질에 다가가기 위한 특정 구간까지만 필요할 수도 있고, 본인들의 정체성을 영속적인 기술 회사로 정의해야 할 수도 있다.&lt;/p&gt;

&lt;p&gt;스타일쉐어가 만약 자신의 업을 “사람들에게 더 나은 상품을 더 좋은 가격에 제공하는 것”이라는 전통적인 커머스로 정의한다면, 이들의 업에 있어서 기술은 진짜 하려고 하는 일의 기반을 만드는 데에 기간까지만 중요하다고 생각할 수 있다. 혹은 그마저도 외주나 에이전시로 돌리면 더 그들의 본질에 집중할 수 있다. 전통적인 커머스의 업의 본질은 “더 빠른 배송”, “더 나은 가격”, “더 많은 상품” 이고 이는 가격 경쟁, 상품 경쟁으로 귀결되지 기술로 승부를 보는 무언가가 아니라고 판단한다면 말이다. 이건 팀이 본인들의 업을 어떻게 정의하고 믿느냐에 따라 다를 것이다.&lt;/p&gt;

&lt;p&gt;그런데 재미있는 점은, 조금만 깊고 철저히 생각해보면 사실은 이러한 전통적인 커머스 본질을 추구하려고 해도 기술이 필요하다는 것이다. 상품 스큐를 어마어마하게 늘리면서 동시에 유저에게 매력적인 가격 할인과 기획전을 제공하려면, 오류 없이 치밀하게 설계되고 대용량을 감당할 수 있는 자동화가 필요하다.&lt;/p&gt;

&lt;p&gt;더 나아가 스타일쉐어가 전통적인 커머스업의 본질을 추구하는 게 아닌, 자신을 “패션업”이라고 정의하고, ‘유저가 패션을 탐색하고 상품을 선정하고 좋은 구매 경험을 할 수 있게 하자’ 는 미션을 추구한다면, 업의 본질을 추구하며 달려가는 길에는 기술로 풀어야 하는 어렵고도 도전적인 문제들이 너무나도 많다. 수백만명의 혹은 수천만 명의 유저들이 동시에 자신에게 더 맞는 개인화된 스타일을 찾을 수 있도록 기술로 끊임없이 혁신하고, 더 참신하고 새롭고 재미있는 소통과 연결의 경험을 제공하면서도 동시에 엄청난 처리량을 견디는 기술로 그 경험을 지탱하고, 더 많은 판매자가 본인들을 원하는 구매자들에게 다가갈 수 있게 하는…. 이런 모든 일이 우리의 업을 “기술로 패션을 혁신한다”라는 프레임으로 앞길을 보면 보이기 시작한다.&lt;/p&gt;

&lt;p&gt;똑같은 일을 하려고 해도 업의 본질을 어떻게 정의하느냐의 차이이다. 패션을 혁신한다는 비전의 청사진에 기술이 있을 수도 있고, 없을 수도 있다. 그러한 업의 본질을 정의하는 것은 팀의 역량이다. 무엇이 옳을지 정답은 없지만, 업의 본질과 기술의 필요성을 명확히 해야 한다는 것은 분명하다.&lt;/p&gt;

&lt;p&gt;나는 많은 미숙한 IT 팀들이 업의 본질에 대한 정의 능력 부족, 혹은 그 본질을 달성하는 데에 기술이 필요한 이유에 대한 고민 부족으로 눈앞의 성장 기회들을 많이 놓치고, 또 진짜 그들에게 필요한 유능한 개발자들도 놓친다고 생각한다. 임팩트를 내는 개발자들은 기술로 세상에 가치를 만들고 싶어 하기 때문이다.&lt;/p&gt;

&lt;p&gt;IT 서비스를 한다면 깊이 고민해봐야 한다고 생각한다. 정말 내가 하려는 업의 본질은 뭘까. 그리고 그 업의 본질은 기술로 풀 수 있는 것이 맞는가. 혹은 기술에 대한 낮은 이해도로 업에서 기술의 중요성을 저평가하고 있는 것은 아닌가. 그리고 명확한 답이 나왔다면 과감하게 행동해야 한다. 기술이 필요 없다면 과감히 기술에 대한 집착을 버리고, 기술이 필요하면 확실히 투자하라. 깊이 고민하고 답을 찾았다면 모두에게 확신을 보여줘야 한다.&lt;/p&gt;</content><author><name></name></author><category term="예민한개발자입니다" /><category term="사설" /><category term="팀" /><category term="문화" /><category term="경영" /><summary type="html">최근 이회사 저회사 대표님이나 이사님 개발자님들을 만나고 다니면서 자주 하게된 이야기 주제가 있다.</summary></entry><entry><title type="html">[사설 #2] 우리가 Best Seller 를 읽어야하는 이유</title><link href="http://jaynewho.com/post/47" rel="alternate" type="text/html" title="[사설 #2] 우리가 Best Seller 를 읽어야하는 이유" /><published>2020-05-22T22:34:50+09:00</published><updated>2020-05-22T22:34:50+09:00</updated><id>http://jaynewho.com/post/47</id><content type="html" xml:base="http://jaynewho.com/post/47">&lt;p&gt;반골 기질이 있는 나는 서점에 가는 것을 좋아하지만 Best Seller 섹션에 꽂혀있는 유명한 책들에는 먼저 손이 가지 않는다. 주변 사람들이 모두 읽는 책을 읽으면 ‘이런 이런 책을 읽었는데 이런이런 내용이 좋더라’라고 자랑을 하기도 어렵고, 지식의 가치는 정보의 비대칭에서 온다는 생각이 있어서, 많은 사람들이 이미 아는 내용을 습득해봤자 의미가 있을까 하는 의문이 있기 때문이다.&lt;/p&gt;

&lt;p&gt;확실히 ‘나만 아는 정보다’라는 사실은 전통적으로 매력적이었던 것으로 보인다. 고대 그리스의 권력은 소수만이 접근 가능한 지식에서 나왔다고 한다. 일부 지식인들만 되물림과 인맥을 통해 전달되는 ‘책’ (그때는 매우 희귀했었다)을 읽을 수 있었고, 그를 통해 부여받은 정보와 지식의 압도적인 비대칭을 이용해 권력을 손에 넣었다고 한다. 정말 내가 그때 당시의 일반 농민이었어도, ‘다음 달에는 아마 홍수가 날 테니 홍수들을 대비하는 게 좋을 거야’라고 이야기하고, 정말로 정확한 예측을 하는 사람이 있다면 주술을 부리는 마법사처럼 느껴졌을 것이다. 그리고 그 압도되는 기량 차이에 자연스럽게 권력 구조는 형성될 수밖에 없을 것이다.&lt;/p&gt;

&lt;p&gt;또 ‘나만 아는 정보다’라는 사실이 매력적이라는 것은 찌라시를 좋아하는 우리들의 모습만 봐도 보편적인 감정이라는 것을 알 수 있다. 소위 찌라시라고 불리는 ‘증권가에서 떠도는 발 빠른 입소문 정보’는 대중 매체와 언론을 통해 보도되는 핫이슈보다 빠르게 소수의 네트워크를 통해 구전되고, 실제로 그 정보의 비대칭에서 오는 기회 (주식 상승장을 미리 알아챈다거나 하는)가 아주 많다.&lt;/p&gt;

&lt;p&gt;하지만 우리는 서점에 가서 모두가 읽는 Best Seller 들에 관심을 기울여야 한다. 아니, 사실 시간만 있다면 빠짐없이 모두 내용을 파악해야 한다. ‘나만 아는 정보’의 비대칭이 가지는 힘이 큰 만큼, ‘모두가 아는 정보’를 빠르게 습득하는 힘 또한 강력하기 때문이다. 보편 지식을 폭넓고 빠르게 습득하는 근육이 지니는 힘, 바로 ‘General Knowledge의 힘’이다.&lt;/p&gt;

&lt;p&gt;맥킨지, 베인과 같은 컨설팅 회사들이 면접자에게 시사 지식을 테스트하는 이유는 무엇이라고 생각하는가? 바로 지원자의 General Kowledge를 검증하기 위해서다. 보편 지식을 많이 아는 사람은 같은 사안을 다루더라도 더 폭넓게 사고하고, 전체론적인 관점에서 의사결정을 이끌어낼 줄 안다. 그뿐만이랴. 사석에서 어느 대화 주제가 나와도 말할 거리가 있으니, 중요한 인간관계나 기회를 놓치는 일이 적어진다. 또 무엇보다, 보편 지식을 빠르게 따라잡는 근육이 있는 사람은 다른 어떤 새로운 정보나 일감을 가져다줘도 누구보다 빠르게 적응한다.&lt;/p&gt;

&lt;p&gt;또 보편 지식에 능한 사람에게는 출세의 기회가 더 많이 찾아온다. 기회는 과학이 아니라 사회에서 나온다. 사회의 관심이 몰리는 주제가 무엇인지를 알고 있다면 더 많은 기회를 포착할 수 있다. 당신이 바이오 쪽으로 사업을 하고 있는 사업가라고 생각해보자. 다양한 베스트셀러들과 뉴스를 접해가며 “원격 진료”에 대한 사회적 인식이 점점 개선되고 있다는 사실을 포착했다면, 더 공격적으로 원격진료 시장을 향해 사업을 전개시킬 수 있고, 더불어 투자자들에게도 보편 지식을 이용해 더 설득력 있는 IR을 할 수 있다.&lt;/p&gt;

&lt;p&gt;‘다들 읽는 책은 너무 뻔하고 식상해. 남이 추천해준 책을 따라 읽으면 뭔가 따라 하는 것 같잖아?’ 하는 생각을 조금이라도 가지고 있었다면 과감히 버려라. 지금 이 순간의, 대다수 사람들의 사고 체계의 영향을 주는 “보편 지식”을 빠르게 학습하려는 욕심을 가져야 한다. 그것이 넘쳐나는 정보의 홍수 시대에서, 남들을 뛰어넘는 정보역량을 가질 수 있는 역설적이고도 유일한 방법이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/47/cover1.jpg&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="예민한개발자입니다" /><category term="권력" /><category term="보편지식" /><category term="정치" /><category term="성공" /><category term="사설" /><summary type="html">반골 기질이 있는 나는 서점에 가는 것을 좋아하지만 Best Seller 섹션에 꽂혀있는 유명한 책들에는 먼저 손이 가지 않는다. 주변 사람들이 모두 읽는 책을 읽으면 ‘이런 이런 책을 읽었는데 이런이런 내용이 좋더라’라고 자랑을 하기도 어렵고, 지식의 가치는 정보의 비대칭에서 온다는 생각이 있어서, 많은 사람들이 이미 아는 내용을 습득해봤자 의미가 있을까 하는 의문이 있기 때문이다.</summary></entry><entry><title type="html">[사설 #1] 일을 글로 배우셨어요?</title><link href="http://jaynewho.com/post/46" rel="alternate" type="text/html" title="[사설 #1] 일을 글로 배우셨어요?" /><published>2020-04-08T22:34:50+09:00</published><updated>2020-04-08T22:34:50+09:00</updated><id>http://jaynewho.com/post/46</id><content type="html" xml:base="http://jaynewho.com/post/46">&lt;p&gt;애자일 방법론, 린 스타트업, 그로스 해킹 등 기존 시장의 성장곡선을 가파르게 추월해야 살아남을 수 있는 스타트업 업계에서는 성공적인 사례들을 바탕으로 한 다양한 방법론들이 존재한다. 그리고 그 방법론들은 “이렇게 하면 너도 성공할 거야”에 대한 이야기를 해주기 때문에 굉장히 재밌고 인기가 많다.&lt;/p&gt;

&lt;p&gt;처음 “창업”과 “스타트업”이라는 이름에 가슴이 뛰었던 시절이 생각이 난다. 내 손으로 일구는 스타트업은 너무나 해보고 싶었지만, 실무 경험도 없고 아는 것도 하나 없는 나는 스스로에 대한 자신감이 매우 부족했다. 그때 신봉적으로 찾았던 것이 바로 “방법론” 들이었다. 직접 해보지 않으면 신비롭고 신화 같은 것.&lt;/p&gt;

&lt;p&gt;‘와, 워터폴 방식이 아닌 애자일 방식으로 일하는 회사는 너무 혁신적이야! 나도 저런 회사를 다니거나 세울 수 있을까?’ 라던지 ‘J 커브를 그리기 위해 비즈니스 모델 템플릿부터 철저하게 고려해 완성시킨 경영자들 진짜 멋있다. 그들은 이 방법론들의 마스터야! 그렇기 때문에 성공했겠지.’와 같은 생각을 했다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;그런데 이 제대로 일해보지 않은 자의 ‘방법론에 대한 집착’ 은 제대로 연애해보지 않은 자의 ‘글로 배운 연애’ 랑 비슷해서,&lt;/strong&gt; 실제로 해보면 막상 방법론이나 글에서 가르치는 연애는, 하는 말은 틀린 것 하나 없지만 그것만 알고서는 아무것도 할 수 없다. 왜 그럴까? 여느 현실 세계가 그렇듯이, 일과 연애 모두 너무나 많은 변인들에 의해 결과가 달라지는 복잡계이기 때문이다.&lt;/p&gt;

&lt;p&gt;결국 일이나 연애를 잘하기 위해선 방법론뿐만 아니라 상황에 대처하는 “유연한 감각”과 “실행 능력” 이 못지않게 중요하다는 것을 체감할 것이다. 심지어 정형화된 방법론 하나 몰라도, 직접 해보면서 체득하는 유연한 감각과 실행 능력만으로도 충분히 훌륭해질 수 있다. 오로지 “경험 안 해본 사람” 만이 방법론에 집착하고 신봉한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;안 해봤기 때문에 대단해 보이고 달라 보인다.&lt;/strong&gt; 세상 많은 것들이 그렇다. 특히 스타트업의 방법론은, “기성 기업의 업무 방식을 타파하고 그들의 성과를 초월한다”는 신화적인 요소도 내포하고 있기 때문에 더욱 “안 해본 사람들” 이 혹하기 쉽다.&lt;/p&gt;

&lt;p&gt;소위 말해 “해보면 달라”라는 말이 나온다고 할 수 있다.&lt;/p&gt;

&lt;p&gt;연애를 글로만 배운 사람과 연애를 할 때 너무 공식대로만 하려고 하는 상대방에 피로감을 느끼기 십상인 것처럼, 실무를 해보지 않은 방법론 신봉자들도 동료들에게 비슷한 결의 피로감을 준다. 창업을 하기 위해 팀원들이 뭉쳤고, 팀원들 중에 대기업에만 다니셨거나 학생 출신의 팀원이 있다고 상상해보자. 적은 인적, 시간적, 금전적 리소스로 시장을 상회하는 퍼포먼스를 내기 위해서 모두들 열심히 일할 것이다. 그런데 자꾸 대기업에만 다니시던 분이, 평소에 즐겨 읽고 동경하던 “스타트업 바이블”의 방법론을 들먹이면서 “촘촘하게 비즈니스 캔버스부터 다 같이 그려볼까요?” 라거나 “그로스 해킹” 책의 내용을 언급하며 “해야 하는 사안들의 ICE Score를 매기고, 순서대로 진행하는 게 좋겠어요”라고 이야기한다. 그분 입장에서는 평소에 하던 정적인 업무와는 다르고, 그리고 동경하던 방법론들을 발휘해 볼 수 있는 환경이 주어졌기 때문에 신이 났을 것이다. 하지만 같이 일하는 팀원은 어떨까? 방법론은 체득되어있고, 감각과 실무 능력으로 치고 나가고 싶은데, 원리 원칙만 강조하며 일을 더디게 만드는 그 사람이 싫증 날 것이다.&lt;/p&gt;

&lt;p&gt;이번엔 콘텐츠 디자인만 하다가 우리 UI 디자인팀 리드로 오신 새 팀장님을 상상해보자. 팀장님은 UI 디자인 경험이 없어서, 열심히 인터넷에서 UI 디자인팀의 방법론들을 학습하셨다. 그리고는 회사에 와서 “우리, 린 스타트업 실전 UX 책을 모두 같이 읽고 오늘부터 이렇게 실천해봅시다!”라고 한다고 해보자. 물론 새로운 자극이라는 측면에서는 일부 긍정적일 수 있지만, &lt;strong&gt;상황에 따라 실무와 너무 동떨어진 이야기이면 팀원들의 사기는 저하된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;그럼 반대로, 일을 잘하기 위해선 어떻게 해야 하나? 뭐… “이론에 집중하지 말고, 직접 해봐!” 아니겠나… 영상 편집 잘하고 싶으면 서울대학교 영상미디어학과(? 있긴 한가 ?) 수업 자료 구해다가 열심히 공부하지 말고, 비디오 클래스 영상 편집 강의 들으면서 브이로그 채널이라도 시작해보라. 웹 서비스 개발해보고 싶으면 C++이나 컴퓨터공학 기초 이론부터 듣지 말고, 직접 서비스 하나라도 구글링해 만들어보라. 마케팅 잘하고 싶으면 “그로스 해킹” 책 읽으며 방법론을 다질 시간에 직접 만든 제품을 어떻게 팔지 고민해보아야 한다. 일하다 필요할 때에 “그로스 해킹” 책을 자연스럽게 찾게 될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;실무는 방법론이 전부가 아니다.&lt;/strong&gt; 실전은 다르다. 그렇기 때문에 나는 미래에 함께 일하게 될 사람을 구할 땐, 언제나 방법론 척척박사보다 직접 손을 더럽힐 줄 아는 실무자를 찾겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/46/justdoit.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="예민한개발자입니다" /><category term="일" /><category term="협업" /><category term="사설" /><summary type="html">애자일 방법론, 린 스타트업, 그로스 해킹 등 기존 시장의 성장곡선을 가파르게 추월해야 살아남을 수 있는 스타트업 업계에서는 성공적인 사례들을 바탕으로 한 다양한 방법론들이 존재한다. 그리고 그 방법론들은 “이렇게 하면 너도 성공할 거야”에 대한 이야기를 해주기 때문에 굉장히 재밌고 인기가 많다.</summary></entry><entry><title type="html">DDD 했더니 비대해지는 엔티티, 좋은 대책은 ?</title><link href="http://jaynewho.com/post/45" rel="alternate" type="text/html" title="DDD 했더니 비대해지는 엔티티, 좋은 대책은 ?" /><published>2020-03-24T22:34:50+09:00</published><updated>2020-03-24T22:34:50+09:00</updated><id>http://jaynewho.com/post/45</id><content type="html" xml:base="http://jaynewho.com/post/45">&lt;p&gt;혹시 DDD (Domain Driven Development) 나 클린 아키텍처를 들어본 적 있으십니까? 만약 당신이 개발자라면 서점의 컴퓨터 관련 서적이나 페이스북 커뮤니티, 혹은 기술 블로그 등에서 한두 번쯤 들어보셨을 수 있습니다. 그럼 더 나아가서, DDD 나 클린 아키텍처를 프로젝트에 적용해보신 적이 있나요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/45/diagram.png&quot; alt=&quot;DDD/Untitled%201.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DDD (우리말로는 “도메인 주도 개발”)과 클린 아키텍처에서 비즈니스 애플리케이션은 크게 세 계층으로 이루어집니다. 바로 Pesenter (표현 계층) , UseCase (유즈 케이스 계층) , 그리고 Entity (엔티티 계층) 인데요. Presenter는 비즈니스 애플리케이션의 귀와 입으로, 비즈니스 애플리케이션의 사용 명세라고 할 수 있습니다. 만약 MVC 구조를 따르는 웹 애플리케이션이라면 Controller 계층과 View 계층이 해당 계층에 속한다고 할 수 있겠네요.&lt;/p&gt;

&lt;p&gt;UseCase 계층은 말 그대로 “유즈 케이스”를 정의하고 구현합니다. 유즈 케이스는 “사용자 행위 명세” , “유저 시나리오”와 같은 뜻으로 풀이될 수 있습니다. 만약 당신의 애플리케이션이 쇼핑몰 서버라면, “사용자가 주문하기” 나 “판매자가 주문의 배송 상태를 변경하기” 등의 행위 등이 유즈 케이스가 될 것입니다. Service 레이어라는 이름으로 흔히 부릅니다.&lt;/p&gt;

&lt;p&gt;Entity 계층은 애플리케이션의 비즈니스 로직을 담는 비즈니스 객체로 이루어져 있습니다. 비즈니스 객체는 엔티티, 도메인 객체 등의 이름으로도 불리고요. 다시 쇼핑몰 서버 애플리케이션을 예로 들면, “주문”이라는 엔티티 안에는 당신의 쇼핑몰 서비스에서 주문 관련한 로직들과 상태들을 거의 모두 가지고 있어야 합니다.&lt;/p&gt;

&lt;p&gt;DDD와 클린 아키텍처에서는 UseCase와 Entity 레이어를 작성할 때, Entity 레이어의 “비즈니스 객체”에 최대한 많은 비즈니스 룰을 담아, 응집성을 높이고 중복을 줄이는 코드를 작성하라고 말합니다. 만약 그렇게 작성하지 않으면 어떻게 될까요? UseCase 레이어의 코드는 방대해지고, 각기 다른 유즈 케이스에서 사용되는 동일한 로직들의 중복과 파편화가 증가하고, 코드 응집성은 줄어들어 유지보수가 어려울 것입니다.&lt;/p&gt;

&lt;p&gt;아래의 사진은 유명한 Use Case 명세표입니다. 그리고 굵은 글씨로 쓰여있는 것은 클린 아키텍처에서 “엔티티 레이어에 작성하라” 고 권하는 로직입니다. 핵심 비즈니스 룰이기 때문에, 여러 유즈 케이스에서 공통적으로 쓰일 것이기 때문이죠.&lt;/p&gt;

&lt;p&gt;만약 굵은 글씨의 비즈니스 룰들이 엔티티가 아닌 서비스 레이어에 드러났다면 어땠을까요? 아래 예시는 ATM 인출 유즈 케이스인데요. 만약 이를 작성한 한참 이후에 다른 개발자가 ATM 입금 유즈 케이스를 개발하려고 한다면, 해당 ATM 인출 로직에 사용되는 “사용자 Valid 검증”, “사용자 PIN 번호 체크” 등을 모두 재 구현해야 할 것입니다. (혹은 재 구현하기 싫어서 리펙토링으로 응집성이 높아지는 구조로 개선하겠죠.) 유지보수 시에나 신기능 개발 시에나 적지 않은 개발 비용으로 돌아올 것입니다. 그 개발 비용은 누적되어서 기업 전체의 성과를 좌지우지할 것입니다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/45/usecase.jpg&quot; alt=&quot;DDD.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Entity 계층에 도메인 룰을 최대한 모으면 좋은 점은 이뿐만이 아닙니다. 대부분의 언어에서 클린 아키텍처 패턴을 구현하면 Entity 객체는 Plain 객체로 작성합니다. (java에서는 POJO라고 부릅니다.) Plain 객체란 순수히 해당 언어의 클래스 문법으로만 작성되고, 그 어떤 프레임워크나 외부 종속 없이도 테스 터블 한 객체입니다. 이런 Plain 객체는 테스트하기 매우 용이해서, 더 많은 테스트 코드를 작성하게 하는 순기능이 있습니다.&lt;/p&gt;

&lt;p&gt;그래서 우선…&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클린 아키텍처나 DDD를 적용해보지 않으셨다면, 관련된 글을 읽어보시고 주장하는 패턴들을 이해하신 후 조금씩 적용해보시길 추천드립니다.&lt;/li&gt;
  &lt;li&gt;클린 아키텍처와 DDD를 하고 있는데, 엔티티 계층은 날씬하고 서비스 계층이 비대하시다면, 서비스 계층의 로직들을 최대한 엔티티 계층으로 끌어내려보시는 걸 추천드립니다. 대부분의 서비스 계층은 결국 엔티티 객체들을 불러와서 메서드들을 호출하는 역할만으로도 충분하다는 것을 발견하실 거예요. 그리고 로직의 응집성이 엄청 상승하는 것을 느끼실 겁니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;제가 일하는 개발팀에서도 1번과 2번을 잘 실천하고 있습니다. (쇼핑몰 시스템을 만들고 있습니다.) 물론 처음부터 잘하던 건 아니었어요. 처음에는 클린 아키텍처나 DDD 패턴에 대한 학습이 부족해, 서비스 계층에 절차적으로 로직을 풀어쓰기 다반사였습니다. 그러나 차츰차츰 응집성 있게 엔티티를 살찌워나갔고 (?), 그 결과 서비스 계층은 날씬해지고 코드 응집성은 크게 높아졌어요.&lt;/p&gt;

&lt;p&gt;그런데 커머스 시스템이 담당해야 하는 기능이 많다 보니, 계속 새로운 기능을 개발할 때마다 엔티티 객체 파일이 점점 1000줄, 심하면 2000-3000줄까지 늘어나기 시작했습니다. 여러 상황에 쓰이는 도메인 객체일수록 더 심했어요. 예를 들어 “주문” 도메인은 “사용자의 주문 신청”에 필요한 로직, “판매자의 정산 관리”에 필요한 로직, “주문의 반품 환불 처리”에 필요한 로직 등 너무 다양한 상황에 필요한 로직을 모두 담다 보니, 로직의 응집성은 좋아지고 중복은 줄었지만 불편한 점이 이만저만이 아니었습니다. &lt;strong&gt;주문 엔티티가 너무 커서 원하는 메서드를 탐색하기가 점점 어려워졌고, 여러 명이 하나의 거대 파일을 함께 수정하다 보니 버전 관리 도구 (Git)에서 충돌이 잦아졌습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* 3000줄 짜리 주문 엔티티 객체. 하나의 엔티티 객체에 반품, 환불, 정산, 출고, 주문내역 조회 
* 등 모든 책임이 집중되어있다. &quot;주문&quot; 이라는 관심사로 모으기 시작했지만, 너무 방대해져서 하위 
* 관심사들로 나눌 수 있게 됨. 
*/&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// ... 여러 관심사에 필요한 속성들이 모두 정의됨&lt;/span&gt;
  
  &lt;span class=&quot;cm&quot;&gt;/**
  * 판매자가 주문을 출고한다
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Export&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doExport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * 유저가 주문을 반품한다
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OrderReturn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;requestReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * 월말에 주문을 정산한다. 수정되면 안되는 중요한 코드.
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Price&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateAccountPrice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// ... 여러 관심사에 필요한 메서드들이 모두 정의됨 &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;한동안 마땅한 해결책 없이, 계속 엔티티 객체는 커져만 갔습니다. 그러던 어느 날, 상품의 세일 이벤트 시스템 프로젝트 개발을 시작해야 하는 날이 왔습니다. 상품 운영팀 분들이 상품의 세일 기간과 세일 가격을 예약하고, 해당 시점에 상품의 가격이 할인되는 기능인데요. (이 외에도 세부적인 기능들이 많지만 대표 기능은 그렇습니다) 해당 기능의 비즈니스 로직을 작성하기 위해 여느 때와 같이 “상품” 엔티티 파일을 열었는데, 그 순간 멈칫했습니다. ‘이미 3000줄을 넘어가는 이 클래스 파일에, 앞으로 세일 관련 로직을 1000줄 더 추가하면 감당이 안될 것이다!’&lt;/p&gt;

&lt;p&gt;그때 다짐했습니다. “이렇게 비대한 엔티티는 DDD와 클린 아키텍처를 주창하신 선배님들이 원하던 바가 아닐 것이다. 다시 DDD와 클린 아키텍처에서 해답을 찾아오리라!” 그리고는 ‘엔티티’, ‘분리’, ‘응집성’, ‘관심사’ 등의 키워드로 열심히 서칭을 했습니다.&lt;/p&gt;

&lt;h1 id=&quot;문제는-관심사의-분리-였다&quot;&gt;문제는 “관심사의 분리” 였다.&lt;/h1&gt;

&lt;p&gt;프로그래밍을 하다 보면, 과거 학부 시절 혹은 이론 공부 시절에 ‘에이 코드 짜는 데에 이런 게 중요하겠어?’ 하던 것들이 부메랑처럼 돌아와 “아! 중요한 것이었구나” 하는 것들이 있습니다. 이번에도 저는 또 기초 이론의 중요성을 통감했습니다. 결국 거대해진 엔티티의 원인은 “관심사의 분리 가 덜 되었기 때문”이었습니다. 관심사의 분리는 객체지향 설계 5원칙인 SOLID의 첫 번째에서도 강조되고, 소프트웨어 공학의 진리 정언처럼 여겨지는 ‘응집력은 높이고, 결합도는 낮춰라’라는 말과 관련이 깊죠. ‘관심사의 분리’는 하나의 객체는 여러 관심사를 책임지면 안 된다는 아주 간단하고도 중요한 원칙입니다.&lt;/p&gt;

&lt;p&gt;DDD에서는 이미 제게 하나의 도메인 안에서도 관심사를 분리하여 객체를 잘게 쪼개는 패턴을 소개해 주었습니다. 바로 “Bounded Context” 개념입니다. 다만 제가 처음 그 방법론을 읽었을 때, 받아들일 준비가 안되어있을 뿐이었죠. 필요성을 느끼고 다시 찾아가 읽으니 이해가 확 되더군요.&lt;/p&gt;

&lt;p&gt;Bounded Context는 &lt;strong&gt;“같은 도메인이어도, 사용되는 맥락이 다르면 엔티티를 별도로 매핑하라”라는 원칙&lt;/strong&gt;입니다. 제가 아까 상품 엔티티에 세일 관련 로직 1000줄을 추가하려고 했다고 했는데, 이때 “세일 콘텍스트”라는 패키지를 만들고, 그 안에 세일 관심사에 필요한 로직을 구현한 상품 엔티티를 새로 작성하면 관심사의 분리도 더 잘 되고 응집도도 높아집니다. 알고 나니 너무 당연하고 속이 시원한 방법이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/45/bc.png&quot; alt=&quot;DDD/Untitled%202.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에서 작성한 주문 엔티티를 Bounded Context 별로 따로 만들면, 각 객체의 책임이 더 명확해집니다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* 출고 맥락에서의 주문
*/&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;OrderForExport&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Export&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;


  &lt;span class=&quot;cm&quot;&gt;/**
  * 판매자가 주문을 출고한다
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Export&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doExport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
* 정산 맥락에서의 주문
*/&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;OrderForAccount&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * 월말에 주문을 정산한다. 수정되면 안되는 중요한 코드.
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Price&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateAccountPrice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
* 반품 맥락에서의 주문
*/&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;OrderForReturn&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OrderReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * 유저가 주문을 반품한다
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OrderReturn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;requestReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h1 id=&quot;걱정-코드-중복-오히려-생기지-않을까&quot;&gt;걱정. 코드 중복 오히려 생기지 않을까?&lt;/h1&gt;

&lt;p&gt;예전에 어렴풋이 Bounded Context 개념을 처음 봤을 때의 감정은 아마 이런 것들이었던 것 같습니다.&lt;/p&gt;

&lt;p&gt;“똑같은 도메인을 담당하는 객체를 하나가 아니라 여러 개를 만든다고? 그럼 코드의 중복이 늘어나는 것 아니야? 관리 비용이 너무 늘 것 같은데?”&lt;/p&gt;

&lt;p&gt;간단한 예로 상품의 할인율 계산 로직을 생각해보자면, 할인율 = 판매가/정상가 * 100인데, 이 로직은 어느 맥락에서나 상품이라면 거의 모두 사용되기 때문에, 상품 객체를 N개 만들면 각각의 객체에 N 번 작성해야 하죠.&lt;/p&gt;

&lt;p&gt;네, 일부 로직들의 중복이 증가하는 것은 사실입니다. 그뿐만 아니라 동일한 엔티티 속성을 N번 정의하게 되므로 전체 프로젝트의 코드의 양이 늘어나게 되죠. 그럼에도 Bounded Context 개념은 적용해볼 만한 가치가 있습니다. 프로젝트가 커지고 하나의 도메인 영역에서 여러 맥락의 일들이 일어나고 있으면, 일부 로직의 중복 증가에서 오는 비용보다, 관심사의 분리와 응집성 분리에서 오는 효용이 훨씬 큽니다. 이는 분리를 해보고 나니까 확실히 알겠더라고요.&lt;/p&gt;

&lt;p&gt;아래는 프로젝트에 직접 적용해보면서 느꼈던 &lt;strong&gt;Bounded Context의 장점들&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;“정산” 등 수정에 민감한 중요한 로직도 안전하게 분리하고 관리할 수 있다.&lt;/li&gt;
  &lt;li&gt;맥락 안에서의 도메인 로직들이 더 응집성 있게 모여서, 해당 맥락 한판을 이해하는데 더 도움이 된다.&lt;/li&gt;
  &lt;li&gt;같은 도메인이어도 맥락마다 참조를 필요로 하는 연관 도메인들이 다른데, 맥락에 필요한 관계만 최소한으로 매핑할 수 있어 N+1 문제 등 성능 문제가 다소(?) 해결된다.&lt;/li&gt;
  &lt;li&gt;같은 도메인이어도 맥락마다 사용되는 메서드가 매우 다르고, 모두 필요한 Global 한 도메인 로직은 생각보다 많지 않다. Context 분리로 얻는 효용이 일부 로직의 중복보다 효용이 크다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아래는 그럼에도 &lt;strong&gt;Bounded Context의 고려해야 할 점&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Bounded Context는 불가피하게 Global 한 도메인 로직의 중복이 발생한다. (ex. 할인율 계산) 팀 규모가 어느 정도 커서 Global 로직의 중복 비용을 감당할 수 있을 때 나누는 것이 좋다.&lt;/li&gt;
  &lt;li&gt;팀 규모와 맞는 적절한 Bounded Context 민감도를 정하는 것이 중요해 보인다. 팀이 감당할 수 없을 만큼 잘게 Bounded Context를 나누면, (극단적으로 5명의 개발팀이 상품 도메인 객체를 관심사별로 10개 나눔) 효용보다 비용이 커진다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;cqrs-도-크게-보면-맥락의-분리&quot;&gt;CQRS 도 크게 보면 맥락의 분리&lt;/h1&gt;

&lt;p&gt;CQRS는 Command and Query Responsibility Segregation, 즉 “명령과 조회의 책임 분리”를 통해 관심사 분리를 달성하는 소프트웨어 패턴입니다. 이 또한 DDD의 Bounded Context 개념과 함께 버무려 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;상품 도메인에서, “판매자의 상품 관리” 맥락용 상품 엔티티를 분리해 관리하고 있다고 가정해봅니다. 처음에는 판매자가 상품 리스트나 상품 상세를 조회하는 역할과, 판매자의 상품 수정 및 관리 기능들을 모두 담당했습니다. 그러나 점점 ‘판매자 상품 조회’와 ‘판매자 상품 수정 관리’의 책임과 범위가 커지면, 이를 분리하는 것이 좋을 것입니다. 이때 CQRS 패턴에 따라 Bounded Context를 ‘조회’와 ‘명령(수정 및 관리)’의 엔티티를 분리하면 더 높은 응집성을 가진 두 객체로 나뉠 것입니다.&lt;/p&gt;

&lt;p&gt;혹은 ‘조회’에 ORM 보다 성능이 나은 쿼리 기반의 로직이 필요하다면, CQRS를 통해 둘을 분리할 수도 있겠죠.&lt;/p&gt;

&lt;h1 id=&quot;그래서-지금-무엇을-해야할까&quot;&gt;그래서, 지금 무엇을 해야할까&lt;/h1&gt;

&lt;p&gt;그래서, 지금 우리 프로젝트에 무엇을 하면 좋을까요? 각자의 상황에 따라 다를 것입니다. 위에서 말씀드린 내용을 일부 반복하겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클린 아키텍처나 DDD를 적용해보지 않으셨다면, 관련된 글을 읽어보시고 주장하는 패턴들을 이해하신 후 조금씩 적용해보시길 추천드립니다.&lt;/li&gt;
  &lt;li&gt;클린 아키텍처와 DDD를 하고 있는데, 엔티티 계층은 날씬하고 서비스 계층이 비대하시다면, 서비스 계층의 로직들을 최대한 엔티티 계층으로 끌어내려보시는 걸 추천드립니다. 대부분의 서비스 계층은 결국 엔티티 객체들을 불러와서 메서드들을 호출하는 역할만으로도 충분하다는 것을 발견하실 거예요. 그리고 로직의 응집성이 엄청 상승하는 것을 느끼실 겁니다.&lt;/li&gt;
  &lt;li&gt;엔티티에 비즈니스 로직 몰빵은 잘하고 있는데, 엔티티가 너무 커지고 관심사별로 분리가 잘 안된다고 느끼시나요? Bounded Context 개념을 적용해보세요. 같은 도메인이어도 관심사가 다르면 더 하위의 도메인으로 나뉘어야 합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;--광고--스타일쉐어-커머스-시스템을-함께-만드실-백엔드-개발자-동료분을-찾고-있어요&quot;&gt;📢 ( 광고 ) 스타일쉐어 커머스 시스템을 함께 만드실 백엔드 개발자 동료분을 찾고 있어요&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/45/styleshare.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 몸담고 있는 스타일쉐어의 커머스 개발팀은 일하는 동료들 모두가 “어떻게하면 함께 문제를 더 잘 해결할까?” 를 함께 고민하는 팀이라고 자부합니다. 개발자 개개인에게 많은 의사 결정 권한이 주어지고, 또 그만큼 개발적 의사 결정에 대한 설득과 그 결과에 대한 책임을 고민할 수 있는 성장하기 좋은 일터입니다.&lt;/p&gt;

&lt;p&gt;함께 커머스 도메인에 존재하는 수많은 문제의 해결을 위해 고민할 팀원을 찾고 있습니다. 많은 지원 부탁드려요 🙂&lt;/p&gt;

&lt;p&gt;(편하게 여쭤보고 싶은 점이 있으시다면 제 개인 메일인 shinjayne@gmail.com 로 가볍게 연락 주셔도 괜찮습니다!)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;스타일쉐어는 대한민국 1525 인구의 절반 이상이 사용하는 No.1 패션 서비스 StyleShare를 운영하는 회사입니다.&lt;/p&gt;

  &lt;p&gt;스타일쉐어는 이전의 e커머스 회사들과는 차별화된 서비스를 제공하며, 변화하는 시대에 맞춰 M·Z 세대의 최적화된 패션·뷰티 쇼핑 채널로 거듭나고 있습니다.&lt;/p&gt;

  &lt;p&gt;높은 충성도와 19%에 달하는 구매 전환율을 기반으로 2018년 12월 기준 연 거래액 1,200억(29CM 연결 기준)을 달성했습니다. 
2018년 3월에는 온라인 셀렉트샵 ‘29CM’을 인수하여 10대부터 30대까지를 아우르는 패션 커머스 기업으로 거듭났습니다.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.wanted.co.kr/wd/5313&quot;&gt;Wanted - 스타일쉐어 커머스 백엔드 개발자 채용 공고&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.notion.so/styleshare/2ae1e1e8dc964a5592f397980e2bc2d4&quot;&gt;Notion 채용 공고 페이지 - 스타일쉐어 커머스 개발자&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;글을-쓰기-전-참고한-함께-읽어보면-좋은-글&quot;&gt;글을 쓰기 전 참고한, 함께 읽어보면 좋은 글.&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@younghyun/%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%ED%8C%8C%ED%8A%B81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-vs-%EB%8F%84%EB%A9%94%EC%9D%B8-236c7008ac83&quot;&gt;아키텍처의 발전과정 Part1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@younghyun/clean-architecture-part-2-the-clean-architecture-3e2666cdce83&quot;&gt;아키텍처의 발전과정 Part2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://nesoy.github.io/articles/2018-07/DDD-Bounded-Context&quot;&gt;Bounded Context : DDD&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)&quot;&gt;객체 지향 설계 원칙 : SOLID&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;소프트웨어 공학 : 높은 응집력, 낮은 결합력&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="cleanarchitecture" /><category term="ddd" /><category term="architecture" /><category term="boundedcontext" /><summary type="html">혹시 DDD (Domain Driven Development) 나 클린 아키텍처를 들어본 적 있으십니까? 만약 당신이 개발자라면 서점의 컴퓨터 관련 서적이나 페이스북 커뮤니티, 혹은 기술 블로그 등에서 한두 번쯤 들어보셨을 수 있습니다. 그럼 더 나아가서, DDD 나 클린 아키텍처를 프로젝트에 적용해보신 적이 있나요?</summary></entry><entry><title type="html">동시성 문제 - 비즈니스 애플리케이션 (Part 3)</title><link href="http://jaynewho.com/post/44" rel="alternate" type="text/html" title="동시성 문제 - 비즈니스 애플리케이션 (Part 3)" /><published>2020-03-07T00:41:50+09:00</published><updated>2020-03-07T00:41:50+09:00</updated><id>http://jaynewho.com/post/44</id><content type="html" xml:base="http://jaynewho.com/post/44">&lt;blockquote&gt;
  &lt;p&gt;시리즈&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/post/42&quot;&gt;Part 1 : 동시성 문제 - 일반론&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/post/43&quot;&gt;Part 2  : 동시성 문제 - 데이터베이스와 JPA&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;Part 3 : 동시성 문제 - 비즈니스 애플리케이션 &lt;strong&gt;(NOW)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞선 글들에서 소개한 동시성 문제에 관련한 일반론을 비즈니스 애플리케이션의 개발에서도 이용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;일반론 파트에서 다루었다시피, 비즈니스 애플리케이션에서의 동시성 문제도 읽고→쓰는 프로세스에서 발생합니다.&lt;/p&gt;

&lt;h1 id=&quot;쇼핑몰-시스템에서의-주문과-재고-차감&quot;&gt;쇼핑몰 시스템에서의 주문과 재고 차감&lt;/h1&gt;

&lt;p&gt;우리가 물건을 파는 쇼핑몰 커머스 시스템을 개발하고 있다고 생각해봅니다. 그 중에서도 고객이 물건을 주문하는 과정의 비즈니스 로직을 개발하고 있습니다.  고객의 주문을 처리하는 과정을 도식화해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/44/1.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;재고 남았는지 확인&lt;/li&gt;
  &lt;li&gt;가격을 계산하고 → 주문서를 작성하고 → 결제를 요청&lt;/li&gt;
  &lt;li&gt;재고를 차감&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 때, 하나의 상품에 동시에 여러 주문이 들어올 때 발생할 수 있는 동시성 문제는 무엇일까요? 네, 바로 &lt;strong&gt;“손실되는 업데이트”&lt;/strong&gt; 입니다.  아래의 그림을 살펴보시죠.&lt;/p&gt;

&lt;p&gt;(참고로 한번 읽어온 데이터는 메모리에 저장하는 애플리케이션의 특성을 가정합니다. 또다른 동시성 문제인 “일관성 없는 읽기”의 문제는 따라서 논외가 됩니다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/44/2.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;고객이 주문을 한 시점에는 재고가 2개였지만, 주문을 처리하는 과정 중 먼저 누군가 2개를 모두 주문해가면서 재고를 2 차감했습니다. 따라서 재고는 0이 되었죠. 하지만 현재 이 고객의 주문 세션에서는 주문이 모두 끝난 뒤 재고를 2에서 1로 업데이트하기 때문에, 손실되는 업데이트가 발생하게 됩니다. 재고는 더이상 믿을 수 없는 값이 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;낙관적-잠금을-통한-해결&quot;&gt;낙관적 잠금을 통한 해결&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/44/3.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동시성 제어 기법 중 하나인 낙관적 잠금 기법을 이용해 아키텍처를 구성하면 믿을 수 없는 재고값 문제를 해결할 수 있습니다.  하지만 전체 프로세스 중에 Transaction 의 원자성을 보장하지 못하게 하는 “외부 시스템 연동” 같은 과정이 있다면, 낙관적 잠금은 사용하기 어렵습니다. 낙관적 잠금은 전체 프로세스의 실패를 마지막 저장 시도 시점에 알 수 있는데, 원자적으로 Rollback 이 어려운 프로세스라면 전체 시스템의 정합성이 깨지기 때문입니다.&lt;/p&gt;

&lt;p&gt;(마지막에 재고 차감에서 충돌이 일어나 주문은 실패하였는데, 외부 결제 시스템 호출은 이미 일어나서 고객의 돈이 빠져 나간다면 시스템의 큰 문제일 것입니다.)&lt;/p&gt;

&lt;p&gt;이런 경우, 시스템의 활동성을 조금 포기하더라도 정확성을 높일 수 있는 “비관적 잠금” 을 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;비관적-잠금을-통한-해결&quot;&gt;비관적 잠금을 통한 해결&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/44/4.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비지니스 어플리케이션에서의 비관적 잠금은 보통 동일한 작업을 하는 프로세스들 중 단 하나만이 점유할 수 있는 리소스 (Lock 혹은 Semaphore) 를 이용해 구현합니다. 한 프로세스가 재고 차감에 대한 Lock 을 점유하고 있다면, 현재 주문하려는 고객은 그 Lock 점유가 해제될 때까지 기다렸다가 프로세스를 실행합니다.  모든 주문 프로세스가 순차적으로 진행되는 것이죠.&lt;/p&gt;

&lt;p&gt;비관적 잠금은  낙관적 잠금에 비해 활동성은 줄어들어 주문이 몰리는 시점에 고객은 더 느린 주문을 경험하겠지만, 결제만 되고 취소가 되는 등의 부정확한 시스템을 경험하게 될 확률은 그만큼 줄 것입니다.&lt;/p&gt;</content><author><name></name></author><category term="concurrency" /><category term="architecture" /><category term="enterprise" /><category term="database" /><category term="jpa" /><summary type="html">시리즈 Part 1 : 동시성 문제 - 일반론 Part 2 : 동시성 문제 - 데이터베이스와 JPA Part 3 : 동시성 문제 - 비즈니스 애플리케이션 (NOW)</summary></entry><entry><title type="html">동시성 문제 - 데이터베이스와 JPA (Part 2)</title><link href="http://jaynewho.com/post/43" rel="alternate" type="text/html" title="동시성 문제 - 데이터베이스와 JPA (Part 2)" /><published>2020-03-06T01:31:50+09:00</published><updated>2020-03-06T01:31:50+09:00</updated><id>http://jaynewho.com/post/43</id><content type="html" xml:base="http://jaynewho.com/post/43">&lt;blockquote&gt;
  &lt;p&gt;시리즈&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/post/42&quot;&gt;Part 1 : 동시성 문제 - 일반론&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;Part 2  : 동시성 문제 - 데이터베이스와 JPA &lt;strong&gt;(NOW)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/post/44&quot;&gt;Part 3  : 동시성 문제 - 비즈니스 애플리케이션&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞선 글에서 특정 시스템에 종속되지 않는 &lt;strong&gt;동시성 문제의 일반론&lt;/strong&gt;에 대해서 정리해보았습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동시성 문제는 2개 이상의 세션이 “읽고 쓰기 Read→Write” 하려고 할 때 발생한다.&lt;/li&gt;
  &lt;li&gt;동시성 문제는 크게 “일관성 없는 읽기” 와 “손실되는 업데이트” 로 나뉜다.&lt;/li&gt;
  &lt;li&gt;“일관성 없는 읽기” 는 불변성-복사본으로 해결한다.&lt;/li&gt;
  &lt;li&gt;“손실되는 업데이트” 는 낙관적 잠금과 비관적 잠금으로 해결한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이번 글에서는 데이터베이스 시스템과 JPA 에서는 동시성 문제를 어떻게 제어하는지 알아보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;데이터베이스의-동시성-제어&quot;&gt;데이터베이스의 동시성 제어&lt;/h1&gt;

&lt;p&gt;데이터베이스 시스템에서 세션은 “트랜잭션 (Transaction)” 입니다.&lt;/p&gt;

&lt;p&gt;Transaction 의 특성 4가지 ACID 중 Isolation 은 바로 트랜잭션의 동시성 제어와 깊이 관련이 있습니다.&lt;/p&gt;

&lt;p&gt;바로 이 Isolation 의 정도를 나타내는 Isolation Level 4가지가, 데이터베이스 동시성 제어의 핵심입니다.&lt;/p&gt;

&lt;p&gt;각각의 레벨에 따라 “일관성 없는 읽기” 와 “손실되는 업데이트” 가 해결되는지 확인해보겠습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Isolation Level&lt;/th&gt;
      &lt;th&gt;“일관성 없는 읽기” 해결되나?&lt;/th&gt;
      &lt;th&gt;“손실되는 업데이트” 해결되나?&lt;/th&gt;
      &lt;th&gt;일반론&lt;/th&gt;
      &lt;th&gt;“정확성과 활동성”&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Serializable&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;비관적 잠금으로 두 문제 모두 해결&lt;/td&gt;
      &lt;td&gt;정확성은 높으나 활동성 매우 낮음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Repeatable Read&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;복사본 사용으로 “일관성 없는 읽기” 해결&lt;/td&gt;
      &lt;td&gt;적절한 타협. 대부분 DBMS 의 기본값.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Read Committed&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;복사본을 사용하지 않아서 읽기에 일관성이 없음&lt;/td&gt;
      &lt;td&gt;활동성 (동시성) 이 매우 높음&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;Read Uncommitted 를 논외로 한 이유는 RDBMS 표준에서는 격리수준으로 인정하지 않기 때문입니다.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;jpa-의-동시성-제어&quot;&gt;JPA 의 동시성 제어&lt;/h1&gt;

&lt;p&gt;JPA 시스템에서의 세션은 하나의 JPA Transaction 입니다. JPA에서의  읽기 쓰기 동시성은 Entity 객체와 관련이 있습니다.&lt;/p&gt;

&lt;p&gt;Entity 객체를 한번 조회하면 JPA 의 영속성 컨텍스트 (Persistance Context) 에 캐시되기 때문에, 세션 (JPA Transaction) 내에서의 “일관성 없는 읽기” 의 문제는 없습니다.&lt;/p&gt;

&lt;p&gt;그렇다면 JPA 는 “손실되는 업데이트” 문제를 어떻게 제어할까요?  JPA 는 Entity 단위의 낙관적 잠금과 비관적 잠금을 제공합니다.&lt;/p&gt;

&lt;h2 id=&quot;jpa-낙관적-잠금&quot;&gt;JPA 낙관적 잠금&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/43/2.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JPA 의 버전 관리 기능 ( &lt;code class=&quot;highlighter-rouge&quot;&gt;@Version&lt;/code&gt; )을 이용해 Entity 의 버전을 관리해 낙관적 잠금을 구현합니다. Application Level 에서의 잠금이며,  낙관적 잠금이므로 두번째 세션이 Write 하기 전까지는 충돌을 알 수 없습니다.&lt;/p&gt;

&lt;p&gt;활동성은 높일 수 있지만, 잘 진행되고 있던 프로세스가 변경 사항을 저장하려고 할 때 까지 프로세스의 성패를 예측할 수 없다는 것이 단점입니다.&lt;/p&gt;

&lt;h2 id=&quot;jpa-비관적-잠금&quot;&gt;JPA 비관적 잠금&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/43/1.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터베이스가 제공하는 lock 기능을 이용해 엔티티를 영속 상태로 올릴 때부터 다른 세션에서 조회하지 못하도록 잠금을 걸어둡니다. ( &lt;code class=&quot;highlighter-rouge&quot;&gt;select for update&lt;/code&gt; 구문이라고 생각할 수 있습니다. )&lt;/p&gt;

&lt;p&gt;역시 비관적 잠금인만큼, 활동성은 매우 저하되지만 정확성과 세션의 성공은 보장됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 다음 글  : &lt;a href=&quot;/post/44&quot;&gt;동시성 문제 - 비즈니스 애플리케이션 (Part 3)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="concurrency" /><category term="architecture" /><category term="enterprise" /><category term="database" /><category term="jpa" /><summary type="html">시리즈 Part 1 : 동시성 문제 - 일반론 Part 2 : 동시성 문제 - 데이터베이스와 JPA (NOW) Part 3 : 동시성 문제 - 비즈니스 애플리케이션</summary></entry><entry><title type="html">동시성 문제 - 일반론 (Part 1)</title><link href="http://jaynewho.com/post/42" rel="alternate" type="text/html" title="동시성 문제 - 일반론 (Part 1)" /><published>2020-03-05T14:25:50+09:00</published><updated>2020-03-05T14:25:50+09:00</updated><id>http://jaynewho.com/post/42</id><content type="html" xml:base="http://jaynewho.com/post/42">&lt;blockquote&gt;
  &lt;p&gt;시리즈&lt;/p&gt;

  &lt;p&gt;Part 1 : 동시성 문제 - 일반론 &lt;strong&gt;(NOW)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;Part 2  : &lt;a href=&quot;/post/43&quot;&gt;동시성 문제 - 데이터베이스와 JPA&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/post/44&quot;&gt;Part 3  : 동시성 문제 - 비즈니스 애플리케이션&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;동시성 문제란 두 개 이상의 세션이 공통된 자원에 대해 모두 &lt;strong&gt;읽고 쓰는 작업(Read→Write)&lt;/strong&gt; 을 하려고 하는 경우 발생할 수 있는 문제를 말합니다.&lt;/p&gt;

&lt;p&gt;애플리케이션을 개발하다보면 여러 동시성 문제들을 만나고, 또 동시성 제어를 도와주는 여러 시스템들(데이터베이스 시스템, JPA 시스템 등) 을 보게됩니다.  이런 여러 시스템들이 제공하는 상세한 기능들은 모두 상이하지만, 동시성 문제를 정의하는 방식과 제어하는 이론적인 기틀은 모두 동일합니다.&lt;/p&gt;

&lt;p&gt;그래서 오늘은 특정 시스템에 종속되지 않는  &lt;strong&gt;동시성 문제와 제어 방법론&lt;/strong&gt;에 대해 정리하려고 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;동시성 문제에 “완전한 해결”은 없습니다. “제어”(적절한 해결) 만 있을 뿐입니다. 동시성 문제는 “정확성 과 활동성 을 어떻게하면 모두 최대로 할 수 있을까?” 에 대한 고민이기 때문입니다. 활동성 (얼마나 빠르게) 을 포기하면 정확성을 높일 수 있습니다. 마찬가지로 정확성(얼마나 올바른 데이터) 을 타협하면 활동성을 높일 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;동시성-문제와-제어-방법론&quot;&gt;동시성 문제와 제어 방법론&lt;/h1&gt;

&lt;p&gt;동시성 문제라고 불리우는 2가지 현상은 바로  “일관성 없는 읽기” 와 “손실되는 업데이트” 입니다.&lt;/p&gt;

&lt;h2 id=&quot;일관성-없는-읽기&quot;&gt;일관성 없는 읽기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/42/4.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;세션 2는 동시에 실행되고 있는 세션 1 때문에, 데이터에 접근하는 시점마다 다른 값을 읽게 됩니다. 이를 “일관성 없는 읽기” 라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;일관성-없는-읽기는-해결이-쉽다&quot;&gt;일관성 없는 읽기는 해결이 쉽다&lt;/h3&gt;

&lt;p&gt;일관성 없는 읽기는 해결이 쉽습니다. 바로 “불변성”, 복사본을 이용하면 됩니다. 세션 2가 최초로  데이터를 조회할 때 해당 데이터를 복사한 후, 이후에도 계속 사용하는 것입니다.  비록 세션 1이 변경한 데이터의 원장은 감지하지 못하더라도, 세션 2 내에서는 계속 동일한 복사본을 바라볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;손실되는-업데이트&quot;&gt;손실되는 업데이트&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/42/1.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;더 늦게 시작한 세션 2에 의해 세션 1의 변경사항이 무시되는 현상을 “손실되는 업데이트” 라고 합니다.&lt;/p&gt;

&lt;p&gt;데이터베이스 시스템, JPA 애플리케이션 시스템, 혹은 우리가 직접 조성하는 비즈니스 시스템에서 모두 중요하게 고려되어야 하는 문제입니다.&lt;/p&gt;

&lt;p&gt;“손실되는 업데이트” 를 방지하기 위한 방법으로는 크게 2가지가 있습니다. 바로 “낙관적 잠금” 과 “비관적 잠금” 입니다.&lt;/p&gt;

&lt;h3 id=&quot;낙관적-잠금&quot;&gt;낙관적 잠금&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/42/2.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“낙관적 잠금” 은 ‘저장 시 체크한다’ 입니다.  세션 1이 데이터 A 를 읽어왔더라도 세션 2는 자유롭게 데이터 A 를 읽어올 수 있습니다. 다만 저장하려고 할 때,  저장하려는 대상 데이터가 세션 2가 들고있던 데이터와 상이하면 저장이 되지 않습니다.&lt;/p&gt;

&lt;p&gt;낙관적 잠금을 구현하기 위해서는 공통된 리소스 A 에 대한 Versioning 이 되어야합니다. 세션 2가 들고 있는 A 의 Version 이, 저장하려는 대상 A 의 Version 과 같은지 체크해야하기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;비관적-잠금&quot;&gt;비관적 잠금&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/42/3.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“비관적 잠금” 은 ‘이미 읽고 있는 사람이 있다면, 나는 못읽어’ 입니다. 보수적인 잠금이라고 할 수 있겠죠. 낙관적 잠금에 비관적 잠금은 세션이 실패할 확률은 줄여주지만, 여러 세션의 “활동성” 은 높여주지 못합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 다음 글  : &lt;a href=&quot;/post/43&quot;&gt;동시성 문제 - 데이터베이스와 JPA (Part 2)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;참고 문헌 : 마틴 파울러의 “엔터프라이즈 애플리케이션 아키텍쳐 패턴”&lt;/em&gt;&lt;/p&gt;</content><author><name></name></author><category term="concurrency" /><category term="architecture" /><category term="enterprise" /><summary type="html">시리즈 Part 1 : 동시성 문제 - 일반론 (NOW) Part 2 : 동시성 문제 - 데이터베이스와 JPA Part 3 : 동시성 문제 - 비즈니스 애플리케이션</summary></entry><entry><title type="html">논리력은 멘탈 모델 + 지식 체계 다. 을 읽고</title><link href="http://jaynewho.com/post/41" rel="alternate" type="text/html" title="논리력은 멘탈 모델 + 지식 체계 다. &lt;슈퍼 씽킹&gt; 을 읽고" /><published>2020-03-01T00:12:50+09:00</published><updated>2020-03-01T00:12:50+09:00</updated><id>http://jaynewho.com/post/41</id><content type="html" xml:base="http://jaynewho.com/post/41">&lt;p&gt;“슈퍼 씽킹” 이란 책은 다음과 같은 주장으로 서문을 연다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;단편적인 사실들만 알고있는 것은 아무런 힘을 발휘하지 못한다. 사실들을 엮어 의미와 해석을 가능케 해주는 것을 “멘탈 모델” 이라고 하며, 이는 다양한 학문에서 유래하기도 하고, 살면서 자연스레 체득되기도 한다.&lt;/p&gt;

  &lt;p&gt;다양한 멘탈 모델들, 특히 모든 분야에 강력한 힘을 발휘하는 “슈퍼 모델” 들을 많이 익히면 “슈퍼 씽킹” 을 할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그리고 책의 구성은 저자가 살면서 습득한 다양한 슈퍼 멘탈 모델들을 나열하는 방식으로 되어있다.&lt;/p&gt;

&lt;p&gt;이 책이 전달하는 메세지가 책의 서문만을 읽고도 내게 큰 의미로 다가왔다. 그 이유를 이 글을 통해 설명하고자 한다.&lt;/p&gt;

&lt;p&gt;나는 “논리력” 이 내가 추구하는 중요한 능력이라는 사실을 최근에 자각했고 (논리적인 사고가 더 높은 생산성으로 이어진다고 믿기 때문이다), 그 “논리력” 이 강해지기 위해 필요한 것들을 찾으려 힘썼다. 그 중 첫 번째로 찾은 구성요소는 (어릴 적 부터 왠지 모르게 인생에서 중요하게 생각해온) “지식 체계” 다.&lt;/p&gt;

&lt;p&gt;한가지 새로운 지식을 습득해도 사람마다 흡수하는 속도가 다르다. 나는 이 차이를 발생시키는 원인을 지식 체계의 차이에서 찾았다.  자신이 쌓아온 지식 체계가 촘촘하고 빼곡할수록,  그 잘 짜여진 체 속에서 연관도가 높은 지식을 찾아, 새로운 지식을 빠른 속도로 배치할 수 있기 때문이다.  그리고 지식체계는 새로운 정보의 습득력 뿐만 아니라, 지금 상황에 딱 필요한 지식을 머릿속에서 검색하는 능력에도 강력한 힘을 발휘한다. 마치 인덱싱이 잘 된 데이터베이스가 검색 속도가 빠른 것과 같다.&lt;/p&gt;

&lt;p&gt;고도화된 지식 체계의 특성은  촘촘함 그리고 빼곡함인데, 이 두 특성 모두 개인이 얼마나 다양한 지식을 접했는가와 지식을 얼마나 체계적으로 정리할 수 있는 논리적 사고력을 갖췄는가 에 영향을 받는다.&lt;/p&gt;

&lt;p&gt;고도화된 지식 체계의 중요성을 설파하는 사람은 나뿐만이 아니다. 넷플릭스의 «Inside Bill Gates : 빌게이츠 다큐멘터리» 에서 빌게이츠도 자신의 독서습관을 소개하는 대목에서 지식 체계에 대해 언급한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘저는 제 머리 속의 지식의 틀 속에 새로운 지식들의 자리를 찾아 넣는 것을 좋아합니다.’ - &amp;lt; Inside Bill Gates : Netflix &amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;논리력이 강하려면 논리적 사고에 필요한 근거인 지식들이 수중에 많아야하고, 단순히 수중에 많은 것을 넘어서 빠르게 시의적절한 지식을 꺼내 논리의 근거로 사용할 수 있어야한다. 따라서 “고도화된 지식 체계” 는 논리력의 필요조건이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 항상 아쉬웠던 부분은 고도화된 지식 체계가 논리력 의 충분 조건은 아니라는 것이었다.  분명 논리력을 구성하는 요인이 지식 체계 외에 더 있다고 느끼고 있었는데, 이 슈퍼 씽킹이란 책의 서문과 목차를 읽고 바로 느꼈다. 내가 찾던 논리력 의 또 다른 필요 조건은 “다양한 멘탈 모델” 이였다는 것을.&lt;/p&gt;

&lt;p&gt;멘탈 모델이 무엇인지, 어떤 효용을 가지는지 와닿지 않는 분들이 있을 것이다. 그래서 다시 나의 글로 돌아가보자. 내가 이 글에서 작성한 다음의 두 글귀는 이 책의 영향을 받아, 평소에 내가 가지고 있던 멘탈 모델을 이용해 분석한 것이다.  첫 번째로 이 대목.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;‘그리고 지식체계는 새로운 정보의 습득력 뿐만 아니라, 지금 상황에 딱 필요한 지식을 머릿속에서 검색하는 능력에도 강력한 힘을 발휘한다. 마치 인덱싱이 잘 된 데이터베이스가 검색 속도가 빠른 것과 같다.’&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 대목에서 나는 컴퓨터공학에서 기인한 “데이터베이스의 인덱싱” 이라는 멘탈 모델을 이용해 지식 체계라는 보편적인 현상을 이해했다. (참고로 이 책에서는 이렇게 특정 학문적 영역에서 기인하였어도 보편적으로 효용을 줄 수 있는 멘탈 모델을 “슈퍼 모델” 이라고 부른다.)  만약 내가 이 멘탈 모델이 없었다면, 지식 체계의 중요성을 논리적으로 설명하지 못했을 수도 있고, 더 나아가서는 지식 체계의 중요성 자체를 인지하지 못했을 수도 있다.&lt;/p&gt;

&lt;p&gt;두번째로는 이 대목이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;‘고도화된 지식 체계가 논리력의 충분 조건은 아니라는 것이었다. 분명 논리력을 구성하는 요인이 지식 체계 외에 더 있다고 느끼고 있었는데, 이 슈퍼 씽킹이란 책의 서문과 목차를 읽고 바로 느꼈다. 내가 찾던 논리력의 또 다른 필요 조건은 “다양한 멘탈 모델” 이었다는 것을.’&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 대목에서는 “필요 충분 조건” 이라는 논리학에서 기인한 멘탈 모델을 사용한 것이다. 이 멘탈 모델을 사용하면 위 대목 뿐만 아니라 일상 생활의 다양한 부분에서 논리적 의존 관계를 더 쉽게 파악하고 다른 사람에게 설명할 수 있다. 멘탈 모델의 효용을 단적으로 보여주는 예이다.&lt;/p&gt;

&lt;p&gt;이렇듯 분명히 멘탈 모델은 똑같은 사실을 마주하더라도 더 빠르게 자신의 방식으로 현상을 해석할 수 있게 해주고, 논리적 결정의 속도와 근거력을 높여준다.  따라서 분명 멘탈 모델은 지식 체계와 더불어 논리력의 필요 조건이라고 할 수 있겠다.&lt;/p&gt;

&lt;p&gt;“슈퍼 씽킹” 이 서문에서부터 강조한 ‘슈퍼 씽킹을 하기 위한 슈퍼 멘탈 모델들의 중요성’ 은 나에게 위와 같은 생각을 하게 만들었고, 덕분에 나는 내가 중요하게 생각하는 “논리력” 에 필요한 중요한 요인을 또 하나 찾았다. 이는 내가 앞으로 책을 읽거나 새로운 정보를 얻었을 때, 지식 체계의 관점에서만이 아니라 새로운 멘탈 모델의 습득 관점에도 집중할 수 있게 해 줄 것이다. 이렇게 생각하니 정말 마음이 부푼다. 부푼 마음으로 서문에서 슈퍼 씽킹의 표지를 덮는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/41/bookcover.jpg&quot; alt=&quot;책&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="inspiration" /><category term="book" /><category term="logical" /><category term="thinking" /><summary type="html">“슈퍼 씽킹” 이란 책은 다음과 같은 주장으로 서문을 연다.</summary></entry><entry><title type="html">점을 연결하는 사람들 - ‘기획자의 습관’을 읽고</title><link href="http://jaynewho.com/post/40" rel="alternate" type="text/html" title="점을 연결하는 사람들 - '기획자의 습관'을 읽고" /><published>2019-08-08T21:30:50+09:00</published><updated>2019-08-08T21:30:50+09:00</updated><id>http://jaynewho.com/post/40</id><content type="html" xml:base="http://jaynewho.com/post/40">&lt;blockquote&gt;
  &lt;p&gt;«기획자의 습관» 을 읽고. 창의, 통찰, 연결, 기획에 대한 생각 정리.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;기획자의 습관이란 책을 읽고 있습니다.&lt;/p&gt;

&lt;p&gt;저자 최장순씨는 오랫동안 기획자로 일했고, 자신이 일상에서 어떻게 기획 아이디어를 이끌어내는지를 이 책에 담았습니다.&lt;/p&gt;

&lt;p&gt;첫 챕터의 첫번째 주제는 “엣지오브 투모로우”라는 영화입니다. 그는 이 영화를 관람하고, 마치 매일 반복되는 일상을 살면서 “내일의 가장자리” 에서 “내일” 로 넘어가지 못하는 우리의 삶을 떠올렸고, 니체의 “영원회귀” 사상을 떠올렸고, 니체의 저서 «차라투스트라는 이렇게 말했다» 의 “양치기소년이 뱀을 물어뜯은 후 ‘변화한 자’ 가 되었다”  란 이야기를 떠올렸습니다. 굉장히 통찰력 있는 연결이라고 생각합니다.&lt;/p&gt;

&lt;p&gt;저는 이렇게 통찰력 있는 연결이 굉장히 멋있다고 생각합니다. 사실 창의적인 아이디어, 대단한 기획은 세상에 이미 존재하는 것들을 새로운 관점에서 연결점을 찾아내고 새로운 방식으로 잘 연결하는 것입니다.&lt;/p&gt;

&lt;p&gt;스티브 잡스는 인터뷰에서 “어떻게 그렇게 창의적인 아이디어들을 낼 수 있나요?” 라는 질문을 받고 이렇게 답했다고 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“사실 저는 그런 이야기를 들을때마다 굉장히 부끄럽습니다. 저는 다른사람들과 크게 다르거나, 특별히 더 천재적이지 않기 때문이죠. 저는 그저 세상에 이미 존재하는 것들을, 이전과는 다른 방식으로 연결하는 것 뿐입니다. 그리고 저는 창의성이 바로 그런 것이라고 생각합니다. 따라서 창의성은 연습을 통해 기를 수 있습니다.”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;어떻게보면 제가 기획자의 습관이라는 책을 읽다가, 스티브잡스를 떠올린 것도 하나의 “새로운 연결” 을 찾아낸 것입니다. 이 또한 창의성을 발휘한 것이라고 볼 수 있겠죠.&lt;/p&gt;

&lt;p&gt;새로운 연결을 잘 찾아내는 것을 혹자는 “통찰” 이라고 표현합니다. 저는 “창의”, “통찰” 모두 맞다고 생각합니다.&lt;/p&gt;

&lt;p&gt;기획, 창의, 통찰, 연결. 모두 제게는 같은 말로 느껴집니다.&lt;/p&gt;

&lt;p&gt;“창의”, “통찰” 을 잘하기위해선 어떻게 훈련해야할까요? 일상에 존재하는, 혼자서는 무의미한 점들을 연결해 의미를 만들어내는 것, 어떻게하면 잘 할 수 있을까요?&lt;/p&gt;

&lt;p&gt;우선 첫째로는 재료가 될 점들을 많이 알아야하고, 둘째로는 점들간의 관통하는 아이디어를 끄집어내고 연결할 줄 아는 센스를 길려야한다고 생각합니다.&lt;/p&gt;

&lt;p&gt;재료가 되는 점들을 많이 알려면 책을 많이 읽고, 세상에 일어나는 일들에 많은 관심을 기울여야합니다.&lt;/p&gt;

&lt;p&gt;점들간의 관통하는 아이디어를 끄집어내고 연결하는 센스를 기르려면, 점들을 잘 연결하는 사람들의 이야기를 많이 듣고 보고 익혀야합니다. “창의” 는 스티브잡스의 말처럼, 훈련해서 기를 수 있는 “후천적 능력” 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/40/bookcover.jpg&quot; alt=&quot;책표지&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="inspiration" /><category term="book" /><category term="planning" /><summary type="html">«기획자의 습관» 을 읽고. 창의, 통찰, 연결, 기획에 대한 생각 정리.</summary></entry><entry><title type="html">JPA 의 Fetch Type 과 친해지기</title><link href="http://jaynewho.com/post/39" rel="alternate" type="text/html" title="JPA 의 Fetch Type 과 친해지기" /><published>2019-08-06T21:30:50+09:00</published><updated>2019-08-06T21:30:50+09:00</updated><id>http://jaynewho.com/post/39</id><content type="html" xml:base="http://jaynewho.com/post/39">&lt;p&gt;JPA 를 이용한 개발을 하다보면 자주 접하는 프로그래밍적인 이슈가 있습니다. 바로 &lt;strong&gt;Fetch Type (Fetch 전략)&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;Fetch Type 속성은 언제 동작하고 어떻게 동작하는지, 그리고 어떨 때 Fetch Type 때문에 N+1 문제가 발생하는지, 또 어떻게 해결하는지 알아봅니다.&lt;/p&gt;

&lt;p&gt;추가적으로, 이상하게 동작하는 OneToOne 의 FetchType LAZY 설정도 짚고 넘어갑니다.&lt;/p&gt;

&lt;p&gt;이 글을 이끌어가는데 도움을 주는 두 엔티티를 소개합니다. “주문” 과 “멤버” 라는 친구들입니다. 주문과 멤버는 N:1 의 관계에 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 주문 엔티티&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;order&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@ManyToOne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;member_id&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 멤버 엔티티&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;member&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Column&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@OneToMany&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orders&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;fetch-type-이란&quot;&gt;Fetch Type 이란&lt;/h1&gt;

&lt;p&gt;Fetch Type 은 JPA 가 하나의 Entity 를 조회할 때, 연관관계에 있는 객체들을 어떻게 가져올 것이냐를 나타내는 설정값입니다.&lt;/p&gt;

&lt;p&gt;Fetch Type 은 크게 Eager 와 Lazy 두가지 전략이 있습니다. Fetch Type Issue 상황이라는 것은 하나의 Entity 를 로드할 때, 아래의 두가지 전략 중 고민하는 상황을 말합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;연관 관계에 있는 Entity 들 모두 가져온다 → Eager 전략&lt;/li&gt;
  &lt;li&gt;연관 관계에 있는 Entity 가져오지 않고, getter 로 접근할 때 가져온다 → Lazy 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;fetch-type-어떻게-동작할까요&quot;&gt;Fetch Type 어떻게 동작할까요?&lt;/h1&gt;

&lt;h2 id=&quot;manytoone-컬럼-있을-때-주인일-때&quot;&gt;ManyToOne 컬럼 있을 때 (주인일 때)&lt;/h2&gt;

&lt;p&gt;Order Entity 는 단일 Member Entity 를 가지는 ManyToOne 컬럼이 있습니다. ( member 의 PK 가 Foreign Key 로 실제로 order DB컬럼에 매핑되어있으므로 Order 가 주인입니다. )&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ManyToOne 의 기본 FetchType 은 EAGER 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fetchtypeeager-기본&quot;&gt;FetchType=EAGER &lt;code class=&quot;highlighter-rouge&quot;&gt;기본&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;아래와같이, Join 을 통해 한번에 모든 쿼리를 가져옵니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	order.id,
	order.member_id,
	member.id,
	member.name
from order
outer join member
	on order.member_id=member.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;order 에 대한 for 문이 돌면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;order.getMember&lt;/code&gt; 를 호출했다고 합시다.&lt;/p&gt;

&lt;p&gt;이미 member 관련 정보가 Entity Manager 에 캐싱이 되어있기 때문에 추가적인 쿼리는 나가지 않을 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;fetchtypelazy&quot;&gt;FetchType=LAZY&lt;/h3&gt;

&lt;p&gt;Order List 를 가져오는 상황에서 &lt;strong&gt;N+1 Problem 이 발생할 수 있습니다&lt;/strong&gt;. Order List 를 불러온 뒤, 각 Member 에 대해 무언가를 하는 For Loop 가 코드에 있다면 말입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	order.id,
	order.member_id
from order;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 쿼리 결과가 아래와 같다고 합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;order.id&lt;/th&gt;
      &lt;th&gt;order.member_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1001&lt;/td&gt;
      &lt;td&gt;999&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1002&lt;/td&gt;
      &lt;td&gt;888&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1003&lt;/td&gt;
      &lt;td&gt;777&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;order 에 대한 for 문이 돌면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;order.getMember&lt;/code&gt; 를 호출했다고 합시다. 그럼 아래와 같이 3번의 쿼리가 더 발생할 것입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	member.id,
	member.name
from member
where member.id=999;

select
	member.id,
	member.name
from member
where member.id=888;

select
	member.id,
	member.name
from member
where member.id=777;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;onetomany-컬럼-있을-때-종일-때&quot;&gt;OneToMany 컬럼 있을 때 (종일 때)&lt;/h2&gt;

&lt;p&gt;Member Entity 에는 Order Entity Collection (List 혹은 Set) 을 가지는 OneToMany 컬럼이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OneToMany 의 기본 FetchType 은 LAZY 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fetchtypeeager&quot;&gt;FetchType=EAGER&lt;/h3&gt;

&lt;p&gt;Member List 를 가져오려고 해봅시다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	member.id,
	member.name
from member;

// member 가 2개 라면
// order set 땡겨오는 쿼리도 바로 2번 날라갑니다.

select
	order.id,
	order.member_id
from order
where member_id=999;

select
	order.id,
	order.member_id
from order
where member_id=888;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;member 를 가져오는 동시에 쿼리가 2방 더 날라갑니다. (이를 한번의 쿼리로 해결하려면 직접 JPQL 을 작성하거나 Query Builder 를 이용해 Fetch Join 을 해야합니다.)&lt;/p&gt;

&lt;h3 id=&quot;fetchtypelazy-기본&quot;&gt;FetchType=LAZY &lt;code class=&quot;highlighter-rouge&quot;&gt;기본&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Member List 를 가져오려고 해봅시다. 한번의 쿼리만 날라갑니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	member.id,
	member.name
from member;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;fetchtype-이-동작하는-시점&quot;&gt;FetchType 이 동작하는 시점&lt;/h1&gt;

&lt;p&gt;JPA Entity Manager 에 의해 관리되는 Persistence Context 에 Entity 가 Managed 상태로 올라올 때의 동작입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/39/39-persist-context.png&quot; alt=&quot;39-persist-context&quot; /&gt;&lt;/p&gt;

&lt;p&gt;queryDSL 과 같은 쿼리 빌더를 이용해 아무리 Join 문을 짜도, (Fetch Join 을 하지 않는 이상) 메인 도메인의 엔티티만 Persistence Context 에 올라옵니다. 연관관계에 대한 Fetch 도 메인 도메인만 일어납니다.&lt;/p&gt;

&lt;h1 id=&quot;n1-문제는-이럴-때-발생합니다&quot;&gt;N+1 문제는 이럴 때 발생합니다.&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ManyToOne, OneToOne 컬럼의 FetchType 을 LAZY 로 하였을 경우 발생합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;n1-은-어떻게-해결할까요&quot;&gt;N+1 은 어떻게 해결할까요?&lt;/h2&gt;

&lt;p&gt;N+1 이 발생하는 Entity 연관관계를 발견하였다면, 한 Entity 가 Managed 상태로 올라올 때, N+1 문제를 일으키는 Entity Collections 들도 동시에 Managed 상태로 올라오게 하면 됩니다.&lt;/p&gt;

&lt;p&gt;지금까지 크게 3가지 방법을 발견했습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;JPQL 의 Fetch Join 을 이용합니다. (QueryDSL 과 같은 쿼리빌더의 도움을 받을 수도 있습니다.)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ManyToOne, OneToOne 의 FetchType = LAZY → EAGER 로 변경합니다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@EntityGraph&lt;/code&gt; 를 이용해, 한 쿼리에 대해서만 EAGER load 를 지정합니다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;onetoone-의-fetchtype-lazy-는-사용자가-의도한대로-동작하지-않습니다&quot;&gt;OneToOne 의 FetchType LAZY 는 사용자가 의도한대로 동작하지 않습니다.&lt;/h1&gt;

&lt;p&gt;OneToOne 컬럼의 FetchType=LAZY 는 사용자가 의도한대로 동작하지도 않습니다! 아래의 글을 보시죠.&lt;/p&gt;

&lt;p&gt;OneToOne 의 FetchType=LAZY 는 컬럼을 조회하지 않아도 무조건 쿼리가 날라갑니다. 1번 날라갈 쿼리를 무조건 날라가는 2번의 쿼리로 바꿔치기 하는 셈 뿐입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wonwoo.ml/index.php/post/1566&quot;&gt;hibernate OneToOne lazy 구현하기&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;query-builder-를-이용하는-경우-onetoone-은-fetch-join-걸어주는게-좋습니다&quot;&gt;Query Builder 를 이용하는 경우, OneToOne 은 Fetch Join 걸어주는게 좋습니다.&lt;/h1&gt;

&lt;p&gt;쿼리 빌더를 이용해서 Order List 를 가져오는 쿼리를 짠다고 합시다. 예를 들면 queryDSL 기준으로 아래와 같이 짭니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Order&amp;gt; orders = jpaQueryFactory.select(qOrder).from(qOrder).fetch();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;개발자는 Order 의 Member 연관관계가 FetchType EAGER 로 설정되어있으므로, Order 와 Member 를 조인에서 한번에 가져와주는 쿼리가 나가길 기대할 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 쿼리 빌더를 이용하면, 사실 순수한 Order 에 대한 쿼리만 나가는 경우가 많습니다. 아래와 같이 말이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	order.id,
	order.member_id
from order;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이렇게 쿼리가 나가면, 복수개의 Order Entity 가 영속성 컨텍스트로 로드될 때 EAGER 로 설정된 Member 연관관계의 Fetch Type 이 동작하여 바로 N개의 단일 Member 쿼리가 나가게 됩니다. (FetchType 이 동작하는 시점은 영속성 컨텍스트로 로드될 때입니다.)&lt;/p&gt;

&lt;p&gt;따라서 Query Builder 를 이용해 JPQL 쿼리를 직접 작성할 경우, One To One 관계의 Entity 에 대해선 Fetch Join 을 걸어주는 것이 좋습니다.&lt;/p&gt;

&lt;h1 id=&quot;더-읽어보면-좋을-글&quot;&gt;더 읽어보면 좋을 글&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;N+1 문제를 해결하기 위한 방법들&lt;/strong&gt;을 잘 정리해놓은 글입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Fetch Join&lt;/code&gt; 을 이용하는 방법과 &lt;code class=&quot;highlighter-rouge&quot;&gt;@EntityGraph&lt;/code&gt; Annotation 을 이용하는 법을 소개하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jojoldu.tistory.com/165&quot;&gt;JPA N+1 문제 및 해결방안&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="java" /><category term="spring" /><category term="jpa" /><summary type="html">JPA 를 이용한 개발을 하다보면 자주 접하는 프로그래밍적인 이슈가 있습니다. 바로 Fetch Type (Fetch 전략) 입니다.</summary></entry></feed>