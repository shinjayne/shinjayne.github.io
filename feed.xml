<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://jaynewho.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://jaynewho.com/" rel="alternate" type="text/html" /><updated>2020-03-24T23:04:01+09:00</updated><id>http://jaynewho.com/</id><title type="html">Jayne.who();</title><subtitle>shinjayne`s Developer Blog. 신재인의 개발 블로그. Web / Deep Learning / Android / etc ...</subtitle><entry><title type="html">DDD 했더니 비대해지는 엔티티, 좋은 대책은 ?</title><link href="http://jaynewho.com/post/45" rel="alternate" type="text/html" title="DDD 했더니 비대해지는 엔티티, 좋은 대책은 ?" /><published>2020-03-24T22:34:50+09:00</published><updated>2020-03-24T22:34:50+09:00</updated><id>http://jaynewho.com/post/45</id><content type="html" xml:base="http://jaynewho.com/post/45">&lt;blockquote&gt;
  &lt;p&gt;🙏 정확한 이론 전달에 목적을 둔 글이 아닌 실제 프로젝트 적용기입니다. 다소 부실한 기반 이론이 있더라도 너그러운 피드백 부탁드립니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;혹시 DDD (Domain Driven Development) 나 클린 아키텍처를 들어본 적 있으십니까? 만약 당신이 개발자라면 서점의 컴퓨터 관련 서적이나 페이스북 커뮤니티, 혹은 기술 블로그 등에서 한두 번쯤 들어보셨을 수 있습니다. 그럼 더 나아가서, DDD 나 클린 아키텍처를 프로젝트에 적용해보신 적이 있나요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/45/diagram.png&quot; alt=&quot;DDD/Untitled%201.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DDD (우리말로는 “도메인 주도 개발”)과 클린 아키텍처에서 비즈니스 애플리케이션은 크게 세 계층으로 이루어집니다. 바로 Pesenter (표현 계층) , UseCase (유즈 케이스 계층) , 그리고 Entity (엔티티 계층) 인데요. Presenter는 비즈니스 애플리케이션의 귀와 입으로, 비즈니스 애플리케이션의 사용 명세라고 할 수 있습니다. 만약 MVC 구조를 따르는 웹 애플리케이션이라면 Controller 계층과 View 계층이 해당 계층에 속한다고 할 수 있겠네요.&lt;/p&gt;

&lt;p&gt;UseCase 계층은 말 그대로 “유즈 케이스”를 정의하고 구현합니다. 유즈 케이스는 “사용자 행위 명세” , “유저 시나리오”와 같은 뜻으로 풀이될 수 있습니다. 만약 당신의 애플리케이션이 쇼핑몰 서버라면, “사용자가 주문하기” 나 “판매자가 주문의 배송 상태를 변경하기” 등의 행위 등이 유즈 케이스가 될 것입니다. Service 레이어라는 이름으로 흔히 부릅니다.&lt;/p&gt;

&lt;p&gt;Entity 계층은 애플리케이션의 비즈니스 로직을 담는 비즈니스 객체로 이루어져 있습니다. 비즈니스 객체는 엔티티, 도메인 객체 등의 이름으로도 불리고요. 다시 쇼핑몰 서버 애플리케이션을 예로 들면, “주문”이라는 엔티티 안에는 당신의 쇼핑몰 서비스에서 주문 관련한 로직들과 상태들을 거의 모두 가지고 있어야 합니다.&lt;/p&gt;

&lt;p&gt;DDD와 클린 아키텍처에서는 UseCase와 Entity 레이어를 작성할 때, Entity 레이어의 “비즈니스 객체”에 최대한 많은 비즈니스 룰을 담아, 응집성을 높이고 중복을 줄이는 코드를 작성하라고 말합니다. 만약 그렇게 작성하지 않으면 어떻게 될까요? UseCase 레이어의 코드는 방대해지고, 각기 다른 유즈 케이스에서 사용되는 동일한 로직들의 중복과 파편화가 증가하고, 코드 응집성은 줄어들어 유지보수가 어려울 것입니다.&lt;/p&gt;

&lt;p&gt;아래의 사진은 유명한 Use Case 명세표입니다. 그리고 굵은 글씨로 쓰여있는 것은 클린 아키텍처에서 “엔티티 레이어에 작성하라” 고 권하는 로직입니다. 핵심 비즈니스 룰이기 때문에, 여러 유즈 케이스에서 공통적으로 쓰일 것이기 때문이죠.&lt;/p&gt;

&lt;p&gt;만약 굵은 글씨의 비즈니스 룰들이 엔티티가 아닌 서비스 레이어에 드러났다면 어땠을까요? 아래 예시는 ATM 인출 유즈 케이스인데요. 만약 이를 작성한 한참 이후에 다른 개발자가 ATM 입금 유즈 케이스를 개발하려고 한다면, 해당 ATM 인출 로직에 사용되는 “사용자 Valid 검증”, “사용자 PIN 번호 체크” 등을 모두 재 구현해야 할 것입니다. (혹은 재 구현하기 싫어서 리펙토링으로 응집성이 높아지는 구조로 개선하겠죠.) 유지보수 시에나 신기능 개발 시에나 적지 않은 개발 비용으로 돌아올 것입니다. 그 개발 비용은 누적되어서 기업 전체의 성과를 좌지우지할 것입니다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/45/usecase.jpg&quot; alt=&quot;DDD.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Entity 계층에 도메인 룰을 최대한 모으면 좋은 점은 이뿐만이 아닙니다. 대부분의 언어에서 클린 아키텍처 패턴을 구현하면 Entity 객체는 Plain 객체로 작성합니다. (java에서는 POJO라고 부릅니다.) Plain 객체란 순수히 해당 언어의 클래스 문법으로만 작성되고, 그 어떤 프레임워크나 외부 종속 없이도 테스 터블 한 객체입니다. 이런 Plain 객체는 테스트하기 매우 용이해서, 더 많은 테스트 코드를 작성하게 하는 순기능이 있습니다.&lt;/p&gt;

&lt;p&gt;그래서 우선…&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클린 아키텍처나 DDD를 적용해보지 않으셨다면, 관련된 글을 읽어보시고 주장하는 패턴들을 이해하신 후 조금씩 적용해보시길 추천드립니다.&lt;/li&gt;
  &lt;li&gt;클린 아키텍처와 DDD를 하고 있는데, 엔티티 계층은 날씬하고 서비스 계층이 비대하시다면, 서비스 계층의 로직들을 최대한 엔티티 계층으로 끌어내려보시는 걸 추천드립니다. 대부분의 서비스 계층은 결국 엔티티 객체들을 불러와서 메서드들을 호출하는 역할만으로도 충분하다는 것을 발견하실 거예요. 그리고 로직의 응집성이 엄청 상승하는 것을 느끼실 겁니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;제가 일하는 개발팀에서도 1번과 2번을 잘 실천하고 있습니다. (쇼핑몰 시스템을 만들고 있습니다.) 물론 처음부터 잘하던 건 아니었어요. 처음에는 클린 아키텍처나 DDD 패턴에 대한 학습이 부족해, 서비스 계층에 절차적으로 로직을 풀어쓰기 다반사였습니다. 그러나 차츰차츰 응집성 있게 엔티티를 살찌워나갔고 (?), 그 결과 서비스 계층은 날씬해지고 코드 응집성은 크게 높아졌어요.&lt;/p&gt;

&lt;p&gt;그런데 커머스 시스템이 담당해야 하는 기능이 많다 보니, 계속 새로운 기능을 개발할 때마다 엔티티 객체 파일이 점점 1000줄, 심하면 2000-3000줄까지 늘어나기 시작했습니다. 여러 상황에 쓰이는 도메인 객체일수록 더 심했어요. 예를 들어 “주문” 도메인은 “사용자의 주문 신청”에 필요한 로직, “판매자의 정산 관리”에 필요한 로직, “주문의 반품 환불 처리”에 필요한 로직 등 너무 다양한 상황에 필요한 로직을 모두 담다 보니, 로직의 응집성은 좋아지고 중복은 줄었지만 불편한 점이 이만저만이 아니었습니다. &lt;strong&gt;주문 엔티티가 너무 커서 원하는 메서드를 탐색하기가 점점 어려워졌고, 여러 명이 하나의 거대 파일을 함께 수정하다 보니 버전 관리 도구 (Git)에서 충돌이 잦아졌습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* 3000줄 짜리 주문 엔티티 객체. 하나의 엔티티 객체에 반품, 환불, 정산, 출고, 주문내역 조회 
* 등 모든 책임이 집중되어있다. &quot;주문&quot; 이라는 관심사로 모으기 시작했지만, 너무 방대해져서 하위 
* 관심사들로 나눌 수 있게 됨. 
*/&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// ... 여러 관심사에 필요한 속성들이 모두 정의됨&lt;/span&gt;
  
  &lt;span class=&quot;cm&quot;&gt;/**
  * 판매자가 주문을 출고한다
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Export&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doExport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * 유저가 주문을 반품한다
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OrderReturn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;requestReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * 월말에 주문을 정산한다. 수정되면 안되는 중요한 코드.
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Price&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateAccountPrice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// ... 여러 관심사에 필요한 메서드들이 모두 정의됨 &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;한동안 마땅한 해결책 없이, 계속 엔티티 객체는 커져만 갔습니다. 그러던 어느 날, 상품의 세일 이벤트 시스템 프로젝트 개발을 시작해야 하는 날이 왔습니다. 상품 운영팀 분들이 상품의 세일 기간과 세일 가격을 예약하고, 해당 시점에 상품의 가격이 할인되는 기능인데요. (이 외에도 세부적인 기능들이 많지만 대표 기능은 그렇습니다) 해당 기능의 비즈니스 로직을 작성하기 위해 여느 때와 같이 “상품” 엔티티 파일을 열었는데, 그 순간 멈칫했습니다. ‘이미 3000줄을 넘어가는 이 클래스 파일에, 앞으로 세일 관련 로직을 1000줄 더 추가하면 감당이 안될 것이다!’&lt;/p&gt;

&lt;p&gt;그때 다짐했습니다. “이렇게 비대한 엔티티는 DDD와 클린 아키텍처를 주창하신 선배님들이 원하던 바가 아닐 것이다. 다시 DDD와 클린 아키텍처에서 해답을 찾아오리라!” 그리고는 ‘엔티티’, ‘분리’, ‘응집성’, ‘관심사’ 등의 키워드로 열심히 서칭을 했습니다.&lt;/p&gt;

&lt;h1 id=&quot;문제는-관심사의-분리-였다&quot;&gt;문제는 “관심사의 분리” 였다.&lt;/h1&gt;

&lt;p&gt;프로그래밍을 하다 보면, 과거 학부 시절 혹은 이론 공부 시절에 ‘에이 코드 짜는 데에 이런 게 중요하겠어?’ 하던 것들이 부메랑처럼 돌아와 “아! 중요한 것이었구나” 하는 것들이 있습니다. 이번에도 저는 또 기초 이론의 중요성을 통감했습니다. 결국 거대해진 엔티티의 원인은 “관심사의 분리 가 덜 되었기 때문”이었습니다. 관심사의 분리는 객체지향 설계 5원칙인 SOLID의 첫 번째에서도 강조되고, 소프트웨어 공학의 진리 정언처럼 여겨지는 ‘응집력은 높이고, 결합도는 낮춰라’라는 말과 관련이 깊죠. ‘관심사의 분리’는 하나의 객체는 여러 관심사를 책임지면 안 된다는 아주 간단하고도 중요한 원칙입니다.&lt;/p&gt;

&lt;p&gt;DDD에서는 이미 제게 하나의 도메인 안에서도 관심사를 분리하여 객체를 잘게 쪼개는 패턴을 소개해 주었습니다. 바로 “Bounded Context” 개념입니다. 다만 제가 처음 그 방법론을 읽었을 때, 받아들일 준비가 안되어있을 뿐이었죠. 필요성을 느끼고 다시 찾아가 읽으니 이해가 확 되더군요.&lt;/p&gt;

&lt;p&gt;Bounded Context는 &lt;strong&gt;“같은 도메인이어도, 사용되는 맥락이 다르면 엔티티를 별도로 매핑하라”라는 원칙&lt;/strong&gt;입니다. 제가 아까 상품 엔티티에 세일 관련 로직 1000줄을 추가하려고 했다고 했는데, 이때 “세일 콘텍스트”라는 패키지를 만들고, 그 안에 세일 관심사에 필요한 로직을 구현한 상품 엔티티를 새로 작성하면 관심사의 분리도 더 잘 되고 응집도도 높아집니다. 알고 나니 너무 당연하고 속이 시원한 방법이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/45/bc.png&quot; alt=&quot;DDD/Untitled%202.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에서 작성한 주문 엔티티를 Bounded Context 별로 따로 만들면, 각 객체의 책임이 더 명확해집니다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* 출고 맥락에서의 주문
*/&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;OrderForExport&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Export&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;


  &lt;span class=&quot;cm&quot;&gt;/**
  * 판매자가 주문을 출고한다
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Export&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doExport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
* 정산 맥락에서의 주문
*/&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;OrderForAccount&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * 월말에 주문을 정산한다. 수정되면 안되는 중요한 코드.
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Price&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateAccountPrice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
* 반품 맥락에서의 주문
*/&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;OrderForReturn&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OrderReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * 유저가 주문을 반품한다
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OrderReturn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;requestReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h1 id=&quot;걱정-코드-중복-오히려-생기지-않을까&quot;&gt;걱정. 코드 중복 오히려 생기지 않을까?&lt;/h1&gt;

&lt;p&gt;예전에 어렴풋이 Bounded Context 개념을 처음 봤을 때의 감정은 아마 이런 것들이었던 것 같습니다.&lt;/p&gt;

&lt;p&gt;“똑같은 도메인을 담당하는 객체를 하나가 아니라 여러 개를 만든다고? 그럼 코드의 중복이 늘어나는 것 아니야? 관리 비용이 너무 늘 것 같은데?”&lt;/p&gt;

&lt;p&gt;간단한 예로 상품의 할인율 계산 로직을 생각해보자면, 할인율 = 판매가/정상가 * 100인데, 이 로직은 어느 맥락에서나 상품이라면 거의 모두 사용되기 때문에, 상품 객체를 N개 만들면 각각의 객체에 N 번 작성해야 하죠.&lt;/p&gt;

&lt;p&gt;네, 일부 로직들의 중복이 증가하는 것은 사실입니다. 그뿐만 아니라 동일한 엔티티 속성을 N번 정의하게 되므로 전체 프로젝트의 코드의 양이 늘어나게 되죠. 그럼에도 Bounded Context 개념은 적용해볼 만한 가치가 있습니다. 프로젝트가 커지고 하나의 도메인 영역에서 여러 맥락의 일들이 일어나고 있으면, 일부 로직의 중복 증가에서 오는 비용보다, 관심사의 분리와 응집성 분리에서 오는 효용이 훨씬 큽니다. 이는 분리를 해보고 나니까 확실히 알겠더라고요.&lt;/p&gt;

&lt;p&gt;아래는 프로젝트에 직접 적용해보면서 느꼈던 &lt;strong&gt;Bounded Context의 장점들&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;“정산” 등 수정에 민감한 중요한 로직도 안전하게 분리하고 관리할 수 있다.&lt;/li&gt;
  &lt;li&gt;맥락 안에서의 도메인 로직들이 더 응집성 있게 모여서, 해당 맥락 한판을 이해하는데 더 도움이 된다.&lt;/li&gt;
  &lt;li&gt;같은 도메인이어도 맥락마다 참조를 필요로 하는 연관 도메인들이 다른데, 맥락에 필요한 관계만 최소한으로 매핑할 수 있어 N+1 문제 등 성능 문제가 다소(?) 해결된다.&lt;/li&gt;
  &lt;li&gt;같은 도메인이어도 맥락마다 사용되는 메서드가 매우 다르고, 모두 필요한 Global 한 도메인 로직은 생각보다 많지 않다. Context 분리로 얻는 효용이 일부 로직의 중복보다 효용이 크다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아래는 그럼에도 &lt;strong&gt;Bounded Context의 고려해야 할 점&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Bounded Context는 불가피하게 Global 한 도메인 로직의 중복이 발생한다. (ex. 할인율 계산) 팀 규모가 어느 정도 커서 Global 로직의 중복 비용을 감당할 수 있을 때 나누는 것이 좋다.&lt;/li&gt;
  &lt;li&gt;팀 규모와 맞는 적절한 Bounded Context 민감도를 정하는 것이 중요해 보인다. 팀이 감당할 수 없을 만큼 잘게 Bounded Context를 나누면, (극단적으로 5명의 개발팀이 상품 도메인 객체를 관심사별로 10개 나눔) 효용보다 비용이 커진다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;cqrs-도-크게-보면-맥락의-분리&quot;&gt;CQRS 도 크게 보면 맥락의 분리&lt;/h1&gt;

&lt;p&gt;CQRS는 Command and Query Responsibility Segregation, 즉 “명령과 조회의 책임 분리”를 통해 관심사 분리를 달성하는 소프트웨어 패턴입니다. 이 또한 DDD의 Bounded Context 개념과 함께 버무려 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;상품 도메인에서, “판매자의 상품 관리” 맥락용 상품 엔티티를 분리해 관리하고 있다고 가정해봅니다. 처음에는 판매자가 상품 리스트나 상품 상세를 조회하는 역할과, 판매자의 상품 수정 및 관리 기능들을 모두 담당했습니다. 그러나 점점 ‘판매자 상품 조회’와 ‘판매자 상품 수정 관리’의 책임과 범위가 커지면, 이를 분리하는 것이 좋을 것입니다. 이때 CQRS 패턴에 따라 Bounded Context를 ‘조회’와 ‘명령(수정 및 관리)’의 엔티티를 분리하면 더 높은 응집성을 가진 두 객체로 나뉠 것입니다.&lt;/p&gt;

&lt;p&gt;혹은 ‘조회’에 ORM 보다 성능이 나은 쿼리 기반의 로직이 필요하다면, CQRS를 통해 둘을 분리할 수도 있겠죠.&lt;/p&gt;

&lt;h1 id=&quot;그래서-지금-무엇을-해야할까&quot;&gt;그래서, 지금 무엇을 해야할까&lt;/h1&gt;

&lt;p&gt;그래서, 지금 우리 프로젝트에 무엇을 하면 좋을까요? 각자의 상황에 따라 다를 것입니다. 위에서 말씀드린 내용을 일부 반복하겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클린 아키텍처나 DDD를 적용해보지 않으셨다면, 관련된 글을 읽어보시고 주장하는 패턴들을 이해하신 후 조금씩 적용해보시길 추천드립니다.&lt;/li&gt;
  &lt;li&gt;클린 아키텍처와 DDD를 하고 있는데, 엔티티 계층은 날씬하고 서비스 계층이 비대하시다면, 서비스 계층의 로직들을 최대한 엔티티 계층으로 끌어내려보시는 걸 추천드립니다. 대부분의 서비스 계층은 결국 엔티티 객체들을 불러와서 메서드들을 호출하는 역할만으로도 충분하다는 것을 발견하실 거예요. 그리고 로직의 응집성이 엄청 상승하는 것을 느끼실 겁니다.&lt;/li&gt;
  &lt;li&gt;엔티티에 비즈니스 로직 몰빵은 잘하고 있는데, 엔티티가 너무 커지고 관심사별로 분리가 잘 안된다고 느끼시나요? Bounded Context 개념을 적용해보세요. 같은 도메인이어도 관심사가 다르면 더 하위의 도메인으로 나뉘어야 합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;--광고--스타일쉐어-커머스-시스템을-함께-만드실-백엔드-개발자-동료분을-찾고-있어요&quot;&gt;📢 ( 광고 ) 스타일쉐어 커머스 시스템을 함께 만드실 백엔드 개발자 동료분을 찾고 있어요&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/45/styleshare.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 몸담고 있는 스타일쉐어의 커머스 개발팀은 일하는 동료들 모두가 “어떻게하면 함께 문제를 더 잘 해결할까?” 를 함께 고민하는 팀이라고 자부합니다. 개발자 개개인에게 많은 의사 결정 권한이 주어지고, 또 그만큼 개발적 의사 결정에 대한 설득과 그 결과에 대한 책임을 고민할 수 있는 성장하기 좋은 일터입니다.&lt;/p&gt;

&lt;p&gt;함께 커머스 도메인에 존재하는 수많은 문제의 해결을 위해 고민할 팀원을 찾고 있습니다. 많은 지원 부탁드려요 🙂&lt;/p&gt;

&lt;p&gt;(편하게 여쭤보고 싶은 점이 있으시다면 제 개인 메일인 shinjayne@gmail.com 로 가볍게 연락 주셔도 괜찮습니다!)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;스타일쉐어는 대한민국 1525 인구의 절반 이상이 사용하는 No.1 패션 서비스 StyleShare를 운영하는 회사입니다.&lt;/p&gt;

  &lt;p&gt;스타일쉐어는 이전의 e커머스 회사들과는 차별화된 서비스를 제공하며, 변화하는 시대에 맞춰 M·Z 세대의 최적화된 패션·뷰티 쇼핑 채널로 거듭나고 있습니다.&lt;/p&gt;

  &lt;p&gt;높은 충성도와 19%에 달하는 구매 전환율을 기반으로 2018년 12월 기준 연 거래액 1,200억(29CM 연결 기준)을 달성했습니다. 
2018년 3월에는 온라인 셀렉트샵 ‘29CM’을 인수하여 10대부터 30대까지를 아우르는 패션 커머스 기업으로 거듭났습니다.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.wanted.co.kr/wd/5313&quot;&gt;Wanted - 스타일쉐어 커머스 백엔드 개발자 채용 공고&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.notion.so/styleshare/2ae1e1e8dc964a5592f397980e2bc2d4&quot;&gt;Notion 채용 공고 페이지 - 스타일쉐어 커머스 개발자&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;글을-쓰기-전-참고한-함께-읽어보면-좋은-글&quot;&gt;글을 쓰기 전 참고한, 함께 읽어보면 좋은 글.&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@younghyun/%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%ED%8C%8C%ED%8A%B81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-vs-%EB%8F%84%EB%A9%94%EC%9D%B8-236c7008ac83&quot;&gt;아키텍처의 발전과정 Part1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@younghyun/clean-architecture-part-2-the-clean-architecture-3e2666cdce83&quot;&gt;아키텍처의 발전과정 Part2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://nesoy.github.io/articles/2018-07/DDD-Bounded-Context&quot;&gt;Bounded Context : DDD&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)&quot;&gt;객체 지향 설계 원칙 : SOLID&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;소프트웨어 공학 : 높은 응집력, 낮은 결합력&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="cleanarchitecture" /><category term="ddd" /><category term="architecture" /><category term="boundedcontext" /><summary type="html">🙏 정확한 이론 전달에 목적을 둔 글이 아닌 실제 프로젝트 적용기입니다. 다소 부실한 기반 이론이 있더라도 너그러운 피드백 부탁드립니다.</summary></entry><entry><title type="html">동시성 문제 - 비즈니스 애플리케이션 (Part 3)</title><link href="http://jaynewho.com/post/44" rel="alternate" type="text/html" title="동시성 문제 - 비즈니스 애플리케이션 (Part 3)" /><published>2020-03-07T00:41:50+09:00</published><updated>2020-03-07T00:41:50+09:00</updated><id>http://jaynewho.com/post/44</id><content type="html" xml:base="http://jaynewho.com/post/44">&lt;blockquote&gt;
  &lt;p&gt;시리즈&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/post/42&quot;&gt;Part 1 : 동시성 문제 - 일반론&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/post/43&quot;&gt;Part 2  : 동시성 문제 - 데이터베이스와 JPA&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;Part 3 : 동시성 문제 - 비즈니스 애플리케이션 &lt;strong&gt;(NOW)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞선 글들에서 소개한 동시성 문제에 관련한 일반론을 비즈니스 애플리케이션의 개발에서도 이용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;일반론 파트에서 다루었다시피, 비즈니스 애플리케이션에서의 동시성 문제도 읽고→쓰는 프로세스에서 발생합니다.&lt;/p&gt;

&lt;h1 id=&quot;쇼핑몰-시스템에서의-주문과-재고-차감&quot;&gt;쇼핑몰 시스템에서의 주문과 재고 차감&lt;/h1&gt;

&lt;p&gt;우리가 물건을 파는 쇼핑몰 커머스 시스템을 개발하고 있다고 생각해봅니다. 그 중에서도 고객이 물건을 주문하는 과정의 비즈니스 로직을 개발하고 있습니다.  고객의 주문을 처리하는 과정을 도식화해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/44/1.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;재고 남았는지 확인&lt;/li&gt;
  &lt;li&gt;가격을 계산하고 → 주문서를 작성하고 → 결제를 요청&lt;/li&gt;
  &lt;li&gt;재고를 차감&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 때, 하나의 상품에 동시에 여러 주문이 들어올 때 발생할 수 있는 동시성 문제는 무엇일까요? 네, 바로 &lt;strong&gt;“손실되는 업데이트”&lt;/strong&gt; 입니다.  아래의 그림을 살펴보시죠.&lt;/p&gt;

&lt;p&gt;(참고로 한번 읽어온 데이터는 메모리에 저장하는 애플리케이션의 특성을 가정합니다. 또다른 동시성 문제인 “일관성 없는 읽기”의 문제는 따라서 논외가 됩니다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/44/2.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;고객이 주문을 한 시점에는 재고가 2개였지만, 주문을 처리하는 과정 중 먼저 누군가 2개를 모두 주문해가면서 재고를 2 차감했습니다. 따라서 재고는 0이 되었죠. 하지만 현재 이 고객의 주문 세션에서는 주문이 모두 끝난 뒤 재고를 2에서 1로 업데이트하기 때문에, 손실되는 업데이트가 발생하게 됩니다. 재고는 더이상 믿을 수 없는 값이 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;낙관적-잠금을-통한-해결&quot;&gt;낙관적 잠금을 통한 해결&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/44/3.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동시성 제어 기법 중 하나인 낙관적 잠금 기법을 이용해 아키텍처를 구성하면 믿을 수 없는 재고값 문제를 해결할 수 있습니다.  하지만 전체 프로세스 중에 Transaction 의 원자성을 보장하지 못하게 하는 “외부 시스템 연동” 같은 과정이 있다면, 낙관적 잠금은 사용하기 어렵습니다. 낙관적 잠금은 전체 프로세스의 실패를 마지막 저장 시도 시점에 알 수 있는데, 원자적으로 Rollback 이 어려운 프로세스라면 전체 시스템의 정합성이 깨지기 때문입니다.&lt;/p&gt;

&lt;p&gt;(마지막에 재고 차감에서 충돌이 일어나 주문은 실패하였는데, 외부 결제 시스템 호출은 이미 일어나서 고객의 돈이 빠져 나간다면 시스템의 큰 문제일 것입니다.)&lt;/p&gt;

&lt;p&gt;이런 경우, 시스템의 활동성을 조금 포기하더라도 정확성을 높일 수 있는 “비관적 잠금” 을 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;비관적-잠금을-통한-해결&quot;&gt;비관적 잠금을 통한 해결&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/44/4.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비지니스 어플리케이션에서의 비관적 잠금은 보통 동일한 작업을 하는 프로세스들 중 단 하나만이 점유할 수 있는 리소스 (Lock 혹은 Semaphore) 를 이용해 구현합니다. 한 프로세스가 재고 차감에 대한 Lock 을 점유하고 있다면, 현재 주문하려는 고객은 그 Lock 점유가 해제될 때까지 기다렸다가 프로세스를 실행합니다.  모든 주문 프로세스가 순차적으로 진행되는 것이죠.&lt;/p&gt;

&lt;p&gt;비관적 잠금은  낙관적 잠금에 비해 활동성은 줄어들어 주문이 몰리는 시점에 고객은 더 느린 주문을 경험하겠지만, 결제만 되고 취소가 되는 등의 부정확한 시스템을 경험하게 될 확률은 그만큼 줄 것입니다.&lt;/p&gt;</content><author><name></name></author><category term="concurrency" /><category term="architecture" /><category term="enterprise" /><category term="database" /><category term="jpa" /><summary type="html">시리즈 Part 1 : 동시성 문제 - 일반론 Part 2 : 동시성 문제 - 데이터베이스와 JPA Part 3 : 동시성 문제 - 비즈니스 애플리케이션 (NOW)</summary></entry><entry><title type="html">동시성 문제 - 데이터베이스와 JPA (Part 2)</title><link href="http://jaynewho.com/post/43" rel="alternate" type="text/html" title="동시성 문제 - 데이터베이스와 JPA (Part 2)" /><published>2020-03-06T01:31:50+09:00</published><updated>2020-03-06T01:31:50+09:00</updated><id>http://jaynewho.com/post/43</id><content type="html" xml:base="http://jaynewho.com/post/43">&lt;blockquote&gt;
  &lt;p&gt;시리즈&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/post/42&quot;&gt;Part 1 : 동시성 문제 - 일반론&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;Part 2  : 동시성 문제 - 데이터베이스와 JPA &lt;strong&gt;(NOW)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/post/44&quot;&gt;Part 3  : 동시성 문제 - 비즈니스 애플리케이션&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞선 글에서 특정 시스템에 종속되지 않는 &lt;strong&gt;동시성 문제의 일반론&lt;/strong&gt;에 대해서 정리해보았습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동시성 문제는 2개 이상의 세션이 “읽고 쓰기 Read→Write” 하려고 할 때 발생한다.&lt;/li&gt;
  &lt;li&gt;동시성 문제는 크게 “일관성 없는 읽기” 와 “손실되는 업데이트” 로 나뉜다.&lt;/li&gt;
  &lt;li&gt;“일관성 없는 읽기” 는 불변성-복사본으로 해결한다.&lt;/li&gt;
  &lt;li&gt;“손실되는 업데이트” 는 낙관적 잠금과 비관적 잠금으로 해결한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이번 글에서는 데이터베이스 시스템과 JPA 에서는 동시성 문제를 어떻게 제어하는지 알아보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;데이터베이스의-동시성-제어&quot;&gt;데이터베이스의 동시성 제어&lt;/h1&gt;

&lt;p&gt;데이터베이스 시스템에서 세션은 “트랜잭션 (Transaction)” 입니다.&lt;/p&gt;

&lt;p&gt;Transaction 의 특성 4가지 ACID 중 Isolation 은 바로 트랜잭션의 동시성 제어와 깊이 관련이 있습니다.&lt;/p&gt;

&lt;p&gt;바로 이 Isolation 의 정도를 나타내는 Isolation Level 4가지가, 데이터베이스 동시성 제어의 핵심입니다.&lt;/p&gt;

&lt;p&gt;각각의 레벨에 따라 “일관성 없는 읽기” 와 “손실되는 업데이트” 가 해결되는지 확인해보겠습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Isolation Level&lt;/th&gt;
      &lt;th&gt;“일관성 없는 읽기” 해결되나?&lt;/th&gt;
      &lt;th&gt;“손실되는 업데이트” 해결되나?&lt;/th&gt;
      &lt;th&gt;일반론&lt;/th&gt;
      &lt;th&gt;“정확성과 활동성”&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Serializable&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;비관적 잠금으로 두 문제 모두 해결&lt;/td&gt;
      &lt;td&gt;정확성은 높으나 활동성 매우 낮음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Repeatable Read&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;복사본 사용으로 “일관성 없는 읽기” 해결&lt;/td&gt;
      &lt;td&gt;적절한 타협. 대부분 DBMS 의 기본값.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Read Committed&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;복사본을 사용하지 않아서 읽기에 일관성이 없음&lt;/td&gt;
      &lt;td&gt;활동성 (동시성) 이 매우 높음&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;Read Uncommitted 를 논외로 한 이유는 RDBMS 표준에서는 격리수준으로 인정하지 않기 때문입니다.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;jpa-의-동시성-제어&quot;&gt;JPA 의 동시성 제어&lt;/h1&gt;

&lt;p&gt;JPA 시스템에서의 세션은 하나의 JPA Transaction 입니다. JPA에서의  읽기 쓰기 동시성은 Entity 객체와 관련이 있습니다.&lt;/p&gt;

&lt;p&gt;Entity 객체를 한번 조회하면 JPA 의 영속성 컨텍스트 (Persistance Context) 에 캐시되기 때문에, 세션 (JPA Transaction) 내에서의 “일관성 없는 읽기” 의 문제는 없습니다.&lt;/p&gt;

&lt;p&gt;그렇다면 JPA 는 “손실되는 업데이트” 문제를 어떻게 제어할까요?  JPA 는 Entity 단위의 낙관적 잠금과 비관적 잠금을 제공합니다.&lt;/p&gt;

&lt;h2 id=&quot;jpa-낙관적-잠금&quot;&gt;JPA 낙관적 잠금&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/43/2.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JPA 의 버전 관리 기능 ( &lt;code class=&quot;highlighter-rouge&quot;&gt;@Version&lt;/code&gt; )을 이용해 Entity 의 버전을 관리해 낙관적 잠금을 구현합니다. Application Level 에서의 잠금이며,  낙관적 잠금이므로 두번째 세션이 Write 하기 전까지는 충돌을 알 수 없습니다.&lt;/p&gt;

&lt;p&gt;활동성은 높일 수 있지만, 잘 진행되고 있던 프로세스가 변경 사항을 저장하려고 할 때 까지 프로세스의 성패를 예측할 수 없다는 것이 단점입니다.&lt;/p&gt;

&lt;h2 id=&quot;jpa-비관적-잠금&quot;&gt;JPA 비관적 잠금&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/43/1.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터베이스가 제공하는 lock 기능을 이용해 엔티티를 영속 상태로 올릴 때부터 다른 세션에서 조회하지 못하도록 잠금을 걸어둡니다. ( &lt;code class=&quot;highlighter-rouge&quot;&gt;select for update&lt;/code&gt; 구문이라고 생각할 수 있습니다. )&lt;/p&gt;

&lt;p&gt;역시 비관적 잠금인만큼, 활동성은 매우 저하되지만 정확성과 세션의 성공은 보장됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 다음 글  : &lt;a href=&quot;/post/44&quot;&gt;동시성 문제 - 비즈니스 애플리케이션 (Part 3)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="concurrency" /><category term="architecture" /><category term="enterprise" /><category term="database" /><category term="jpa" /><summary type="html">시리즈 Part 1 : 동시성 문제 - 일반론 Part 2 : 동시성 문제 - 데이터베이스와 JPA (NOW) Part 3 : 동시성 문제 - 비즈니스 애플리케이션</summary></entry><entry><title type="html">동시성 문제 - 일반론 (Part 1)</title><link href="http://jaynewho.com/post/42" rel="alternate" type="text/html" title="동시성 문제 - 일반론 (Part 1)" /><published>2020-03-05T14:25:50+09:00</published><updated>2020-03-05T14:25:50+09:00</updated><id>http://jaynewho.com/post/42</id><content type="html" xml:base="http://jaynewho.com/post/42">&lt;blockquote&gt;
  &lt;p&gt;시리즈&lt;/p&gt;

  &lt;p&gt;Part 1 : 동시성 문제 - 일반론 &lt;strong&gt;(NOW)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;Part 2  : &lt;a href=&quot;/post/43&quot;&gt;동시성 문제 - 데이터베이스와 JPA&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/post/44&quot;&gt;Part 3  : 동시성 문제 - 비즈니스 애플리케이션&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;동시성 문제란 두 개 이상의 세션이 공통된 자원에 대해 모두 &lt;strong&gt;읽고 쓰는 작업(Read→Write)&lt;/strong&gt; 을 하려고 하는 경우 발생할 수 있는 문제를 말합니다.&lt;/p&gt;

&lt;p&gt;애플리케이션을 개발하다보면 여러 동시성 문제들을 만나고, 또 동시성 제어를 도와주는 여러 시스템들(데이터베이스 시스템, JPA 시스템 등) 을 보게됩니다.  이런 여러 시스템들이 제공하는 상세한 기능들은 모두 상이하지만, 동시성 문제를 정의하는 방식과 제어하는 이론적인 기틀은 모두 동일합니다.&lt;/p&gt;

&lt;p&gt;그래서 오늘은 특정 시스템에 종속되지 않는  &lt;strong&gt;동시성 문제와 제어 방법론&lt;/strong&gt;에 대해 정리하려고 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;동시성 문제에 “완전한 해결”은 없습니다. “제어”(적절한 해결) 만 있을 뿐입니다. 동시성 문제는 “정확성 과 활동성 을 어떻게하면 모두 최대로 할 수 있을까?” 에 대한 고민이기 때문입니다. 활동성 (얼마나 빠르게) 을 포기하면 정확성을 높일 수 있습니다. 마찬가지로 정확성(얼마나 올바른 데이터) 을 타협하면 활동성을 높일 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;동시성-문제와-제어-방법론&quot;&gt;동시성 문제와 제어 방법론&lt;/h1&gt;

&lt;p&gt;동시성 문제라고 불리우는 2가지 현상은 바로  “일관성 없는 읽기” 와 “손실되는 업데이트” 입니다.&lt;/p&gt;

&lt;h2 id=&quot;일관성-없는-읽기&quot;&gt;일관성 없는 읽기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/42/4.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;세션 2는 동시에 실행되고 있는 세션 1 때문에, 데이터에 접근하는 시점마다 다른 값을 읽게 됩니다. 이를 “일관성 없는 읽기” 라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;일관성-없는-읽기는-해결이-쉽다&quot;&gt;일관성 없는 읽기는 해결이 쉽다&lt;/h3&gt;

&lt;p&gt;일관성 없는 읽기는 해결이 쉽습니다. 바로 “불변성”, 복사본을 이용하면 됩니다. 세션 2가 최초로  데이터를 조회할 때 해당 데이터를 복사한 후, 이후에도 계속 사용하는 것입니다.  비록 세션 1이 변경한 데이터의 원장은 감지하지 못하더라도, 세션 2 내에서는 계속 동일한 복사본을 바라볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;손실되는-업데이트&quot;&gt;손실되는 업데이트&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/42/1.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;더 늦게 시작한 세션 2에 의해 세션 1의 변경사항이 무시되는 현상을 “손실되는 업데이트” 라고 합니다.&lt;/p&gt;

&lt;p&gt;데이터베이스 시스템, JPA 애플리케이션 시스템, 혹은 우리가 직접 조성하는 비즈니스 시스템에서 모두 중요하게 고려되어야 하는 문제입니다.&lt;/p&gt;

&lt;p&gt;“손실되는 업데이트” 를 방지하기 위한 방법으로는 크게 2가지가 있습니다. 바로 “낙관적 잠금” 과 “비관적 잠금” 입니다.&lt;/p&gt;

&lt;h3 id=&quot;낙관적-잠금&quot;&gt;낙관적 잠금&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/42/2.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“낙관적 잠금” 은 ‘저장 시 체크한다’ 입니다.  세션 1이 데이터 A 를 읽어왔더라도 세션 2는 자유롭게 데이터 A 를 읽어올 수 있습니다. 다만 저장하려고 할 때,  저장하려는 대상 데이터가 세션 2가 들고있던 데이터와 상이하면 저장이 되지 않습니다.&lt;/p&gt;

&lt;p&gt;낙관적 잠금을 구현하기 위해서는 공통된 리소스 A 에 대한 Versioning 이 되어야합니다. 세션 2가 들고 있는 A 의 Version 이, 저장하려는 대상 A 의 Version 과 같은지 체크해야하기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;비관적-잠금&quot;&gt;비관적 잠금&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/42/3.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“비관적 잠금” 은 ‘이미 읽고 있는 사람이 있다면, 나는 못읽어’ 입니다. 보수적인 잠금이라고 할 수 있겠죠. 낙관적 잠금에 비관적 잠금은 세션이 실패할 확률은 줄여주지만, 여러 세션의 “활동성” 은 높여주지 못합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 다음 글  : &lt;a href=&quot;/post/43&quot;&gt;동시성 문제 - 데이터베이스와 JPA (Part 2)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;참고 문헌 : 마틴 파울러의 “엔터프라이즈 애플리케이션 아키텍쳐 패턴”&lt;/em&gt;&lt;/p&gt;</content><author><name></name></author><category term="concurrency" /><category term="architecture" /><category term="enterprise" /><summary type="html">시리즈 Part 1 : 동시성 문제 - 일반론 (NOW) Part 2 : 동시성 문제 - 데이터베이스와 JPA Part 3 : 동시성 문제 - 비즈니스 애플리케이션</summary></entry><entry><title type="html">논리력은 멘탈 모델 + 지식 체계 다. 을 읽고</title><link href="http://jaynewho.com/post/41" rel="alternate" type="text/html" title="논리력은 멘탈 모델 + 지식 체계 다. &lt;슈퍼 씽킹&gt; 을 읽고" /><published>2020-03-01T00:12:50+09:00</published><updated>2020-03-01T00:12:50+09:00</updated><id>http://jaynewho.com/post/41</id><content type="html" xml:base="http://jaynewho.com/post/41">&lt;p&gt;“슈퍼 씽킹” 이란 책은 다음과 같은 주장으로 서문을 연다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;단편적인 사실들만 알고있는 것은 아무런 힘을 발휘하지 못한다. 사실들을 엮어 의미와 해석을 가능케 해주는 것을 “멘탈 모델” 이라고 하며, 이는 다양한 학문에서 유래하기도 하고, 살면서 자연스레 체득되기도 한다.&lt;/p&gt;

  &lt;p&gt;다양한 멘탈 모델들, 특히 모든 분야에 강력한 힘을 발휘하는 “슈퍼 모델” 들을 많이 익히면 “슈퍼 씽킹” 을 할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그리고 책의 구성은 저자가 살면서 습득한 다양한 슈퍼 멘탈 모델들을 나열하는 방식으로 되어있다.&lt;/p&gt;

&lt;p&gt;이 책이 전달하는 메세지가 책의 서문만을 읽고도 내게 큰 의미로 다가왔다. 그 이유를 이 글을 통해 설명하고자 한다.&lt;/p&gt;

&lt;p&gt;나는 “논리력” 이 내가 추구하는 중요한 능력이라는 사실을 최근에 자각했고 (논리적인 사고가 더 높은 생산성으로 이어진다고 믿기 때문이다), 그 “논리력” 이 강해지기 위해 필요한 것들을 찾으려 힘썼다. 그 중 첫 번째로 찾은 구성요소는 (어릴 적 부터 왠지 모르게 인생에서 중요하게 생각해온) “지식 체계” 다.&lt;/p&gt;

&lt;p&gt;한가지 새로운 지식을 습득해도 사람마다 흡수하는 속도가 다르다. 나는 이 차이를 발생시키는 원인을 지식 체계의 차이에서 찾았다.  자신이 쌓아온 지식 체계가 촘촘하고 빼곡할수록,  그 잘 짜여진 체 속에서 연관도가 높은 지식을 찾아, 새로운 지식을 빠른 속도로 배치할 수 있기 때문이다.  그리고 지식체계는 새로운 정보의 습득력 뿐만 아니라, 지금 상황에 딱 필요한 지식을 머릿속에서 검색하는 능력에도 강력한 힘을 발휘한다. 마치 인덱싱이 잘 된 데이터베이스가 검색 속도가 빠른 것과 같다.&lt;/p&gt;

&lt;p&gt;고도화된 지식 체계의 특성은  촘촘함 그리고 빼곡함인데, 이 두 특성 모두 개인이 얼마나 다양한 지식을 접했는가와 지식을 얼마나 체계적으로 정리할 수 있는 논리적 사고력을 갖췄는가 에 영향을 받는다.&lt;/p&gt;

&lt;p&gt;고도화된 지식 체계의 중요성을 설파하는 사람은 나뿐만이 아니다. 넷플릭스의 «Inside Bill Gates : 빌게이츠 다큐멘터리» 에서 빌게이츠도 자신의 독서습관을 소개하는 대목에서 지식 체계에 대해 언급한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘저는 제 머리 속의 지식의 틀 속에 새로운 지식들의 자리를 찾아 넣는 것을 좋아합니다.’ - &amp;lt; Inside Bill Gates : Netflix &amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;논리력이 강하려면 논리적 사고에 필요한 근거인 지식들이 수중에 많아야하고, 단순히 수중에 많은 것을 넘어서 빠르게 시의적절한 지식을 꺼내 논리의 근거로 사용할 수 있어야한다. 따라서 “고도화된 지식 체계” 는 논리력의 필요조건이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 항상 아쉬웠던 부분은 고도화된 지식 체계가 논리력 의 충분 조건은 아니라는 것이었다.  분명 논리력을 구성하는 요인이 지식 체계 외에 더 있다고 느끼고 있었는데, 이 슈퍼 씽킹이란 책의 서문과 목차를 읽고 바로 느꼈다. 내가 찾던 논리력 의 또 다른 필요 조건은 “다양한 멘탈 모델” 이였다는 것을.&lt;/p&gt;

&lt;p&gt;멘탈 모델이 무엇인지, 어떤 효용을 가지는지 와닿지 않는 분들이 있을 것이다. 그래서 다시 나의 글로 돌아가보자. 내가 이 글에서 작성한 다음의 두 글귀는 이 책의 영향을 받아, 평소에 내가 가지고 있던 멘탈 모델을 이용해 분석한 것이다.  첫 번째로 이 대목.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;‘그리고 지식체계는 새로운 정보의 습득력 뿐만 아니라, 지금 상황에 딱 필요한 지식을 머릿속에서 검색하는 능력에도 강력한 힘을 발휘한다. 마치 인덱싱이 잘 된 데이터베이스가 검색 속도가 빠른 것과 같다.’&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 대목에서 나는 컴퓨터공학에서 기인한 “데이터베이스의 인덱싱” 이라는 멘탈 모델을 이용해 지식 체계라는 보편적인 현상을 이해했다. (참고로 이 책에서는 이렇게 특정 학문적 영역에서 기인하였어도 보편적으로 효용을 줄 수 있는 멘탈 모델을 “슈퍼 모델” 이라고 부른다.)  만약 내가 이 멘탈 모델이 없었다면, 지식 체계의 중요성을 논리적으로 설명하지 못했을 수도 있고, 더 나아가서는 지식 체계의 중요성 자체를 인지하지 못했을 수도 있다.&lt;/p&gt;

&lt;p&gt;두번째로는 이 대목이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;‘고도화된 지식 체계가 논리력의 충분 조건은 아니라는 것이었다. 분명 논리력을 구성하는 요인이 지식 체계 외에 더 있다고 느끼고 있었는데, 이 슈퍼 씽킹이란 책의 서문과 목차를 읽고 바로 느꼈다. 내가 찾던 논리력의 또 다른 필요 조건은 “다양한 멘탈 모델” 이었다는 것을.’&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 대목에서는 “필요 충분 조건” 이라는 논리학에서 기인한 멘탈 모델을 사용한 것이다. 이 멘탈 모델을 사용하면 위 대목 뿐만 아니라 일상 생활의 다양한 부분에서 논리적 의존 관계를 더 쉽게 파악하고 다른 사람에게 설명할 수 있다. 멘탈 모델의 효용을 단적으로 보여주는 예이다.&lt;/p&gt;

&lt;p&gt;이렇듯 분명히 멘탈 모델은 똑같은 사실을 마주하더라도 더 빠르게 자신의 방식으로 현상을 해석할 수 있게 해주고, 논리적 결정의 속도와 근거력을 높여준다.  따라서 분명 멘탈 모델은 지식 체계와 더불어 논리력의 필요 조건이라고 할 수 있겠다.&lt;/p&gt;

&lt;p&gt;“슈퍼 씽킹” 이 서문에서부터 강조한 ‘슈퍼 씽킹을 하기 위한 슈퍼 멘탈 모델들의 중요성’ 은 나에게 위와 같은 생각을 하게 만들었고, 덕분에 나는 내가 중요하게 생각하는 “논리력” 에 필요한 중요한 요인을 또 하나 찾았다. 이는 내가 앞으로 책을 읽거나 새로운 정보를 얻었을 때, 지식 체계의 관점에서만이 아니라 새로운 멘탈 모델의 습득 관점에도 집중할 수 있게 해 줄 것이다. 이렇게 생각하니 정말 마음이 부푼다. 부푼 마음으로 서문에서 슈퍼 씽킹의 표지를 덮는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/41/bookcover.jpg&quot; alt=&quot;책&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="inspiration" /><category term="book" /><category term="logical" /><category term="thinking" /><summary type="html">“슈퍼 씽킹” 이란 책은 다음과 같은 주장으로 서문을 연다.</summary></entry><entry><title type="html">점을 연결하는 사람들 - ‘기획자의 습관’을 읽고</title><link href="http://jaynewho.com/post/40" rel="alternate" type="text/html" title="점을 연결하는 사람들 - '기획자의 습관'을 읽고" /><published>2019-08-08T21:30:50+09:00</published><updated>2019-08-08T21:30:50+09:00</updated><id>http://jaynewho.com/post/40</id><content type="html" xml:base="http://jaynewho.com/post/40">&lt;blockquote&gt;
  &lt;p&gt;«기획자의 습관» 을 읽고. 창의, 통찰, 연결, 기획에 대한 생각 정리.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;기획자의 습관이란 책을 읽고 있습니다.&lt;/p&gt;

&lt;p&gt;저자 최장순씨는 오랫동안 기획자로 일했고, 자신이 일상에서 어떻게 기획 아이디어를 이끌어내는지를 이 책에 담았습니다.&lt;/p&gt;

&lt;p&gt;첫 챕터의 첫번째 주제는 “엣지오브 투모로우”라는 영화입니다. 그는 이 영화를 관람하고, 마치 매일 반복되는 일상을 살면서 “내일의 가장자리” 에서 “내일” 로 넘어가지 못하는 우리의 삶을 떠올렸고, 니체의 “영원회귀” 사상을 떠올렸고, 니체의 저서 «차라투스트라는 이렇게 말했다» 의 “양치기소년이 뱀을 물어뜯은 후 ‘변화한 자’ 가 되었다”  란 이야기를 떠올렸습니다. 굉장히 통찰력 있는 연결이라고 생각합니다.&lt;/p&gt;

&lt;p&gt;저는 이렇게 통찰력 있는 연결이 굉장히 멋있다고 생각합니다. 사실 창의적인 아이디어, 대단한 기획은 세상에 이미 존재하는 것들을 새로운 관점에서 연결점을 찾아내고 새로운 방식으로 잘 연결하는 것입니다.&lt;/p&gt;

&lt;p&gt;스티브 잡스는 인터뷰에서 “어떻게 그렇게 창의적인 아이디어들을 낼 수 있나요?” 라는 질문을 받고 이렇게 답했다고 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“사실 저는 그런 이야기를 들을때마다 굉장히 부끄럽습니다. 저는 다른사람들과 크게 다르거나, 특별히 더 천재적이지 않기 때문이죠. 저는 그저 세상에 이미 존재하는 것들을, 이전과는 다른 방식으로 연결하는 것 뿐입니다. 그리고 저는 창의성이 바로 그런 것이라고 생각합니다. 따라서 창의성은 연습을 통해 기를 수 있습니다.”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;어떻게보면 제가 기획자의 습관이라는 책을 읽다가, 스티브잡스를 떠올린 것도 하나의 “새로운 연결” 을 찾아낸 것입니다. 이 또한 창의성을 발휘한 것이라고 볼 수 있겠죠.&lt;/p&gt;

&lt;p&gt;새로운 연결을 잘 찾아내는 것을 혹자는 “통찰” 이라고 표현합니다. 저는 “창의”, “통찰” 모두 맞다고 생각합니다.&lt;/p&gt;

&lt;p&gt;기획, 창의, 통찰, 연결. 모두 제게는 같은 말로 느껴집니다.&lt;/p&gt;

&lt;p&gt;“창의”, “통찰” 을 잘하기위해선 어떻게 훈련해야할까요? 일상에 존재하는, 혼자서는 무의미한 점들을 연결해 의미를 만들어내는 것, 어떻게하면 잘 할 수 있을까요?&lt;/p&gt;

&lt;p&gt;우선 첫째로는 재료가 될 점들을 많이 알아야하고, 둘째로는 점들간의 관통하는 아이디어를 끄집어내고 연결할 줄 아는 센스를 길려야한다고 생각합니다.&lt;/p&gt;

&lt;p&gt;재료가 되는 점들을 많이 알려면 책을 많이 읽고, 세상에 일어나는 일들에 많은 관심을 기울여야합니다.&lt;/p&gt;

&lt;p&gt;점들간의 관통하는 아이디어를 끄집어내고 연결하는 센스를 기르려면, 점들을 잘 연결하는 사람들의 이야기를 많이 듣고 보고 익혀야합니다. “창의” 는 스티브잡스의 말처럼, 훈련해서 기를 수 있는 “후천적 능력” 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/40/bookcover.jpg&quot; alt=&quot;책표지&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="inspiration" /><category term="book" /><category term="planning" /><summary type="html">«기획자의 습관» 을 읽고. 창의, 통찰, 연결, 기획에 대한 생각 정리.</summary></entry><entry><title type="html">JPA 의 Fetch Type 과 친해지기</title><link href="http://jaynewho.com/post/39" rel="alternate" type="text/html" title="JPA 의 Fetch Type 과 친해지기" /><published>2019-08-06T21:30:50+09:00</published><updated>2019-08-06T21:30:50+09:00</updated><id>http://jaynewho.com/post/39</id><content type="html" xml:base="http://jaynewho.com/post/39">&lt;p&gt;JPA 를 이용한 개발을 하다보면 자주 접하는 프로그래밍적인 이슈가 있습니다. 바로 &lt;strong&gt;Fetch Type (Fetch 전략)&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;Fetch Type 속성은 언제 동작하고 어떻게 동작하는지, 그리고 어떨 때 Fetch Type 때문에 N+1 문제가 발생하는지, 또 어떻게 해결하는지 알아봅니다.&lt;/p&gt;

&lt;p&gt;추가적으로, 이상하게 동작하는 OneToOne 의 FetchType LAZY 설정도 짚고 넘어갑니다.&lt;/p&gt;

&lt;p&gt;이 글을 이끌어가는데 도움을 주는 두 엔티티를 소개합니다. “주문” 과 “멤버” 라는 친구들입니다. 주문과 멤버는 N:1 의 관계에 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 주문 엔티티&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;order&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@ManyToOne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;member_id&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 멤버 엔티티&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;member&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Column&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@OneToMany&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orders&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;fetch-type-이란&quot;&gt;Fetch Type 이란&lt;/h1&gt;

&lt;p&gt;Fetch Type 은 JPA 가 하나의 Entity 를 조회할 때, 연관관계에 있는 객체들을 어떻게 가져올 것이냐를 나타내는 설정값입니다.&lt;/p&gt;

&lt;p&gt;Fetch Type 은 크게 Eager 와 Lazy 두가지 전략이 있습니다. Fetch Type Issue 상황이라는 것은 하나의 Entity 를 로드할 때, 아래의 두가지 전략 중 고민하는 상황을 말합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;연관 관계에 있는 Entity 들 모두 가져온다 → Eager 전략&lt;/li&gt;
  &lt;li&gt;연관 관계에 있는 Entity 가져오지 않고, getter 로 접근할 때 가져온다 → Lazy 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;fetch-type-어떻게-동작할까요&quot;&gt;Fetch Type 어떻게 동작할까요?&lt;/h1&gt;

&lt;h2 id=&quot;manytoone-컬럼-있을-때-주인일-때&quot;&gt;ManyToOne 컬럼 있을 때 (주인일 때)&lt;/h2&gt;

&lt;p&gt;Order Entity 는 단일 Member Entity 를 가지는 ManyToOne 컬럼이 있습니다. ( member 의 PK 가 Foreign Key 로 실제로 order DB컬럼에 매핑되어있으므로 Order 가 주인입니다. )&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ManyToOne 의 기본 FetchType 은 EAGER 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fetchtypeeager-기본&quot;&gt;FetchType=EAGER &lt;code class=&quot;highlighter-rouge&quot;&gt;기본&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;아래와같이, Join 을 통해 한번에 모든 쿼리를 가져옵니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	order.id,
	order.member_id,
	member.id,
	member.name
from order
outer join member
	on order.member_id=member.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;order 에 대한 for 문이 돌면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;order.getMember&lt;/code&gt; 를 호출했다고 합시다.&lt;/p&gt;

&lt;p&gt;이미 member 관련 정보가 Entity Manager 에 캐싱이 되어있기 때문에 추가적인 쿼리는 나가지 않을 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;fetchtypelazy&quot;&gt;FetchType=LAZY&lt;/h3&gt;

&lt;p&gt;Order List 를 가져오는 상황에서 &lt;strong&gt;N+1 Problem 이 발생할 수 있습니다&lt;/strong&gt;. Order List 를 불러온 뒤, 각 Member 에 대해 무언가를 하는 For Loop 가 코드에 있다면 말입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	order.id,
	order.member_id
from order;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 쿼리 결과가 아래와 같다고 합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;order.id&lt;/th&gt;
      &lt;th&gt;order.member_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1001&lt;/td&gt;
      &lt;td&gt;999&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1002&lt;/td&gt;
      &lt;td&gt;888&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1003&lt;/td&gt;
      &lt;td&gt;777&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;order 에 대한 for 문이 돌면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;order.getMember&lt;/code&gt; 를 호출했다고 합시다. 그럼 아래와 같이 3번의 쿼리가 더 발생할 것입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	member.id,
	member.name
from member
where member.id=999;

select
	member.id,
	member.name
from member
where member.id=888;

select
	member.id,
	member.name
from member
where member.id=777;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;onetomany-컬럼-있을-때-종일-때&quot;&gt;OneToMany 컬럼 있을 때 (종일 때)&lt;/h2&gt;

&lt;p&gt;Member Entity 에는 Order Entity Collection (List 혹은 Set) 을 가지는 OneToMany 컬럼이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OneToMany 의 기본 FetchType 은 LAZY 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fetchtypeeager&quot;&gt;FetchType=EAGER&lt;/h3&gt;

&lt;p&gt;Member List 를 가져오려고 해봅시다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	member.id,
	member.name
from member;

// member 가 2개 라면
// order set 땡겨오는 쿼리도 바로 2번 날라갑니다.

select
	order.id,
	order.member_id
from order
where member_id=999;

select
	order.id,
	order.member_id
from order
where member_id=888;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;member 를 가져오는 동시에 쿼리가 2방 더 날라갑니다. (이를 한번의 쿼리로 해결하려면 직접 JPQL 을 작성하거나 Query Builder 를 이용해 Fetch Join 을 해야합니다.)&lt;/p&gt;

&lt;h3 id=&quot;fetchtypelazy-기본&quot;&gt;FetchType=LAZY &lt;code class=&quot;highlighter-rouge&quot;&gt;기본&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Member List 를 가져오려고 해봅시다. 한번의 쿼리만 날라갑니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	member.id,
	member.name
from member;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;fetchtype-이-동작하는-시점&quot;&gt;FetchType 이 동작하는 시점&lt;/h1&gt;

&lt;p&gt;JPA Entity Manager 에 의해 관리되는 Persistence Context 에 Entity 가 Managed 상태로 올라올 때의 동작입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/39/39-persist-context.png&quot; alt=&quot;39-persist-context&quot; /&gt;&lt;/p&gt;

&lt;p&gt;queryDSL 과 같은 쿼리 빌더를 이용해 아무리 Join 문을 짜도, (Fetch Join 을 하지 않는 이상) 메인 도메인의 엔티티만 Persistence Context 에 올라옵니다. 연관관계에 대한 Fetch 도 메인 도메인만 일어납니다.&lt;/p&gt;

&lt;h1 id=&quot;n1-문제는-이럴-때-발생합니다&quot;&gt;N+1 문제는 이럴 때 발생합니다.&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ManyToOne, OneToOne 컬럼의 FetchType 을 LAZY 로 하였을 경우 발생합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;n1-은-어떻게-해결할까요&quot;&gt;N+1 은 어떻게 해결할까요?&lt;/h2&gt;

&lt;p&gt;N+1 이 발생하는 Entity 연관관계를 발견하였다면, 한 Entity 가 Managed 상태로 올라올 때, N+1 문제를 일으키는 Entity Collections 들도 동시에 Managed 상태로 올라오게 하면 됩니다.&lt;/p&gt;

&lt;p&gt;지금까지 크게 3가지 방법을 발견했습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;JPQL 의 Fetch Join 을 이용합니다. (QueryDSL 과 같은 쿼리빌더의 도움을 받을 수도 있습니다.)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ManyToOne, OneToOne 의 FetchType = LAZY → EAGER 로 변경합니다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@EntityGraph&lt;/code&gt; 를 이용해, 한 쿼리에 대해서만 EAGER load 를 지정합니다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;onetoone-의-fetchtype-lazy-는-사용자가-의도한대로-동작하지-않습니다&quot;&gt;OneToOne 의 FetchType LAZY 는 사용자가 의도한대로 동작하지 않습니다.&lt;/h1&gt;

&lt;p&gt;OneToOne 컬럼의 FetchType=LAZY 는 사용자가 의도한대로 동작하지도 않습니다! 아래의 글을 보시죠.&lt;/p&gt;

&lt;p&gt;OneToOne 의 FetchType=LAZY 는 컬럼을 조회하지 않아도 무조건 쿼리가 날라갑니다. 1번 날라갈 쿼리를 무조건 날라가는 2번의 쿼리로 바꿔치기 하는 셈 뿐입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wonwoo.ml/index.php/post/1566&quot;&gt;hibernate OneToOne lazy 구현하기&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;query-builder-를-이용하는-경우-onetoone-은-fetch-join-걸어주는게-좋습니다&quot;&gt;Query Builder 를 이용하는 경우, OneToOne 은 Fetch Join 걸어주는게 좋습니다.&lt;/h1&gt;

&lt;p&gt;쿼리 빌더를 이용해서 Order List 를 가져오는 쿼리를 짠다고 합시다. 예를 들면 queryDSL 기준으로 아래와 같이 짭니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Order&amp;gt; orders = jpaQueryFactory.select(qOrder).from(qOrder).fetch();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;개발자는 Order 의 Member 연관관계가 FetchType EAGER 로 설정되어있으므로, Order 와 Member 를 조인에서 한번에 가져와주는 쿼리가 나가길 기대할 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 쿼리 빌더를 이용하면, 사실 순수한 Order 에 대한 쿼리만 나가는 경우가 많습니다. 아래와 같이 말이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	order.id,
	order.member_id
from order;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이렇게 쿼리가 나가면, 복수개의 Order Entity 가 영속성 컨텍스트로 로드될 때 EAGER 로 설정된 Member 연관관계의 Fetch Type 이 동작하여 바로 N개의 단일 Member 쿼리가 나가게 됩니다. (FetchType 이 동작하는 시점은 영속성 컨텍스트로 로드될 때입니다.)&lt;/p&gt;

&lt;p&gt;따라서 Query Builder 를 이용해 JPQL 쿼리를 직접 작성할 경우, One To One 관계의 Entity 에 대해선 Fetch Join 을 걸어주는 것이 좋습니다.&lt;/p&gt;

&lt;h1 id=&quot;더-읽어보면-좋을-글&quot;&gt;더 읽어보면 좋을 글&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;N+1 문제를 해결하기 위한 방법들&lt;/strong&gt;을 잘 정리해놓은 글입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Fetch Join&lt;/code&gt; 을 이용하는 방법과 &lt;code class=&quot;highlighter-rouge&quot;&gt;@EntityGraph&lt;/code&gt; Annotation 을 이용하는 법을 소개하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jojoldu.tistory.com/165&quot;&gt;JPA N+1 문제 및 해결방안&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="java" /><category term="spring" /><category term="jpa" /><summary type="html">JPA 를 이용한 개발을 하다보면 자주 접하는 프로그래밍적인 이슈가 있습니다. 바로 Fetch Type (Fetch 전략) 입니다.</summary></entry><entry><title type="html">2018 webRTC 정리</title><link href="http://jaynewho.com/post/36" rel="alternate" type="text/html" title="2018 webRTC 정리" /><published>2019-04-19T14:10:50+09:00</published><updated>2019-04-19T14:10:50+09:00</updated><id>http://jaynewho.com/post/36</id><content type="html" xml:base="http://jaynewho.com/post/36">&lt;blockquote&gt;
  &lt;p&gt;2018년도에 webRTC 를 이용한 ‘코딩 실시간 화상 강의실 서비스’ 를 만들던 경험을 떠올리며, webRTC API 를 이용한 애플리케이션 작성법을 정리해봅니다. 🎉&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;what-is-webrtc&quot;&gt;What is &lt;code class=&quot;highlighter-rouge&quot;&gt;WebRTC&lt;/code&gt;?&lt;/h1&gt;
&lt;p&gt;WebRTC 는 브라우저나 모바일 application 에서 Real Time Communication (RTC) 를 편리하게 할 수 있는 api 를 만들고자 하는 목적으로 시작된 프로젝트입니다. Open Project 이지만 (2018년 12월 기준) Google Chrome Team 의 주도로, Mozilla, Opera 등의 단체의 지원을 받으며 진행되고 있습니다.&lt;/p&gt;

&lt;p&gt;프로젝트의 진행 방식은, WebRTC API 최신 명세 (SPEC) 를 &lt;code class=&quot;highlighter-rouge&quot;&gt;WebRTC M{xx}&lt;/code&gt; 와 같은 이름으로 공개하고, 거의 동시에 Chrome (혹은 Chrome Beta) 에 구현하여 릴리즈하는 것 같습니다. Opera, Safari, Firefox 등의 브라우저들은 이 공개된 명세에 발맞춰 따라옵니다.&lt;/p&gt;

&lt;p&gt;WebRTC 로 할 수 있는 일은 굉장히 많습니다. 그 중에서도 이 글에서는 서버를 통하지 않고 클라이언트와 클라이언트 간의 p2p 영상/음성/데이터 통신을 하는 활용법에 초점을 맞춰서 webRTC 의 API 를 정리해보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://webrtc.org/&quot;&gt;WebRTC 공식 홈페이지 webrtc.org 링크&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;webrtc-의-3가지-대표-api&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WebRTC&lt;/code&gt; 의 3가지 대표 API&lt;/h1&gt;

&lt;p&gt;2018년 말인 현재, 대부분의 브라우저가 webRTC API 표준을 지원합니다. 대부분의 브라우저에서 지원하는 webRTC 의 대표적인 표준 API 3가지를 소개하겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MediaStream&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;getUserMedia&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTCDataChannel&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;api-1-mediastream&quot;&gt;API 1. &lt;code class=&quot;highlighter-rouge&quot;&gt;MediaStream&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;사용자의 카메라와 마이크 같은 곳의 데이터 스트림에 접근합니다. 우리의 애플리케이션이 사용자의 음성, 영상 데이터를 채집해 올 때 자주 사용하게 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;api-2-rtcpeerconnection&quot;&gt;API 2. &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;암호화 및 대역폭 관리를 하는 기능을 가지고 있고, 오디오 또는 비디오 연결을 담당합니다. 애플리케이션이 채집한 음성 및 영상 데이터를 서로 주고 받는 채널을 추상화하였다고 생각하면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;api-3-rtcdatachannel&quot;&gt;API 3. &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCDataChannel&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;음성 및 영상 데이터가 아닌, json/text 데이터들을 주고받는 채널을 추상화한 API 입니다.&lt;/p&gt;

&lt;h1 id=&quot;webrtc-application-이-수행하는-것&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;webRTC&lt;/code&gt; application 이 수행하는 것&lt;/h1&gt;

&lt;p&gt;여러분이 만약 p2p 영상 및 음성 통신을 하는 webRTC application 을 구성한다면, 다음의 주요한 4가지 작업을 수행해야 할 것입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;no&lt;/th&gt;
      &lt;th&gt;stage&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Fetching&lt;/td&gt;
      &lt;td&gt;상대 peer 에게 보낼 사용자의 음성 및 영상 데이터를 수집합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Signaling&lt;/td&gt;
      &lt;td&gt;이 세상 어딘가에 있는 상대 peer 와 연결을 맺기 위해서, 상대 peer 의 정보를 탐색합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Connection&lt;/td&gt;
      &lt;td&gt;발견한 peer 와 p2p connection 을 맺습니다. channel 을 개방해둡니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Communication&lt;/td&gt;
      &lt;td&gt;개방해놓은 채널을 통해 음성/영상/텍스트 데이터를 주고 받습니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위의 4가지 작업의 구체적인 방식과, 각각의 수행에 필요한 webRTC API 들을 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;1단계-fetching&quot;&gt;1단계. Fetching&lt;/h2&gt;

&lt;p&gt;webRTC API 인 &lt;code class=&quot;highlighter-rouge&quot;&gt;MediaStream&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;getUserMedia&lt;/code&gt; 를 이용해 사용자의 영상 및 음성 정보를 가져옵니다. 가져온 이후의 활용법은 4단계에서 자세히 다루겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;2단계-signaling&quot;&gt;2단계. Signaling&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;잠깐! Signlaing 단계는 피어와 피어가 서로를 찾을 수 있도록 돕는 &lt;strong&gt;중간 매개자 역할을 하는 서버인 Signaling Server 를 필요&lt;/strong&gt;로 합니다. Signaling Sever 의 &lt;strong&gt;구현 방식에는 제약이 없습니다.&lt;/strong&gt;  오롯히 애플리케이션을 만드는 개발자의 몫입니다. 개발 엔지니어 개인 역량에 따라 구현 형태도 다르고, 정답도 없습니다. webRTC 애플리케이션 개발을 하면서 가장 어려웠던 부분이기도 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Signaling 단계는 서로 다른 두 peer (WebRTC Client) 가 Communication 하기 위한 준비단계로, 3가지 종류의 정보를 교환해야 합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Network 정보를 교환합니다.
    &lt;ul&gt;
      &lt;li&gt;ICE Framework 를 사용해 find candidate =&amp;gt; ip 와 port 를 찾는다&lt;/li&gt;
      &lt;li&gt;내 ip 와 port 정보&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Media Capability 를 교환합니다.
    &lt;ul&gt;
      &lt;li&gt;sdp (Session Description Protocol) 형식을 따르는 blob 인  &lt;code class=&quot;highlighter-rouge&quot;&gt;offer&lt;/code&gt; 와 &lt;code class=&quot;highlighter-rouge&quot;&gt;answer&lt;/code&gt; 를 주고 받으며 교환합니다.&lt;/li&gt;
      &lt;li&gt;내 브라우저와 상대 peer 브라우저가 사용 가능한 코덱들과 해상도들은 무엇일까&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Session Control Messages 교환합니다
    &lt;ul&gt;
      &lt;li&gt;Session (통신연결) 의 초기화,종료&lt;/li&gt;
      &lt;li&gt;Error Report&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;조금 더 자세히 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;network-정보-ice-candidate-교환하기&quot;&gt;Network 정보 (ICE Candidate) 교환하기&lt;/h3&gt;

&lt;p&gt;세상 어딘가에 있는 상대 peer 를 찾아 연결을 맺기 위해선, 네트워크 정보를 교환해야합니다. 이 때, 중간 매개자 역할로서 별도의 서버인 Signaling Server 가 필요합니다. 순서는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;step&lt;/th&gt;
      &lt;th&gt;do&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; Object 를 새롭게 생성하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.onicecandidate&lt;/code&gt; 핸들러를 통해 현재 내 client 의 Ice Candidate(Network 정보)  가 확보되면 실행될 callback 을 전달합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Ice Candidate (내 네트워크 정보) 가 확보되면, 중간 매개자인 Signaling Server 을 통해 상대 peer 에게  serialized 된 ice candidate 정보를 전송합니다. (쌍방이 서로에게 합니다.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;상대 peer 의 candidate (네트워크 정보) 가 도착하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.addIceCandidate&lt;/code&gt; 를 통해 상대 peer 의 네트워크 정보를 등록합니다. (쌍방이 모두 합니다.)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;media-capability-교환하기--session-control-message-교환하기&quot;&gt;Media Capability 교환하기 + Session Control Message 교환하기&lt;/h3&gt;

&lt;p&gt;상황을 가정해봅시다. A 와 B 가 webRTC 통신을 하려고합니다. 각자 브라우저에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; 객체를 가지고 있고, 서로의 네트워크 정보 (ice candidate) 를 교환 후 각자의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.addIceCandidate&lt;/code&gt; 를 통해 서로의 네트워크 정보를 등록하였습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;step&lt;/th&gt;
      &lt;th&gt;do&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;B 가 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.createOffer&lt;/code&gt; 를 호출해 Offer SDP (Session Description Protocol) 을 생성합니다. 여기엔 내 브라우저에서 사용 가능한 코덱이나 해상도에 대한 정보가 들어있습니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;B 가 Offer SDP 를 Signaling Server (매개자) 을 통해 전송합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;A 는 Signaling Channel 에서 Offer SDP 를 받아, &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.setRemoteDescription&lt;/code&gt; 을 수행합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;A 의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; 객체는 상대 session 에 대한 정보를 알고 있게 되었고, &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.createAnswer&lt;/code&gt; 를 호출하여 Answer SDP 를 생성하여 Signaling Channel 을 통해 B 에게 전달합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;B 도 마찬가지로 자신의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.setRemoteDescription&lt;/code&gt; 을 호출해, 전달받은 Answer SDP 를 등록합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;A, B 각 측에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;setRemoteDescription&lt;/code&gt; 이 성공적으로 수행되었다면, 각 브라우저에서는 서로의 peer 에 대해 인지하고 있는 상태라고 할 수 있고, p2p 연결이 성공적으로 완료되었다고 할 수 있습니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;3단계-connection&quot;&gt;3단계. Connection&lt;/h2&gt;

&lt;p&gt;어려운 Signaling 을 통해 상대 피어의 정보가 잘 등록된 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; 를 얻었다면, 연결이 성공적으로 이루어진 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;4단계-communication&quot;&gt;4단계. Communication&lt;/h2&gt;
&lt;p&gt;보통 webRTC 를 통해서 peer 와 peer 가 주고받는 데이터는 크게 아래의 두가지입니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;video 나 audio 데이터 스트림&lt;/li&gt;
  &lt;li&gt;직렬화된 text 데이터&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;교환의 양상은, 연결이 이루어지기 전에 데아터 stream 이나 채널을 미리 준비하고, 연결이 완료되면 데이터를 받았을 때의 callback 을 통해 받은 데이터를 처리합니다. 조금 더 자세한 내용은 아래와 같습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-video-나-audio-데이터-스트림-의-경우&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1. video 나 audio 데이터 스트림&lt;/code&gt; 의 경우&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;주는 입장&lt;/strong&gt; : 자신의 머신에서  (&lt;code class=&quot;highlighter-rouge&quot;&gt;getUserMedia&lt;/code&gt; 등의 api 를 통해) video/audio 스트림 source 를 취득해 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; 을 생성할 당시에 &lt;code class=&quot;highlighter-rouge&quot;&gt;addTrack&lt;/code&gt;(데이터 stream 채널을 연결) 해줍니다. Signaling 을 통해 connection 이 이루어지기 전에 미리 되어야합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;받는 입장&lt;/strong&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.ontrack&lt;/code&gt; 의 callback 을 커스텀하게 설정해서, connection 이 성공적으로 이루어진 후에 상대방의 Track (video/audio stream) 이 감지되면 어떤 동작을 할지 설정할 수 있습니다. 보통 받은 track 의 데이터 스트림을 DOM 의 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;video srcObject={??}/&amp;gt;&lt;/code&gt; element 에 연결해 보여줍니다.&lt;/p&gt;

&lt;h4 id=&quot;2-직렬화된-text-데이터-의-경우&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2. 직렬화된 text 데이터&lt;/code&gt; 의 경우&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;주는 입장&lt;/strong&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.createDataChannel&lt;/code&gt;  을 통해, 특정 이름의 data 전달 채널을 개설할 수 있습니다. 이 또한 Signaling 을 통해 connection 이 이루어지기 전에 미리 되어야합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;받는 입장&lt;/strong&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.ondatachannel&lt;/code&gt; 의 callback 을 커스텀하게 설정해서, connection 이 성공적으로 이루어진 후에 상대방이 data channel 을 통해 어떤 데이터를 보냈을 때의 동작을 설정할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;webrtc-애플리케이션을-만들-때-겪었던-어려움&quot;&gt;webRTC 애플리케이션을 만들 때 겪었던 어려움&lt;/h1&gt;
&lt;h2 id=&quot;1-피어간의-연결이-끊겼을-때-다시-연결을-맺어줘야-한다&quot;&gt;1. 피어간의 연결이 끊겼을 때, 다시 연결을 맺어줘야 한다&lt;/h2&gt;
&lt;p&gt;인터넷의 문제나 예기치 못한 문제로 피어와 피어간에 맺어놓은 Connection 이 끊어지는 일이 굉장히 자주 발생합니다. 이 때 적절한 retry 로직으로 자연스럽게 재연결을 맺어주어야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;2-안정적인-signaling-server-를-구축해야한다&quot;&gt;2. 안정적인 Signaling Server 를 구축해야한다&lt;/h2&gt;
&lt;p&gt;Signaling 단계가 성공하지 못하면 Connection 을 맺을 수 조차 없습니다. 따라서 안정적인 Signaling Server 를 구축하는 것이 무엇보다 중요했습니다.&lt;/p&gt;

&lt;h1 id=&quot;참고한-자료들&quot;&gt;참고한 자료들&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Getting Started with webRTC : https://www.html5rocks.com/ko/tutorials/webrtc/basics/&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="webrtc" /><category term="js" /><category term="p2p" /><category term="frontend" /><summary type="html">2018년도에 webRTC 를 이용한 ‘코딩 실시간 화상 강의실 서비스’ 를 만들던 경험을 떠올리며, webRTC API 를 이용한 애플리케이션 작성법을 정리해봅니다. 🎉</summary></entry><entry><title type="html">구글이 목표를 달성하는 방식, OKR</title><link href="http://jaynewho.com/post/38" rel="alternate" type="text/html" title="구글이 목표를 달성하는 방식, OKR" /><published>2019-01-27T21:30:50+09:00</published><updated>2019-01-27T21:30:50+09:00</updated><id>http://jaynewho.com/post/38</id><content type="html" xml:base="http://jaynewho.com/post/38">&lt;p&gt;최근 이직 온 회사에서 OKR 을 하고 있다는 것을 알기 전부터 OKR 에 관심이 많았습니다. 이전에 일하던 회사는 10명 남짓한 굉장히 작은 스타트업이었는데, 원하는 목표를 어떻게 하면 달성할 수 있을지 고민하던 찰나에 지인으로부터 OKR 에 대해 듣게 되었습니다. 당시 들었을 때에는, 그저 목표 달성을 위한 좋은 방법론이라 생각했습니다. 하지만 바빠서 자세히 알아보지 못했습니다.&lt;/p&gt;

&lt;p&gt;오늘 우연히 서점에서 이 OKR 책을 발견하고선, 집어들은 자리에서 한숨에 절반을 읽었습니다. 그동안 목표 달성에 대한 갈증이 컸던 모양입니다. 내 인생의 목표 달성에 대한 갈증, 현재 속한 회사의 목표 달성에 대한 갈증, 혹은 미래에 내가 간절히 달성하고프게 될 목표의 달성 방법에 대한 갈증 ? 오늘 이 책에서 얻은 OKR 은 나의 이런 갈증을 꽤나 해소시켜줄 수 있는 무엇이었습니다.&lt;/p&gt;

&lt;p&gt;이 책은 해나와 잭이라는 공동 창업자가 자신들의 스타트업에 OKR 를 적용하면서 겪는 일들, 그러면서 OKR 에 대해 더 잘 알게되는 과정을 스토리 형식으로 풀어나갑니다. 이 글에서는 그 스토리에서 알게 된 OKR 탬플릿을 간단히 여기 정리하려고 합니다.&lt;/p&gt;

&lt;h1 id=&quot;okr-전략이-필요한-이유--황금-사과-이야기&quot;&gt;OKR 전략이 필요한 이유 : 황금 사과 이야기&lt;/h1&gt;
&lt;p&gt;책에서 굉장히 인상깊게 읽은 이야기가 있었습니다. 어릴적 한번씩 읽어봤을만한 고대 그리스 로마 신화의 “황금 사과 이야기” 인데, 이 책에서는 OKR 과 같은 목표 달성 전략이 작은 스타트업이나 큰 기업에 왜 필요한지를 설명하기 위해 이 이야기를 소개하고 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 책에 나온 황금사과 이야기입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;아탈란타는 스파르타에서 가장 빨리 달릴 수 있었던 여인으로, 결혼 생각이 없었다. 중세 시대보다 더한 고대 그리스인이었던 아탈란타의 아버지는 딸의 독신 계획을 용납하지 못하고 달리기 시합을 열기로 했다. 이 시합에서 젊은 남성들이 경주를 벌이게 해서 이기는 자에게 딸을 시집보낼 생각이었다. 아탈란타는 자유를 지키기 위해 자신도 경주에 참여하게 해달라고 청했고, 아버지는 딸이 이길 수도 있다는 생각은 하지 못하고 그 청을 받아들였다.&lt;/p&gt;

  &lt;p&gt;경주에서 아탈란타는 놀랍도록 빨랐고 거의 이길 뻔했다. 한 남자, 히포메네스가 황금 사과 세 개를 그녀가 앞지르기 시작할 때마다 하나씩 굴리지만 않았다면 말이다. 아탈란타는 신기한 황금 사과들을 줍느라 중간에 멈춰 서야 했고, 결국 히포메네스가 간발의 차이로 그녀를 이겼다. 아탈란타가 애초에 자신이 세웠던 목표에만 매달렸더라면 아무 데도 매이지 않고 자유로운 삶을 살아갔을 것이다!&lt;/p&gt;

  &lt;p&gt;모든 벤처기업은 아탈란타처럼 그들의 여정에서 온갖 황금 사과들을 만날 것이다. 어떤 중요한 회의에서 주목받을 기회일 수도 있고, 어쩌면 자신을 위해 당신 회사의 소프트웨어를 바꿔달라고 청하는 거물 고객 한 명일 수도 있다. 아니면 당신의 주의를 흐트러뜨리는 독이 든 사과 같은 나쁜 직원일 수도 있다. 벤처기업의 적은 시간이다. 시기적절하게 실행하는 것을 막는 적은 집중을 방해한다.&lt;/p&gt;

  &lt;p&gt;회사는 훌륭한 목표를 세우고 매주 그 목표들을 달성하는 데 전념해야 하며, 그렇게 달성한 목표들을 축하하면서 나아가야지만 비로소 성장할 수 있다. 그 길에 어떤 반짝이는 사과들이 굴러오든 상관하지 말아야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스타트업을 다니면 이런 상황이 종종 발생합니다. 심지어 이 책의 주인공인 잭과 해나도 수많은 황금 사과들을 마주치죠. 현재 회사의 방향성에는 조금 어긋나는 것 같은 찜찜한 느낌이 들지만, 취하면 엄청난 돈이 될 것 같은 기회들.&lt;/p&gt;

&lt;p&gt;OKR 은 스타트업들이 이런 황금사과에 휘둘리지 않고 목표에 전념할 수 있도록 돕습니다. 유저들을 만족시키기 위한 플랫폼을 만들기로 했고, 신규 사용자 획득과 리텐션율을 Key Results 로 잡았다면, 자신들을 위해 만들고 있던 플랫폼을 개조해달라는 거물 고객을 만나도 확실한 판단을 할 수 있겠죠.&lt;/p&gt;

&lt;p&gt;Objective 와 key Results 를 달성하는데 필요하다면 하는 것이고, 필요하지 않다면 빛나는 황금사과라도 지나칠 용기가 필요합니다.&lt;/p&gt;

&lt;p&gt;함께 설정한 OKR 을 달성하는 것이 팀에 가장 건강하고 달콤한 사과이기 때문이죠.&lt;/p&gt;

&lt;h1 id=&quot;실천하기--okr-템플릿&quot;&gt;실천하기 : OKR 템플릿&lt;/h1&gt;

&lt;p&gt;OKR 탬플릿은 4개의 영역으로 나뉩니다. Objective 와 Key Results 를 설정하는 부분인 &lt;strong&gt;목표&lt;/strong&gt;, 목표를 달성하면서도 항상 점검해야할 항목들인 &lt;strong&gt;건전성&lt;/strong&gt;, 목표를 달성하기 위해 &lt;strong&gt;이번주 해야할 일&lt;/strong&gt;, 그리고 OKR 을 달성하면서 항상 인지하고 있어야 할 &lt;strong&gt;4주 내 향후 중요 이벤트&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/okr1.png&quot; alt=&quot;okr1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 그림에서 초록색 글씨는 한 분기에 한번 정하는 것이고, 붉은색 글씨는 매주 한번씩 수정하는 것입니다.&lt;/p&gt;

&lt;h1 id=&quot;목표&quot;&gt;목표&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/objective.png&quot; alt=&quot;objective&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;objective--key-results&quot;&gt;Objective &amp;amp; Key Results&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;목표&lt;/strong&gt; 칸에는 Objective &amp;amp; Key Results 를 적습니다. Objective 는 조금 추상적일수도 있는 이번 분기에 달성하고픈 목표이고, Key Results 는 그 목표의 달성 여부를 확인할 수 있는 수치들입니다. Key Results 를 모두 달성했다면 Objective 를 달성했다고 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;자신감-지표&quot;&gt;자신감 지표&lt;/h2&gt;
&lt;p&gt;Key Results 아래에는 매주 이 목표에 대한 달성 자신감을 0~10 사이의 정수로 나타냅니다. 처음 Key Results를 설정할 때에는, 지금 설정한 이 목표가 달성할 수 있을지, 못할지에 대한 확신이 5:5 여야 합니다. 너무 달성하기 쉬운 목표를 잡으면 의미가 없기 때문이죠. 따라서 분기 시작에 최초의 자신감은 5/10 으로 모두 적습니다. 한주 한주를 거듭하면서 자신감 지표는 업데이트 될 것이고, 목표를 향해 나아가는 팀원들에게 현재 팀 혹은 자신들의 상태를 알 수 있게 해주는 중요한 지표가 될 것입니다.&lt;/p&gt;

&lt;h1 id=&quot;건전성&quot;&gt;건전성&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/health.png&quot; alt=&quot;health&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;건전성&lt;/strong&gt;에는 OKR 달성을 위해 달려나가면서도, 중간 중간 점검해야 할 상태들입니다. 수치화해서 관리를 한다기보단, 매주 건전성 체크 목록에 있는 항목 중, 이번주에 점검해보면 좋겠다라고 꼽힌 2~3가지 정도를 팀이 함께 이야기하면서 현재 건전하게 지켜지고 있는지, 안되고 있다면 어떤 노력을 더 해야할지 정성적으로 이야기합니다.&lt;/p&gt;

&lt;p&gt;이번 분기의 목표를 “고급스런 브랜드 인식 심어주기” 라고 잡았고, 목표를 향해 온 팀이 전념하다보면 자칫하면 코드의 건전성, 수익 구조 와 같은 팀의 건강함을 뒷받침하는 중요한 요소들을 놓칠 수 있습니다. 이런 항목들을 &lt;strong&gt;건전성&lt;/strong&gt; 칸에 배치해두고 매주 점검하는 것은 매우 중요한 일입니다.&lt;/p&gt;

&lt;h1 id=&quot;이번주-해야할-일&quot;&gt;이번주 해야할 일&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/week.png&quot; alt=&quot;week&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이번주 해야할 일&lt;/strong&gt; 칸에는 이번 분기 목표를 달성하기 위해 이번주 해야할 아주 중요한 일들 3가지 만을 적습니다. 중요한 것은, 정보 공유의 목적이 아닌, 반드시 해내야 하는 일들에 대한 경각심을 주기 위한 리스트라는 것입니다. 자신이 무슨 일을 이번주에 집중하고 있는지 다른사람들에게 공유하기 위한 Todo 리스트가 아니기 때문에, 팀이 아무리 많은 일을 이번주에 진행하고 있다고 하더라도 반드시 해야 하는 중요한 3가지 일만 적습니다.&lt;/p&gt;

&lt;h1 id=&quot;4주-내-향후-중요-이벤트-알림&quot;&gt;4주 내 향후 중요 이벤트 알림&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/event.png&quot; alt=&quot;event&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4주 내 향후 중요 이벤트 알림&lt;/strong&gt; 칸은 정보 공유의 목적이 강합니다. 향후 4주 내로 큼지막하고 중요한 이벤트들을 매주 적어놓으면, 다른 부서의 누군가가 갑자기 특수한 요청을 해왔을 때 덜 당황할 수 있고, 다른 부서의 사람들이 요즘 무엇때문에 정신이 없고 매주 외근을 하는지 아는데에 도움이 됩니다.&lt;/p&gt;</content><author><name></name></author><category term="okr" /><category term="google" /><category term="book" /><category term="startup" /><summary type="html">최근 이직 온 회사에서 OKR 을 하고 있다는 것을 알기 전부터 OKR 에 관심이 많았습니다. 이전에 일하던 회사는 10명 남짓한 굉장히 작은 스타트업이었는데, 원하는 목표를 어떻게 하면 달성할 수 있을지 고민하던 찰나에 지인으로부터 OKR 에 대해 듣게 되었습니다. 당시 들었을 때에는, 그저 목표 달성을 위한 좋은 방법론이라 생각했습니다. 하지만 바빠서 자세히 알아보지 못했습니다.</summary></entry><entry><title type="html">How Great Leaders Inspire Actions?</title><link href="http://jaynewho.com/post/37" rel="alternate" type="text/html" title="How Great Leaders Inspire Actions?" /><published>2018-12-26T14:10:50+09:00</published><updated>2018-12-26T14:10:50+09:00</updated><id>http://jaynewho.com/post/37</id><content type="html" xml:base="http://jaynewho.com/post/37">&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.ted.com/talks/simon_sinek_how_great_leaders_inspire_action&quot;&gt;글 제목과 동명의 TED 영상을 시청 한 뒤, 내용을 정리한 글입니다.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apple 과 같은 기업은 같은 전문가, 같은 컨설턴트, 같은 기술, 같은 자원을 사용하는데 다른 IT 기업들과 무엇이 다르길래 사람들의 마음을 사로잡을까?&lt;/p&gt;

&lt;p&gt;마틴 루터 킹은 당시 고통받는 수많은 흑인들과 무엇이 달랐기에 리더가 되고 많은 사람들이 따랐을까?&lt;/p&gt;

&lt;p&gt;비행체 만들기 붐이 일었던 당시에, 라이트 형제는 어떻게 다른 더 많은 자본과 유명세가 있던 다른 경쟁자들과 다르게 비행기를 만드는데에 유일하게 성공하였을까?&lt;/p&gt;

&lt;p&gt;Simon Sinek 은 이들을 가능케 한 Pattern 이 무엇인지 오랜 고민끝에 밝혀냈습니다. 놀랍게도 대부분의 사람들이나 집단은 이 Pattern 과 정확히 정반대로 항상 문제를 접근하고, 오직 사람들에게 Inspire(영감)을 주는 소수의 인물과 집단들만이 이 Pattern 으로 사고합니다.&lt;/p&gt;

&lt;h2 id=&quot;the-golden-circle&quot;&gt;The Golden Circle&lt;/h2&gt;
&lt;p&gt;Simon Sinek 은 이 Pattern 을 &lt;strong&gt;Golden Circle&lt;/strong&gt; 이라고 일컫습니다. 그리고 이것이 &lt;strong&gt;특출난 이들을 특출나게 만드는 바로 그것&lt;/strong&gt; 이라고 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/37/IMG_1334.PNG&quot; alt=&quot;Golden Circle&quot; /&gt;&lt;/p&gt;

&lt;p&gt;대부분의 사람들이나 집단들은 Golden Circle 의 바깥에서 안쪽방향으로 사고합니다. 우리가 무엇을 하고있는지를 (What) 모르는 사람이나 집단은 없기 때문이죠. 어떤 기업은 말합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“우리는 스크린 캡쳐도 가능하고, 당신이 본 방송의 녹화도 자동으로 해주며, Live 생방송을 일시정지했다가 다시 볼 수 있는 엄청난 기능의 TV 를 팝니다. 멋지죠? 어떻게 만들었냐구요? 최고의 기술진들과 최첨단 기술들을 조합하였습니다!”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이를 본 고객들은 말합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;”오 멋진 사실인걸? 그런데 … 와닿지가 않아. (It doesn`t feel right)”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;왜 이런걸까요? 이 기업은 자신들이 무엇을 만드는지, 무엇을 만들고싶은지 정확히 알고있습니다. 어떻게 만들지도 알죠. 하지만 왜 만드는지가 없었습니다. Golden Circle 의 바깥쪽부터 안쪽으로 사고한것이죠. 고객들은 이 제품이 멋진 제품이란것을 부정하진 않지만, 사고싶지 않습니다. 그 이유는 인간의 뇌 또한 Golden Circle 을 닮았고, 인간의 뇌에서 의사결정을 담당하는 부분은 가장 안쪽인 Why 인 부분이기 때문이죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/37/img1234.png&quot; alt=&quot;simon sinek&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사람들은 자신의 뇌의 가장 안쪽인 Why 가 설득되어야 결정을 내립니다. 표면적인 사실들과 지표들은 뇌의 가장  바깥 부분인 What 계층에서 맴돌기만 할 뿐, 아무런 결정에 영향을 끼치지 않습니다.&lt;/p&gt;

&lt;p&gt;영감을 주는 기업이나 인물들은 모두 예외없이 Why-&amp;gt;How-&amp;gt;What 순서로 사고합니다. What 에 도달해 생긴 제품이나 결과물, 부의 축적 등은 이런 사고의 산물로 나온 현상일 뿐이지요. 강력한 Why 로부터 drive 된 무언가는 사람들의 뇌의 Why를 자극해 믿음(Belief), 영감(Inspire) 등을 부여합니다.&lt;/p&gt;

&lt;p&gt;아까 위의 기업이 아래와 같이 사고했다면 어떠하였을까요?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“우리는 세상 모든 사람의 Live 방송 시청 경험을 업그레이드 하고싶은 신념이 있어. 이것을 이루기 위해선 사람들이 Live 방송을 시청하는 디바이스의 개혁이 필요해. 그렇기 때문에 우리는 새로운 기능을 담은 TV 를 만들게 되었어. 한번 사지 않을래?”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;아까보다 보는 소비자, 고객으로 하여금 마음 속의 무언가를 꿈틀이게 하는 힘이 있습니다. 뇌 속의 결정권자 Why 를 자극한 것이죠.&lt;/p&gt;

&lt;p&gt;이와 같은 접근의 차이는 우리 주변에서도 볼 수 있습니다. Apple 아이폰과 삼성 옴니아를 예로 들겠습니다. Apple 은 “We beleive in thinking differently” 라고 말합니다. 이것이 가지는 힘에 대해 강한 신념을 가지고 있습니다. 이러한 Why 로부터 나온 현상들이 iPhone 이기도 하고 iPod 이기도 한 것입니다. 반면 삼성은 어떤 스펙의 스마트폰을 만들지 고민부터 하였을 것입니다. What 부터 사고한 것이죠.  이 차이가 고객들의 구매 의사를 결정지었습니다.&lt;/p&gt;

&lt;p&gt;비단 기업의 이야기만이 아닙니다. 마틴 루터 킹이 당시 유일하게 흑인 인권 운동을 외친 사람이었을까요? 마틴 루터 킹이 한 모든 행동이나 운동이 완전 무결하게 옳은 결정이었을까요? 그렇지 않습니다. 마틴 루터 킹의 가장 유명한 연설에서도 알 수 있듯이, 그는 왜 자신이 이것을 하는지에 대한 신념(Why) 를 강조합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I believe …&lt;/p&gt;

  &lt;p&gt;I believe …&lt;/p&gt;

  &lt;p&gt;I believe …&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이는 수많은 사람들에게 함께하고 싶은 신념, 믿음, 영감을 제시한 것이고, 이에 공감하는 사람들이 함께한 것입니다.&lt;/p&gt;

&lt;p&gt;정치인에 이 Golden Circle 을 대입시켜볼 수도 있겠습니다. 왜 언론에 나오는 수많은 정치인들이 내세우는 공약들이, 분명 멋진 공약들인데 와닿지 않을까요? 정치인들은 왜 시민들의 마음을 사로잡는데에 애를 먹는 것일까요? 아마도 Golden Circle 의 바깥쪽부터 안쪽으로 사고하였기 때문일 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/37/img123.png&quot; alt=&quot;simon sinek 2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;those-who-lead-inspire-us&quot;&gt;Those who lead inspire us&lt;/h2&gt;

&lt;p&gt;Simon Sinek 은, 결국 무언가 Lead 하는 사람, 즉 리더들은 사람들을 inspire 시킨다고 말합니다. 그 사람들에게 공감할 수 있는 Why 를 제시한다는 것이죠. 그 Why 에 공감한다면, 고객이나 직원이나 동료나 시민들이나 리더가 무엇을 하는지(What) 에 크게 동요되지 않을 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;궁금증&quot;&gt;궁금증&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SpaceX 를 추진하는 앨런 머스크는 Why-&amp;gt;What 으로 사고한 것일까?&lt;/li&gt;
  &lt;li&gt;Why-&amp;gt;What 으로 사고하는 Apple 이 겪고 있는 현재 위기는 어떻게 설명되어야 하는 것일까?&lt;/li&gt;
  &lt;li&gt;Golden Circle 의 안쪽에서 바깥쪽으로 사고하는 정치인이 우리나라에 있긴 했을까? 있다면 누구였을까?&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">글 제목과 동명의 TED 영상을 시청 한 뒤, 내용을 정리한 글입니다.</summary></entry></feed>