<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-03-06T23:34:30+09:00</updated><id>http://localhost:4000/</id><title type="html">Jayne.who();</title><subtitle>shinjayne`s Developer Blog. 신재인의 개발 블로그. Web / Deep Learning / Android / etc ...</subtitle><entry><title type="html">동시성 문제 - 데이터베이스와 JPA (Part 2)</title><link href="http://localhost:4000/post/43" rel="alternate" type="text/html" title="동시성 문제 - 데이터베이스와 JPA (Part 2)" /><published>2020-03-06T01:31:50+09:00</published><updated>2020-03-06T01:31:50+09:00</updated><id>http://localhost:4000/post/43</id><content type="html" xml:base="http://localhost:4000/post/43">&lt;blockquote&gt;
  &lt;p&gt;시리즈&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/post/42&quot;&gt;Part 1 : 동시성 문제 - 일반론&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;Part 2  : 동시성 문제 - 데이터베이스와 JPA &lt;strong&gt;(NOW)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞선 글에서 특정 시스템에 종속되지 않는 &lt;strong&gt;동시성 문제의 일반론&lt;/strong&gt;에 대해서 정리해보았습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동시성 문제는 2개 이상의 세션이 “읽고 쓰기 Read→Write” 하려고 할 때 발생한다.&lt;/li&gt;
  &lt;li&gt;동시성 문제는 크게 “일관성 없는 읽기” 와 “손실되는 업데이트” 로 나뉜다.&lt;/li&gt;
  &lt;li&gt;“일관성 없는 읽기” 는 불변성-복사본으로 해결한다.&lt;/li&gt;
  &lt;li&gt;“손실되는 업데이트” 는 낙관적 잠금과 비관적 잠금으로 해결한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이번 글에서는 데이터베이스 시스템과 JPA 에서는 동시성 문제를 어떻게 제어하는지 알아보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;데이터베이스의-동시성-제어&quot;&gt;데이터베이스의 동시성 제어&lt;/h1&gt;

&lt;p&gt;데이터베이스 시스템에서 세션은 “트랜잭션 (Transaction)” 입니다.&lt;/p&gt;

&lt;p&gt;Transaction 의 특성 4가지 ACID 중 Isolation 은 바로 트랜잭션의 동시성 제어와 깊이 관련이 있습니다.&lt;/p&gt;

&lt;p&gt;바로 이 Isolation 의 정도를 나타내는 Isolation Level 4가지가, 데이터베이스 동시성 제어의 핵심입니다.&lt;/p&gt;

&lt;p&gt;각각의 레벨에 따라 “일관성 없는 읽기” 와 “손실되는 업데이트” 가 해결되는지 확인해보겠습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Isolation Level&lt;/th&gt;
      &lt;th&gt;“일관성 없는 읽기” 해결되나?&lt;/th&gt;
      &lt;th&gt;“손실되는 업데이트” 해결되나?&lt;/th&gt;
      &lt;th&gt;일반론&lt;/th&gt;
      &lt;th&gt;“정확성과 활동성”&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Serializable&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;비관적 잠금으로 두 문제 모두 해결&lt;/td&gt;
      &lt;td&gt;정확성은 높으나 활동성 매우 낮음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Repeatable Read&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;복사본 사용으로 “일관성 없는 읽기” 해결&lt;/td&gt;
      &lt;td&gt;적절한 타협. 대부분 DBMS 의 기본값.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Read Committed&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;복사본을 사용하지 않아서 읽기에 일관성이 없음&lt;/td&gt;
      &lt;td&gt;활동성 (동시성) 이 매우 높음&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;Read Uncommitted 를 논외로 한 이유는 RDBMS 표준에서는 격리수준으로 인정하지 않기 때문입니다.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;jpa-의-동시성-제어&quot;&gt;JPA 의 동시성 제어&lt;/h1&gt;

&lt;p&gt;JPA 시스템에서의 세션은 하나의 JPA Transaction 입니다. JPA에서의  읽기 쓰기 동시성은 Entity 객체와 관련이 있습니다.&lt;/p&gt;

&lt;p&gt;Entity 객체를 한번 조회하면 JPA 의 영속성 컨텍스트 (Persistance Context) 에 캐시되기 때문에, 세션 (JPA Transaction) 내에서의 “일관성 없는 읽기” 의 문제는 없습니다.&lt;/p&gt;

&lt;p&gt;그렇다면 JPA 는 “손실되는 업데이트” 문제를 어떻게 제어할까요?  JPA 는 Entity 단위의 낙관적 잠금과 비관적 잠금을 제공합니다.&lt;/p&gt;

&lt;h2 id=&quot;jpa-낙관적-잠금&quot;&gt;JPA 낙관적 잠금&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/43/2.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JPA 의 버전 관리 기능 ( &lt;code class=&quot;highlighter-rouge&quot;&gt;@Version&lt;/code&gt; )을 이용해 Entity 의 버전을 관리해 낙관적 잠금을 구현합니다. Application Level 에서의 잠금이며,  낙관적 잠금이므로 두번째 세션이 Write 하기 전까지는 충돌을 알 수 없습니다.&lt;/p&gt;

&lt;p&gt;활동성은 높일 수 있지만, 잘 진행되고 있던 프로세스가 변경 사항을 저장하려고 할 때 까지 프로세스의 성패를 예측할 수 없다는 것이 단점입니다.&lt;/p&gt;

&lt;h2 id=&quot;jpa-비관적-잠금&quot;&gt;JPA 비관적 잠금&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/43/1.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터베이스가 제공하는 lock 기능을 이용해 엔티티를 영속 상태로 올릴 때부터 다른 세션에서 조회하지 못하도록 잠금을 걸어둡니다. ( &lt;code class=&quot;highlighter-rouge&quot;&gt;select for update&lt;/code&gt; 구문이라고 생각할 수 있습니다. )&lt;/p&gt;

&lt;p&gt;역시 비관적 잠금인만큼, 활동성은 매우 저하되지만 정확성과 세션의 성공은 보장됩니다.&lt;/p&gt;</content><author><name></name></author><category term="concurrency" /><category term="architecture" /><category term="enterprise" /><category term="database" /><category term="jpa" /><summary type="html">시리즈 Part 1 : 동시성 문제 - 일반론 Part 2 : 동시성 문제 - 데이터베이스와 JPA (NOW)</summary></entry><entry><title type="html">동시성 문제 - 일반론 (Part 1)</title><link href="http://localhost:4000/post/42" rel="alternate" type="text/html" title="동시성 문제 - 일반론 (Part 1)" /><published>2020-03-05T14:25:50+09:00</published><updated>2020-03-05T14:25:50+09:00</updated><id>http://localhost:4000/post/42</id><content type="html" xml:base="http://localhost:4000/post/42">&lt;blockquote&gt;
  &lt;p&gt;시리즈&lt;/p&gt;

  &lt;p&gt;Part 1 : 동시성 문제 - 일반론 &lt;strong&gt;(NOW)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;Part 2  : &lt;a href=&quot;/post/43&quot;&gt;동시성 문제 - 데이터베이스와 JPA&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;동시성 문제란 두 개 이상의 세션이 공통된 자원에 대해 모두 &lt;strong&gt;읽고 쓰는 작업(Read→Write)&lt;/strong&gt; 을 하려고 하는 경우 발생할 수 있는 문제를 말합니다.&lt;/p&gt;

&lt;p&gt;애플리케이션을 개발하다보면 여러 동시성 문제들을 만나고, 또 동시성 제어를 도와주는 여러 시스템들(데이터베이스 시스템, JPA 시스템 등) 을 보게됩니다.  이런 여러 시스템들이 제공하는 상세한 기능들은 모두 상이하지만, 동시성 문제를 정의하는 방식과 제어하는 이론적인 기틀은 모두 동일합니다.&lt;/p&gt;

&lt;p&gt;그래서 오늘은 특정 시스템에 종속되지 않는  &lt;strong&gt;동시성 문제와 제어 방법론&lt;/strong&gt;에 대해 정리하려고 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;동시성 문제에 “완전한 해결”은 없습니다. “제어”(적절한 해결) 만 있을 뿐입니다. 동시성 문제는 “정확성 과 활동성 을 어떻게하면 모두 최대로 할 수 있을까?” 에 대한 고민이기 때문입니다. 활동성 (얼마나 빠르게) 을 포기하면 정확성을 높일 수 있습니다. 마찬가지로 정확성(얼마나 올바른 데이터) 을 타협하면 활동성을 높일 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;동시성-문제와-제어-방법론&quot;&gt;동시성 문제와 제어 방법론&lt;/h1&gt;

&lt;p&gt;동시성 문제라고 불리우는 2가지 현상은 바로  “일관성 없는 읽기” 와 “손실되는 업데이트” 입니다.&lt;/p&gt;

&lt;h2 id=&quot;일관성-없는-읽기&quot;&gt;일관성 없는 읽기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/42/4.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;세션 2는 동시에 실행되고 있는 세션 1 때문에, 데이터에 접근하는 시점마다 다른 값을 읽게 됩니다. 이를 “일관성 없는 읽기” 라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;일관성-없는-읽기는-해결이-쉽다&quot;&gt;일관성 없는 읽기는 해결이 쉽다&lt;/h3&gt;

&lt;p&gt;일관성 없는 읽기는 해결이 쉽습니다. 바로 “불변성”, 복사본을 이용하면 됩니다. 세션 2가 최초로  데이터를 조회할 때 해당 데이터를 복사한 후, 이후에도 계속 사용하는 것입니다.  비록 세션 1이 변경한 데이터의 원장은 감지하지 못하더라도, 세션 2 내에서는 계속 동일한 복사본을 바라볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;손실되는-업데이트&quot;&gt;손실되는 업데이트&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/42/1.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;더 늦게 시작한 세션 2에 의해 세션 1의 변경사항이 무시되는 현상을 “손실되는 업데이트” 라고 합니다.&lt;/p&gt;

&lt;p&gt;데이터베이스 시스템, JPA 애플리케이션 시스템, 혹은 우리가 직접 조성하는 비즈니스 시스템에서 모두 중요하게 고려되어야 하는 문제입니다.&lt;/p&gt;

&lt;p&gt;“손실되는 업데이트” 를 방지하기 위한 방법으로는 크게 2가지가 있습니다. 바로 “낙관적 잠금” 과 “비관적 잠금” 입니다.&lt;/p&gt;

&lt;h3 id=&quot;낙관적-잠금&quot;&gt;낙관적 잠금&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/42/2.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“낙관적 잠금” 은 ‘저장 시 체크한다’ 입니다.  세션 1이 데이터 A 를 읽어왔더라도 세션 2는 자유롭게 데이터 A 를 읽어올 수 있습니다. 다만 저장하려고 할 때,  저장하려는 대상 데이터가 세션 2가 들고있던 데이터와 상이하면 저장이 되지 않습니다.&lt;/p&gt;

&lt;p&gt;낙관적 잠금을 구현하기 위해서는 공통된 리소스 A 에 대한 Versioning 이 되어야합니다. 세션 2가 들고 있는 A 의 Version 이, 저장하려는 대상 A 의 Version 과 같은지 체크해야하기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;비관적-잠금&quot;&gt;비관적 잠금&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/42/3.png&quot; alt=&quot;img-name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“비관적 잠금” 은 ‘이미 읽고 있는 사람이 있다면, 나는 못읽어’ 입니다. 보수적인 잠금이라고 할 수 있겠죠. 낙관적 잠금에 비관적 잠금은 세션이 실패할 확률은 줄여주지만, 여러 세션의 “활동성” 은 높여주지 못합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 다음 글  : &lt;a href=&quot;/post/43&quot;&gt;동시성 문제 - 데이터베이스와 JPA (Part 2)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;참고 문헌 : 마틴 파울러의 “엔터프라이즈 애플리케이션 아키텍쳐 패턴”&lt;/em&gt;&lt;/p&gt;</content><author><name></name></author><category term="concurrency" /><category term="architecture" /><category term="enterprise" /><summary type="html">시리즈 Part 1 : 동시성 문제 - 일반론 (NOW) Part 2 : 동시성 문제 - 데이터베이스와 JPA</summary></entry><entry><title type="html">논리력은 멘탈 모델 + 지식 체계 다. 을 읽고</title><link href="http://localhost:4000/post/41" rel="alternate" type="text/html" title="논리력은 멘탈 모델 + 지식 체계 다. &lt;슈퍼 씽킹&gt; 을 읽고" /><published>2020-03-01T00:12:50+09:00</published><updated>2020-03-01T00:12:50+09:00</updated><id>http://localhost:4000/post/41</id><content type="html" xml:base="http://localhost:4000/post/41">&lt;p&gt;“슈퍼 씽킹” 이란 책은 다음과 같은 주장으로 서문을 연다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;단편적인 사실들만 알고있는 것은 아무런 힘을 발휘하지 못한다. 사실들을 엮어 의미와 해석을 가능케 해주는 것을 “멘탈 모델” 이라고 하며, 이는 다양한 학문에서 유래하기도 하고, 살면서 자연스레 체득되기도 한다.&lt;/p&gt;

  &lt;p&gt;다양한 멘탈 모델들, 특히 모든 분야에 강력한 힘을 발휘하는 “슈퍼 모델” 들을 많이 익히면 “슈퍼 씽킹” 을 할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그리고 책의 구성은 저자가 살면서 습득한 다양한 슈퍼 멘탈 모델들을 나열하는 방식으로 되어있다.&lt;/p&gt;

&lt;p&gt;이 책이 전달하는 메세지가 책의 서문만을 읽고도 내게 큰 의미로 다가왔다. 그 이유를 이 글을 통해 설명하고자 한다.&lt;/p&gt;

&lt;p&gt;나는 “논리력” 이 내가 추구하는 중요한 능력이라는 사실을 최근에 자각했고 (논리적인 사고가 더 높은 생산성으로 이어진다고 믿기 때문이다), 그 “논리력” 이 강해지기 위해 필요한 것들을 찾으려 힘썼다. 그 중 첫 번째로 찾은 구성요소는 (어릴 적 부터 왠지 모르게 인생에서 중요하게 생각해온) “지식 체계” 다.&lt;/p&gt;

&lt;p&gt;한가지 새로운 지식을 습득해도 사람마다 흡수하는 속도가 다르다. 나는 이 차이를 발생시키는 원인을 지식 체계의 차이에서 찾았다.  자신이 쌓아온 지식 체계가 촘촘하고 빼곡할수록,  그 잘 짜여진 체 속에서 연관도가 높은 지식을 찾아, 새로운 지식을 빠른 속도로 배치할 수 있기 때문이다.  그리고 지식체계는 새로운 정보의 습득력 뿐만 아니라, 지금 상황에 딱 필요한 지식을 머릿속에서 검색하는 능력에도 강력한 힘을 발휘한다. 마치 인덱싱이 잘 된 데이터베이스가 검색 속도가 빠른 것과 같다.&lt;/p&gt;

&lt;p&gt;고도화된 지식 체계의 특성은  촘촘함 그리고 빼곡함인데, 이 두 특성 모두 개인이 얼마나 다양한 지식을 접했는가와 지식을 얼마나 체계적으로 정리할 수 있는 논리적 사고력을 갖췄는가 에 영향을 받는다.&lt;/p&gt;

&lt;p&gt;고도화된 지식 체계의 중요성을 설파하는 사람은 나뿐만이 아니다. 넷플릭스의 «Inside Bill Gates : 빌게이츠 다큐멘터리» 에서 빌게이츠도 자신의 독서습관을 소개하는 대목에서 지식 체계에 대해 언급한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘저는 제 머리 속의 지식의 틀 속에 새로운 지식들의 자리를 찾아 넣는 것을 좋아합니다.’ - &amp;lt; Inside Bill Gates : Netflix &amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;논리력이 강하려면 논리적 사고에 필요한 근거인 지식들이 수중에 많아야하고, 단순히 수중에 많은 것을 넘어서 빠르게 시의적절한 지식을 꺼내 논리의 근거로 사용할 수 있어야한다. 따라서 “고도화된 지식 체계” 는 논리력의 필요조건이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 항상 아쉬웠던 부분은 고도화된 지식 체계가 논리력 의 충분 조건은 아니라는 것이었다.  분명 논리력을 구성하는 요인이 지식 체계 외에 더 있다고 느끼고 있었는데, 이 슈퍼 씽킹이란 책의 서문과 목차를 읽고 바로 느꼈다. 내가 찾던 논리력 의 또 다른 필요 조건은 “다양한 멘탈 모델” 이였다는 것을.&lt;/p&gt;

&lt;p&gt;멘탈 모델이 무엇인지, 어떤 효용을 가지는지 와닿지 않는 분들이 있을 것이다. 그래서 다시 나의 글로 돌아가보자. 내가 이 글에서 작성한 다음의 두 글귀는 이 책의 영향을 받아, 평소에 내가 가지고 있던 멘탈 모델을 이용해 분석한 것이다.  첫 번째로 이 대목.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;‘그리고 지식체계는 새로운 정보의 습득력 뿐만 아니라, 지금 상황에 딱 필요한 지식을 머릿속에서 검색하는 능력에도 강력한 힘을 발휘한다. 마치 인덱싱이 잘 된 데이터베이스가 검색 속도가 빠른 것과 같다.’&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 대목에서 나는 컴퓨터공학에서 기인한 “데이터베이스의 인덱싱” 이라는 멘탈 모델을 이용해 지식 체계라는 보편적인 현상을 이해했다. (참고로 이 책에서는 이렇게 특정 학문적 영역에서 기인하였어도 보편적으로 효용을 줄 수 있는 멘탈 모델을 “슈퍼 모델” 이라고 부른다.)  만약 내가 이 멘탈 모델이 없었다면, 지식 체계의 중요성을 논리적으로 설명하지 못했을 수도 있고, 더 나아가서는 지식 체계의 중요성 자체를 인지하지 못했을 수도 있다.&lt;/p&gt;

&lt;p&gt;두번째로는 이 대목이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;‘고도화된 지식 체계가 논리력의 충분 조건은 아니라는 것이었다. 분명 논리력을 구성하는 요인이 지식 체계 외에 더 있다고 느끼고 있었는데, 이 슈퍼 씽킹이란 책의 서문과 목차를 읽고 바로 느꼈다. 내가 찾던 논리력의 또 다른 필요 조건은 “다양한 멘탈 모델” 이었다는 것을.’&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 대목에서는 “필요 충분 조건” 이라는 논리학에서 기인한 멘탈 모델을 사용한 것이다. 이 멘탈 모델을 사용하면 위 대목 뿐만 아니라 일상 생활의 다양한 부분에서 논리적 의존 관계를 더 쉽게 파악하고 다른 사람에게 설명할 수 있다. 멘탈 모델의 효용을 단적으로 보여주는 예이다.&lt;/p&gt;

&lt;p&gt;이렇듯 분명히 멘탈 모델은 똑같은 사실을 마주하더라도 더 빠르게 자신의 방식으로 현상을 해석할 수 있게 해주고, 논리적 결정의 속도와 근거력을 높여준다.  따라서 분명 멘탈 모델은 지식 체계와 더불어 논리력의 필요 조건이라고 할 수 있겠다.&lt;/p&gt;

&lt;p&gt;“슈퍼 씽킹” 이 서문에서부터 강조한 ‘슈퍼 씽킹을 하기 위한 슈퍼 멘탈 모델들의 중요성’ 은 나에게 위와 같은 생각을 하게 만들었고, 덕분에 나는 내가 중요하게 생각하는 “논리력” 에 필요한 중요한 요인을 또 하나 찾았다. 이는 내가 앞으로 책을 읽거나 새로운 정보를 얻었을 때, 지식 체계의 관점에서만이 아니라 새로운 멘탈 모델의 습득 관점에도 집중할 수 있게 해 줄 것이다. 이렇게 생각하니 정말 마음이 부푼다. 부푼 마음으로 서문에서 슈퍼 씽킹의 표지를 덮는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/41/bookcover.jpg&quot; alt=&quot;책&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="inspiration" /><category term="book" /><category term="logical" /><category term="thinking" /><summary type="html">“슈퍼 씽킹” 이란 책은 다음과 같은 주장으로 서문을 연다.</summary></entry><entry><title type="html">점을 연결하는 사람들 - ‘기획자의 습관’을 읽고</title><link href="http://localhost:4000/post/40" rel="alternate" type="text/html" title="점을 연결하는 사람들 - '기획자의 습관'을 읽고" /><published>2019-08-08T21:30:50+09:00</published><updated>2019-08-08T21:30:50+09:00</updated><id>http://localhost:4000/post/40</id><content type="html" xml:base="http://localhost:4000/post/40">&lt;blockquote&gt;
  &lt;p&gt;«기획자의 습관» 을 읽고. 창의, 통찰, 연결, 기획에 대한 생각 정리.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;기획자의 습관이란 책을 읽고 있습니다.&lt;/p&gt;

&lt;p&gt;저자 최장순씨는 오랫동안 기획자로 일했고, 자신이 일상에서 어떻게 기획 아이디어를 이끌어내는지를 이 책에 담았습니다.&lt;/p&gt;

&lt;p&gt;첫 챕터의 첫번째 주제는 “엣지오브 투모로우”라는 영화입니다. 그는 이 영화를 관람하고, 마치 매일 반복되는 일상을 살면서 “내일의 가장자리” 에서 “내일” 로 넘어가지 못하는 우리의 삶을 떠올렸고, 니체의 “영원회귀” 사상을 떠올렸고, 니체의 저서 «차라투스트라는 이렇게 말했다» 의 “양치기소년이 뱀을 물어뜯은 후 ‘변화한 자’ 가 되었다”  란 이야기를 떠올렸습니다. 굉장히 통찰력 있는 연결이라고 생각합니다.&lt;/p&gt;

&lt;p&gt;저는 이렇게 통찰력 있는 연결이 굉장히 멋있다고 생각합니다. 사실 창의적인 아이디어, 대단한 기획은 세상에 이미 존재하는 것들을 새로운 관점에서 연결점을 찾아내고 새로운 방식으로 잘 연결하는 것입니다.&lt;/p&gt;

&lt;p&gt;스티브 잡스는 인터뷰에서 “어떻게 그렇게 창의적인 아이디어들을 낼 수 있나요?” 라는 질문을 받고 이렇게 답했다고 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“사실 저는 그런 이야기를 들을때마다 굉장히 부끄럽습니다. 저는 다른사람들과 크게 다르거나, 특별히 더 천재적이지 않기 때문이죠. 저는 그저 세상에 이미 존재하는 것들을, 이전과는 다른 방식으로 연결하는 것 뿐입니다. 그리고 저는 창의성이 바로 그런 것이라고 생각합니다. 따라서 창의성은 연습을 통해 기를 수 있습니다.”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;어떻게보면 제가 기획자의 습관이라는 책을 읽다가, 스티브잡스를 떠올린 것도 하나의 “새로운 연결” 을 찾아낸 것입니다. 이 또한 창의성을 발휘한 것이라고 볼 수 있겠죠.&lt;/p&gt;

&lt;p&gt;새로운 연결을 잘 찾아내는 것을 혹자는 “통찰” 이라고 표현합니다. 저는 “창의”, “통찰” 모두 맞다고 생각합니다.&lt;/p&gt;

&lt;p&gt;기획, 창의, 통찰, 연결. 모두 제게는 같은 말로 느껴집니다.&lt;/p&gt;

&lt;p&gt;“창의”, “통찰” 을 잘하기위해선 어떻게 훈련해야할까요? 일상에 존재하는, 혼자서는 무의미한 점들을 연결해 의미를 만들어내는 것, 어떻게하면 잘 할 수 있을까요?&lt;/p&gt;

&lt;p&gt;우선 첫째로는 재료가 될 점들을 많이 알아야하고, 둘째로는 점들간의 관통하는 아이디어를 끄집어내고 연결할 줄 아는 센스를 길려야한다고 생각합니다.&lt;/p&gt;

&lt;p&gt;재료가 되는 점들을 많이 알려면 책을 많이 읽고, 세상에 일어나는 일들에 많은 관심을 기울여야합니다.&lt;/p&gt;

&lt;p&gt;점들간의 관통하는 아이디어를 끄집어내고 연결하는 센스를 기르려면, 점들을 잘 연결하는 사람들의 이야기를 많이 듣고 보고 익혀야합니다. “창의” 는 스티브잡스의 말처럼, 훈련해서 기를 수 있는 “후천적 능력” 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/40/bookcover.jpg&quot; alt=&quot;책표지&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="inspiration" /><category term="book" /><category term="planning" /><summary type="html">«기획자의 습관» 을 읽고. 창의, 통찰, 연결, 기획에 대한 생각 정리.</summary></entry><entry><title type="html">JPA 의 Fetch Type 과 친해지기</title><link href="http://localhost:4000/post/39" rel="alternate" type="text/html" title="JPA 의 Fetch Type 과 친해지기" /><published>2019-08-06T21:30:50+09:00</published><updated>2019-08-06T21:30:50+09:00</updated><id>http://localhost:4000/post/39</id><content type="html" xml:base="http://localhost:4000/post/39">&lt;p&gt;JPA 를 이용한 개발을 하다보면 자주 접하는 프로그래밍적인 이슈가 있습니다. 바로 &lt;strong&gt;Fetch Type (Fetch 전략)&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;Fetch Type 속성은 언제 동작하고 어떻게 동작하는지, 그리고 어떨 때 Fetch Type 때문에 N+1 문제가 발생하는지, 또 어떻게 해결하는지 알아봅니다.&lt;/p&gt;

&lt;p&gt;추가적으로, 이상하게 동작하는 OneToOne 의 FetchType LAZY 설정도 짚고 넘어갑니다.&lt;/p&gt;

&lt;p&gt;이 글을 이끌어가는데 도움을 주는 두 엔티티를 소개합니다. “주문” 과 “멤버” 라는 친구들입니다. 주문과 멤버는 N:1 의 관계에 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 주문 엔티티&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;order&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@ManyToOne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;member_id&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 멤버 엔티티&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Entity&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;member&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Id&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Column&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@OneToMany&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orders&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;fetch-type-이란&quot;&gt;Fetch Type 이란&lt;/h1&gt;

&lt;p&gt;Fetch Type 은 JPA 가 하나의 Entity 를 조회할 때, 연관관계에 있는 객체들을 어떻게 가져올 것이냐를 나타내는 설정값입니다.&lt;/p&gt;

&lt;p&gt;Fetch Type 은 크게 Eager 와 Lazy 두가지 전략이 있습니다. Fetch Type Issue 상황이라는 것은 하나의 Entity 를 로드할 때, 아래의 두가지 전략 중 고민하는 상황을 말합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;연관 관계에 있는 Entity 들 모두 가져온다 → Eager 전략&lt;/li&gt;
  &lt;li&gt;연관 관계에 있는 Entity 가져오지 않고, getter 로 접근할 때 가져온다 → Lazy 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;fetch-type-어떻게-동작할까요&quot;&gt;Fetch Type 어떻게 동작할까요?&lt;/h1&gt;

&lt;h2 id=&quot;manytoone-컬럼-있을-때-주인일-때&quot;&gt;ManyToOne 컬럼 있을 때 (주인일 때)&lt;/h2&gt;

&lt;p&gt;Order Entity 는 단일 Member Entity 를 가지는 ManyToOne 컬럼이 있습니다. ( member 의 PK 가 Foreign Key 로 실제로 order DB컬럼에 매핑되어있으므로 Order 가 주인입니다. )&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ManyToOne 의 기본 FetchType 은 EAGER 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fetchtypeeager-기본&quot;&gt;FetchType=EAGER &lt;code class=&quot;highlighter-rouge&quot;&gt;기본&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;아래와같이, Join 을 통해 한번에 모든 쿼리를 가져옵니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	order.id,
	order.member_id,
	member.id,
	member.name
from order
outer join member
	on order.member_id=member.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;order 에 대한 for 문이 돌면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;order.getMember&lt;/code&gt; 를 호출했다고 합시다.&lt;/p&gt;

&lt;p&gt;이미 member 관련 정보가 Entity Manager 에 캐싱이 되어있기 때문에 추가적인 쿼리는 나가지 않을 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;fetchtypelazy&quot;&gt;FetchType=LAZY&lt;/h3&gt;

&lt;p&gt;Order List 를 가져오는 상황에서 &lt;strong&gt;N+1 Problem 이 발생할 수 있습니다&lt;/strong&gt;. Order List 를 불러온 뒤, 각 Member 에 대해 무언가를 하는 For Loop 가 코드에 있다면 말입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	order.id,
	order.member_id
from order;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 쿼리 결과가 아래와 같다고 합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;order.id&lt;/th&gt;
      &lt;th&gt;order.member_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1001&lt;/td&gt;
      &lt;td&gt;999&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1002&lt;/td&gt;
      &lt;td&gt;888&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1003&lt;/td&gt;
      &lt;td&gt;777&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;order 에 대한 for 문이 돌면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;order.getMember&lt;/code&gt; 를 호출했다고 합시다. 그럼 아래와 같이 3번의 쿼리가 더 발생할 것입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	member.id,
	member.name
from member
where member.id=999;

select
	member.id,
	member.name
from member
where member.id=888;

select
	member.id,
	member.name
from member
where member.id=777;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;onetomany-컬럼-있을-때-종일-때&quot;&gt;OneToMany 컬럼 있을 때 (종일 때)&lt;/h2&gt;

&lt;p&gt;Member Entity 에는 Order Entity Collection (List 혹은 Set) 을 가지는 OneToMany 컬럼이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OneToMany 의 기본 FetchType 은 LAZY 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fetchtypeeager&quot;&gt;FetchType=EAGER&lt;/h3&gt;

&lt;p&gt;Member List 를 가져오려고 해봅시다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	member.id,
	member.name
from member;

// member 가 2개 라면
// order set 땡겨오는 쿼리도 바로 2번 날라갑니다.

select
	order.id,
	order.member_id
from order
where member_id=999;

select
	order.id,
	order.member_id
from order
where member_id=888;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;member 를 가져오는 동시에 쿼리가 2방 더 날라갑니다. (이를 한번의 쿼리로 해결하려면 직접 JPQL 을 작성하거나 Query Builder 를 이용해 Fetch Join 을 해야합니다.)&lt;/p&gt;

&lt;h3 id=&quot;fetchtypelazy-기본&quot;&gt;FetchType=LAZY &lt;code class=&quot;highlighter-rouge&quot;&gt;기본&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Member List 를 가져오려고 해봅시다. 한번의 쿼리만 날라갑니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	member.id,
	member.name
from member;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;fetchtype-이-동작하는-시점&quot;&gt;FetchType 이 동작하는 시점&lt;/h1&gt;

&lt;p&gt;JPA Entity Manager 에 의해 관리되는 Persistence Context 에 Entity 가 Managed 상태로 올라올 때의 동작입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/39/39-persist-context.png&quot; alt=&quot;39-persist-context&quot; /&gt;&lt;/p&gt;

&lt;p&gt;queryDSL 과 같은 쿼리 빌더를 이용해 아무리 Join 문을 짜도, (Fetch Join 을 하지 않는 이상) 메인 도메인의 엔티티만 Persistence Context 에 올라옵니다. 연관관계에 대한 Fetch 도 메인 도메인만 일어납니다.&lt;/p&gt;

&lt;h1 id=&quot;n1-문제는-이럴-때-발생합니다&quot;&gt;N+1 문제는 이럴 때 발생합니다.&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ManyToOne, OneToOne 컬럼의 FetchType 을 LAZY 로 하였을 경우 발생합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;n1-은-어떻게-해결할까요&quot;&gt;N+1 은 어떻게 해결할까요?&lt;/h2&gt;

&lt;p&gt;N+1 이 발생하는 Entity 연관관계를 발견하였다면, 한 Entity 가 Managed 상태로 올라올 때, N+1 문제를 일으키는 Entity Collections 들도 동시에 Managed 상태로 올라오게 하면 됩니다.&lt;/p&gt;

&lt;p&gt;지금까지 크게 3가지 방법을 발견했습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;JPQL 의 Fetch Join 을 이용합니다. (QueryDSL 과 같은 쿼리빌더의 도움을 받을 수도 있습니다.)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ManyToOne, OneToOne 의 FetchType = LAZY → EAGER 로 변경합니다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@EntityGraph&lt;/code&gt; 를 이용해, 한 쿼리에 대해서만 EAGER load 를 지정합니다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;onetoone-의-fetchtype-lazy-는-사용자가-의도한대로-동작하지-않습니다&quot;&gt;OneToOne 의 FetchType LAZY 는 사용자가 의도한대로 동작하지 않습니다.&lt;/h1&gt;

&lt;p&gt;OneToOne 컬럼의 FetchType=LAZY 는 사용자가 의도한대로 동작하지도 않습니다! 아래의 글을 보시죠.&lt;/p&gt;

&lt;p&gt;OneToOne 의 FetchType=LAZY 는 컬럼을 조회하지 않아도 무조건 쿼리가 날라갑니다. 1번 날라갈 쿼리를 무조건 날라가는 2번의 쿼리로 바꿔치기 하는 셈 뿐입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wonwoo.ml/index.php/post/1566&quot;&gt;hibernate OneToOne lazy 구현하기&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;query-builder-를-이용하는-경우-onetoone-은-fetch-join-걸어주는게-좋습니다&quot;&gt;Query Builder 를 이용하는 경우, OneToOne 은 Fetch Join 걸어주는게 좋습니다.&lt;/h1&gt;

&lt;p&gt;쿼리 빌더를 이용해서 Order List 를 가져오는 쿼리를 짠다고 합시다. 예를 들면 queryDSL 기준으로 아래와 같이 짭니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Order&amp;gt; orders = jpaQueryFactory.select(qOrder).from(qOrder).fetch();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;개발자는 Order 의 Member 연관관계가 FetchType EAGER 로 설정되어있으므로, Order 와 Member 를 조인에서 한번에 가져와주는 쿼리가 나가길 기대할 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 쿼리 빌더를 이용하면, 사실 순수한 Order 에 대한 쿼리만 나가는 경우가 많습니다. 아래와 같이 말이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select
	order.id,
	order.member_id
from order;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이렇게 쿼리가 나가면, 복수개의 Order Entity 가 영속성 컨텍스트로 로드될 때 EAGER 로 설정된 Member 연관관계의 Fetch Type 이 동작하여 바로 N개의 단일 Member 쿼리가 나가게 됩니다. (FetchType 이 동작하는 시점은 영속성 컨텍스트로 로드될 때입니다.)&lt;/p&gt;

&lt;p&gt;따라서 Query Builder 를 이용해 JPQL 쿼리를 직접 작성할 경우, One To One 관계의 Entity 에 대해선 Fetch Join 을 걸어주는 것이 좋습니다.&lt;/p&gt;

&lt;h1 id=&quot;더-읽어보면-좋을-글&quot;&gt;더 읽어보면 좋을 글&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;N+1 문제를 해결하기 위한 방법들&lt;/strong&gt;을 잘 정리해놓은 글입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Fetch Join&lt;/code&gt; 을 이용하는 방법과 &lt;code class=&quot;highlighter-rouge&quot;&gt;@EntityGraph&lt;/code&gt; Annotation 을 이용하는 법을 소개하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jojoldu.tistory.com/165&quot;&gt;JPA N+1 문제 및 해결방안&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="java" /><category term="spring" /><category term="jpa" /><summary type="html">JPA 를 이용한 개발을 하다보면 자주 접하는 프로그래밍적인 이슈가 있습니다. 바로 Fetch Type (Fetch 전략) 입니다.</summary></entry><entry><title type="html">2018 webRTC 정리</title><link href="http://localhost:4000/post/36" rel="alternate" type="text/html" title="2018 webRTC 정리" /><published>2019-04-19T14:10:50+09:00</published><updated>2019-04-19T14:10:50+09:00</updated><id>http://localhost:4000/post/36</id><content type="html" xml:base="http://localhost:4000/post/36">&lt;blockquote&gt;
  &lt;p&gt;2018년도에 webRTC 를 이용한 ‘코딩 실시간 화상 강의실 서비스’ 를 만들던 경험을 떠올리며, webRTC API 를 이용한 애플리케이션 작성법을 정리해봅니다. 🎉&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;what-is-webrtc&quot;&gt;What is &lt;code class=&quot;highlighter-rouge&quot;&gt;WebRTC&lt;/code&gt;?&lt;/h1&gt;
&lt;p&gt;WebRTC 는 브라우저나 모바일 application 에서 Real Time Communication (RTC) 를 편리하게 할 수 있는 api 를 만들고자 하는 목적으로 시작된 프로젝트입니다. Open Project 이지만 (2018년 12월 기준) Google Chrome Team 의 주도로, Mozilla, Opera 등의 단체의 지원을 받으며 진행되고 있습니다.&lt;/p&gt;

&lt;p&gt;프로젝트의 진행 방식은, WebRTC API 최신 명세 (SPEC) 를 &lt;code class=&quot;highlighter-rouge&quot;&gt;WebRTC M{xx}&lt;/code&gt; 와 같은 이름으로 공개하고, 거의 동시에 Chrome (혹은 Chrome Beta) 에 구현하여 릴리즈하는 것 같습니다. Opera, Safari, Firefox 등의 브라우저들은 이 공개된 명세에 발맞춰 따라옵니다.&lt;/p&gt;

&lt;p&gt;WebRTC 로 할 수 있는 일은 굉장히 많습니다. 그 중에서도 이 글에서는 서버를 통하지 않고 클라이언트와 클라이언트 간의 p2p 영상/음성/데이터 통신을 하는 활용법에 초점을 맞춰서 webRTC 의 API 를 정리해보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://webrtc.org/&quot;&gt;WebRTC 공식 홈페이지 webrtc.org 링크&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;webrtc-의-3가지-대표-api&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WebRTC&lt;/code&gt; 의 3가지 대표 API&lt;/h1&gt;

&lt;p&gt;2018년 말인 현재, 대부분의 브라우저가 webRTC API 표준을 지원합니다. 대부분의 브라우저에서 지원하는 webRTC 의 대표적인 표준 API 3가지를 소개하겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MediaStream&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;getUserMedia&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTCDataChannel&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;api-1-mediastream&quot;&gt;API 1. &lt;code class=&quot;highlighter-rouge&quot;&gt;MediaStream&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;사용자의 카메라와 마이크 같은 곳의 데이터 스트림에 접근합니다. 우리의 애플리케이션이 사용자의 음성, 영상 데이터를 채집해 올 때 자주 사용하게 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;api-2-rtcpeerconnection&quot;&gt;API 2. &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;암호화 및 대역폭 관리를 하는 기능을 가지고 있고, 오디오 또는 비디오 연결을 담당합니다. 애플리케이션이 채집한 음성 및 영상 데이터를 서로 주고 받는 채널을 추상화하였다고 생각하면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;api-3-rtcdatachannel&quot;&gt;API 3. &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCDataChannel&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;음성 및 영상 데이터가 아닌, json/text 데이터들을 주고받는 채널을 추상화한 API 입니다.&lt;/p&gt;

&lt;h1 id=&quot;webrtc-application-이-수행하는-것&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;webRTC&lt;/code&gt; application 이 수행하는 것&lt;/h1&gt;

&lt;p&gt;여러분이 만약 p2p 영상 및 음성 통신을 하는 webRTC application 을 구성한다면, 다음의 주요한 4가지 작업을 수행해야 할 것입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;no&lt;/th&gt;
      &lt;th&gt;stage&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Fetching&lt;/td&gt;
      &lt;td&gt;상대 peer 에게 보낼 사용자의 음성 및 영상 데이터를 수집합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Signaling&lt;/td&gt;
      &lt;td&gt;이 세상 어딘가에 있는 상대 peer 와 연결을 맺기 위해서, 상대 peer 의 정보를 탐색합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Connection&lt;/td&gt;
      &lt;td&gt;발견한 peer 와 p2p connection 을 맺습니다. channel 을 개방해둡니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Communication&lt;/td&gt;
      &lt;td&gt;개방해놓은 채널을 통해 음성/영상/텍스트 데이터를 주고 받습니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위의 4가지 작업의 구체적인 방식과, 각각의 수행에 필요한 webRTC API 들을 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;1단계-fetching&quot;&gt;1단계. Fetching&lt;/h2&gt;

&lt;p&gt;webRTC API 인 &lt;code class=&quot;highlighter-rouge&quot;&gt;MediaStream&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;getUserMedia&lt;/code&gt; 를 이용해 사용자의 영상 및 음성 정보를 가져옵니다. 가져온 이후의 활용법은 4단계에서 자세히 다루겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;2단계-signaling&quot;&gt;2단계. Signaling&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;잠깐! Signlaing 단계는 피어와 피어가 서로를 찾을 수 있도록 돕는 &lt;strong&gt;중간 매개자 역할을 하는 서버인 Signaling Server 를 필요&lt;/strong&gt;로 합니다. Signaling Sever 의 &lt;strong&gt;구현 방식에는 제약이 없습니다.&lt;/strong&gt;  오롯히 애플리케이션을 만드는 개발자의 몫입니다. 개발 엔지니어 개인 역량에 따라 구현 형태도 다르고, 정답도 없습니다. webRTC 애플리케이션 개발을 하면서 가장 어려웠던 부분이기도 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Signaling 단계는 서로 다른 두 peer (WebRTC Client) 가 Communication 하기 위한 준비단계로, 3가지 종류의 정보를 교환해야 합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Network 정보를 교환합니다.
    &lt;ul&gt;
      &lt;li&gt;ICE Framework 를 사용해 find candidate =&amp;gt; ip 와 port 를 찾는다&lt;/li&gt;
      &lt;li&gt;내 ip 와 port 정보&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Media Capability 를 교환합니다.
    &lt;ul&gt;
      &lt;li&gt;sdp (Session Description Protocol) 형식을 따르는 blob 인  &lt;code class=&quot;highlighter-rouge&quot;&gt;offer&lt;/code&gt; 와 &lt;code class=&quot;highlighter-rouge&quot;&gt;answer&lt;/code&gt; 를 주고 받으며 교환합니다.&lt;/li&gt;
      &lt;li&gt;내 브라우저와 상대 peer 브라우저가 사용 가능한 코덱들과 해상도들은 무엇일까&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Session Control Messages 교환합니다
    &lt;ul&gt;
      &lt;li&gt;Session (통신연결) 의 초기화,종료&lt;/li&gt;
      &lt;li&gt;Error Report&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;조금 더 자세히 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;network-정보-ice-candidate-교환하기&quot;&gt;Network 정보 (ICE Candidate) 교환하기&lt;/h3&gt;

&lt;p&gt;세상 어딘가에 있는 상대 peer 를 찾아 연결을 맺기 위해선, 네트워크 정보를 교환해야합니다. 이 때, 중간 매개자 역할로서 별도의 서버인 Signaling Server 가 필요합니다. 순서는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;step&lt;/th&gt;
      &lt;th&gt;do&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; Object 를 새롭게 생성하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.onicecandidate&lt;/code&gt; 핸들러를 통해 현재 내 client 의 Ice Candidate(Network 정보)  가 확보되면 실행될 callback 을 전달합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Ice Candidate (내 네트워크 정보) 가 확보되면, 중간 매개자인 Signaling Server 을 통해 상대 peer 에게  serialized 된 ice candidate 정보를 전송합니다. (쌍방이 서로에게 합니다.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;상대 peer 의 candidate (네트워크 정보) 가 도착하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.addIceCandidate&lt;/code&gt; 를 통해 상대 peer 의 네트워크 정보를 등록합니다. (쌍방이 모두 합니다.)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;media-capability-교환하기--session-control-message-교환하기&quot;&gt;Media Capability 교환하기 + Session Control Message 교환하기&lt;/h3&gt;

&lt;p&gt;상황을 가정해봅시다. A 와 B 가 webRTC 통신을 하려고합니다. 각자 브라우저에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; 객체를 가지고 있고, 서로의 네트워크 정보 (ice candidate) 를 교환 후 각자의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.addIceCandidate&lt;/code&gt; 를 통해 서로의 네트워크 정보를 등록하였습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;step&lt;/th&gt;
      &lt;th&gt;do&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;B 가 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.createOffer&lt;/code&gt; 를 호출해 Offer SDP (Session Description Protocol) 을 생성합니다. 여기엔 내 브라우저에서 사용 가능한 코덱이나 해상도에 대한 정보가 들어있습니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;B 가 Offer SDP 를 Signaling Server (매개자) 을 통해 전송합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;A 는 Signaling Channel 에서 Offer SDP 를 받아, &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.setRemoteDescription&lt;/code&gt; 을 수행합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;A 의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; 객체는 상대 session 에 대한 정보를 알고 있게 되었고, &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.createAnswer&lt;/code&gt; 를 호출하여 Answer SDP 를 생성하여 Signaling Channel 을 통해 B 에게 전달합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;B 도 마찬가지로 자신의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.setRemoteDescription&lt;/code&gt; 을 호출해, 전달받은 Answer SDP 를 등록합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;A, B 각 측에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;setRemoteDescription&lt;/code&gt; 이 성공적으로 수행되었다면, 각 브라우저에서는 서로의 peer 에 대해 인지하고 있는 상태라고 할 수 있고, p2p 연결이 성공적으로 완료되었다고 할 수 있습니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;3단계-connection&quot;&gt;3단계. Connection&lt;/h2&gt;

&lt;p&gt;어려운 Signaling 을 통해 상대 피어의 정보가 잘 등록된 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; 를 얻었다면, 연결이 성공적으로 이루어진 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;4단계-communication&quot;&gt;4단계. Communication&lt;/h2&gt;
&lt;p&gt;보통 webRTC 를 통해서 peer 와 peer 가 주고받는 데이터는 크게 아래의 두가지입니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;video 나 audio 데이터 스트림&lt;/li&gt;
  &lt;li&gt;직렬화된 text 데이터&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;교환의 양상은, 연결이 이루어지기 전에 데아터 stream 이나 채널을 미리 준비하고, 연결이 완료되면 데이터를 받았을 때의 callback 을 통해 받은 데이터를 처리합니다. 조금 더 자세한 내용은 아래와 같습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-video-나-audio-데이터-스트림-의-경우&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1. video 나 audio 데이터 스트림&lt;/code&gt; 의 경우&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;주는 입장&lt;/strong&gt; : 자신의 머신에서  (&lt;code class=&quot;highlighter-rouge&quot;&gt;getUserMedia&lt;/code&gt; 등의 api 를 통해) video/audio 스트림 source 를 취득해 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; 을 생성할 당시에 &lt;code class=&quot;highlighter-rouge&quot;&gt;addTrack&lt;/code&gt;(데이터 stream 채널을 연결) 해줍니다. Signaling 을 통해 connection 이 이루어지기 전에 미리 되어야합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;받는 입장&lt;/strong&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.ontrack&lt;/code&gt; 의 callback 을 커스텀하게 설정해서, connection 이 성공적으로 이루어진 후에 상대방의 Track (video/audio stream) 이 감지되면 어떤 동작을 할지 설정할 수 있습니다. 보통 받은 track 의 데이터 스트림을 DOM 의 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;video srcObject={??}/&amp;gt;&lt;/code&gt; element 에 연결해 보여줍니다.&lt;/p&gt;

&lt;h4 id=&quot;2-직렬화된-text-데이터-의-경우&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2. 직렬화된 text 데이터&lt;/code&gt; 의 경우&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;주는 입장&lt;/strong&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.createDataChannel&lt;/code&gt;  을 통해, 특정 이름의 data 전달 채널을 개설할 수 있습니다. 이 또한 Signaling 을 통해 connection 이 이루어지기 전에 미리 되어야합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;받는 입장&lt;/strong&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.ondatachannel&lt;/code&gt; 의 callback 을 커스텀하게 설정해서, connection 이 성공적으로 이루어진 후에 상대방이 data channel 을 통해 어떤 데이터를 보냈을 때의 동작을 설정할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;webrtc-애플리케이션을-만들-때-겪었던-어려움&quot;&gt;webRTC 애플리케이션을 만들 때 겪었던 어려움&lt;/h1&gt;
&lt;h2 id=&quot;1-피어간의-연결이-끊겼을-때-다시-연결을-맺어줘야-한다&quot;&gt;1. 피어간의 연결이 끊겼을 때, 다시 연결을 맺어줘야 한다&lt;/h2&gt;
&lt;p&gt;인터넷의 문제나 예기치 못한 문제로 피어와 피어간에 맺어놓은 Connection 이 끊어지는 일이 굉장히 자주 발생합니다. 이 때 적절한 retry 로직으로 자연스럽게 재연결을 맺어주어야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;2-안정적인-signaling-server-를-구축해야한다&quot;&gt;2. 안정적인 Signaling Server 를 구축해야한다&lt;/h2&gt;
&lt;p&gt;Signaling 단계가 성공하지 못하면 Connection 을 맺을 수 조차 없습니다. 따라서 안정적인 Signaling Server 를 구축하는 것이 무엇보다 중요했습니다.&lt;/p&gt;

&lt;h1 id=&quot;참고한-자료들&quot;&gt;참고한 자료들&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Getting Started with webRTC : https://www.html5rocks.com/ko/tutorials/webrtc/basics/&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="webrtc" /><category term="js" /><category term="p2p" /><category term="frontend" /><summary type="html">2018년도에 webRTC 를 이용한 ‘코딩 실시간 화상 강의실 서비스’ 를 만들던 경험을 떠올리며, webRTC API 를 이용한 애플리케이션 작성법을 정리해봅니다. 🎉</summary></entry><entry><title type="html">구글이 목표를 달성하는 방식, OKR</title><link href="http://localhost:4000/post/38" rel="alternate" type="text/html" title="구글이 목표를 달성하는 방식, OKR" /><published>2019-01-27T21:30:50+09:00</published><updated>2019-01-27T21:30:50+09:00</updated><id>http://localhost:4000/post/38</id><content type="html" xml:base="http://localhost:4000/post/38">&lt;p&gt;최근 이직 온 회사에서 OKR 을 하고 있다는 것을 알기 전부터 OKR 에 관심이 많았습니다. 이전에 일하던 회사는 10명 남짓한 굉장히 작은 스타트업이었는데, 원하는 목표를 어떻게 하면 달성할 수 있을지 고민하던 찰나에 지인으로부터 OKR 에 대해 듣게 되었습니다. 당시 들었을 때에는, 그저 목표 달성을 위한 좋은 방법론이라 생각했습니다. 하지만 바빠서 자세히 알아보지 못했습니다.&lt;/p&gt;

&lt;p&gt;오늘 우연히 서점에서 이 OKR 책을 발견하고선, 집어들은 자리에서 한숨에 절반을 읽었습니다. 그동안 목표 달성에 대한 갈증이 컸던 모양입니다. 내 인생의 목표 달성에 대한 갈증, 현재 속한 회사의 목표 달성에 대한 갈증, 혹은 미래에 내가 간절히 달성하고프게 될 목표의 달성 방법에 대한 갈증 ? 오늘 이 책에서 얻은 OKR 은 나의 이런 갈증을 꽤나 해소시켜줄 수 있는 무엇이었습니다.&lt;/p&gt;

&lt;p&gt;이 책은 해나와 잭이라는 공동 창업자가 자신들의 스타트업에 OKR 를 적용하면서 겪는 일들, 그러면서 OKR 에 대해 더 잘 알게되는 과정을 스토리 형식으로 풀어나갑니다. 이 글에서는 그 스토리에서 알게 된 OKR 탬플릿을 간단히 여기 정리하려고 합니다.&lt;/p&gt;

&lt;h1 id=&quot;okr-전략이-필요한-이유--황금-사과-이야기&quot;&gt;OKR 전략이 필요한 이유 : 황금 사과 이야기&lt;/h1&gt;
&lt;p&gt;책에서 굉장히 인상깊게 읽은 이야기가 있었습니다. 어릴적 한번씩 읽어봤을만한 고대 그리스 로마 신화의 “황금 사과 이야기” 인데, 이 책에서는 OKR 과 같은 목표 달성 전략이 작은 스타트업이나 큰 기업에 왜 필요한지를 설명하기 위해 이 이야기를 소개하고 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 책에 나온 황금사과 이야기입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;아탈란타는 스파르타에서 가장 빨리 달릴 수 있었던 여인으로, 결혼 생각이 없었다. 중세 시대보다 더한 고대 그리스인이었던 아탈란타의 아버지는 딸의 독신 계획을 용납하지 못하고 달리기 시합을 열기로 했다. 이 시합에서 젊은 남성들이 경주를 벌이게 해서 이기는 자에게 딸을 시집보낼 생각이었다. 아탈란타는 자유를 지키기 위해 자신도 경주에 참여하게 해달라고 청했고, 아버지는 딸이 이길 수도 있다는 생각은 하지 못하고 그 청을 받아들였다.&lt;/p&gt;

  &lt;p&gt;경주에서 아탈란타는 놀랍도록 빨랐고 거의 이길 뻔했다. 한 남자, 히포메네스가 황금 사과 세 개를 그녀가 앞지르기 시작할 때마다 하나씩 굴리지만 않았다면 말이다. 아탈란타는 신기한 황금 사과들을 줍느라 중간에 멈춰 서야 했고, 결국 히포메네스가 간발의 차이로 그녀를 이겼다. 아탈란타가 애초에 자신이 세웠던 목표에만 매달렸더라면 아무 데도 매이지 않고 자유로운 삶을 살아갔을 것이다!&lt;/p&gt;

  &lt;p&gt;모든 벤처기업은 아탈란타처럼 그들의 여정에서 온갖 황금 사과들을 만날 것이다. 어떤 중요한 회의에서 주목받을 기회일 수도 있고, 어쩌면 자신을 위해 당신 회사의 소프트웨어를 바꿔달라고 청하는 거물 고객 한 명일 수도 있다. 아니면 당신의 주의를 흐트러뜨리는 독이 든 사과 같은 나쁜 직원일 수도 있다. 벤처기업의 적은 시간이다. 시기적절하게 실행하는 것을 막는 적은 집중을 방해한다.&lt;/p&gt;

  &lt;p&gt;회사는 훌륭한 목표를 세우고 매주 그 목표들을 달성하는 데 전념해야 하며, 그렇게 달성한 목표들을 축하하면서 나아가야지만 비로소 성장할 수 있다. 그 길에 어떤 반짝이는 사과들이 굴러오든 상관하지 말아야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스타트업을 다니면 이런 상황이 종종 발생합니다. 심지어 이 책의 주인공인 잭과 해나도 수많은 황금 사과들을 마주치죠. 현재 회사의 방향성에는 조금 어긋나는 것 같은 찜찜한 느낌이 들지만, 취하면 엄청난 돈이 될 것 같은 기회들.&lt;/p&gt;

&lt;p&gt;OKR 은 스타트업들이 이런 황금사과에 휘둘리지 않고 목표에 전념할 수 있도록 돕습니다. 유저들을 만족시키기 위한 플랫폼을 만들기로 했고, 신규 사용자 획득과 리텐션율을 Key Results 로 잡았다면, 자신들을 위해 만들고 있던 플랫폼을 개조해달라는 거물 고객을 만나도 확실한 판단을 할 수 있겠죠.&lt;/p&gt;

&lt;p&gt;Objective 와 key Results 를 달성하는데 필요하다면 하는 것이고, 필요하지 않다면 빛나는 황금사과라도 지나칠 용기가 필요합니다.&lt;/p&gt;

&lt;p&gt;함께 설정한 OKR 을 달성하는 것이 팀에 가장 건강하고 달콤한 사과이기 때문이죠.&lt;/p&gt;

&lt;h1 id=&quot;실천하기--okr-템플릿&quot;&gt;실천하기 : OKR 템플릿&lt;/h1&gt;

&lt;p&gt;OKR 탬플릿은 4개의 영역으로 나뉩니다. Objective 와 Key Results 를 설정하는 부분인 &lt;strong&gt;목표&lt;/strong&gt;, 목표를 달성하면서도 항상 점검해야할 항목들인 &lt;strong&gt;건전성&lt;/strong&gt;, 목표를 달성하기 위해 &lt;strong&gt;이번주 해야할 일&lt;/strong&gt;, 그리고 OKR 을 달성하면서 항상 인지하고 있어야 할 &lt;strong&gt;4주 내 향후 중요 이벤트&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/okr1.png&quot; alt=&quot;okr1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 그림에서 초록색 글씨는 한 분기에 한번 정하는 것이고, 붉은색 글씨는 매주 한번씩 수정하는 것입니다.&lt;/p&gt;

&lt;h1 id=&quot;목표&quot;&gt;목표&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/objective.png&quot; alt=&quot;objective&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;objective--key-results&quot;&gt;Objective &amp;amp; Key Results&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;목표&lt;/strong&gt; 칸에는 Objective &amp;amp; Key Results 를 적습니다. Objective 는 조금 추상적일수도 있는 이번 분기에 달성하고픈 목표이고, Key Results 는 그 목표의 달성 여부를 확인할 수 있는 수치들입니다. Key Results 를 모두 달성했다면 Objective 를 달성했다고 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;자신감-지표&quot;&gt;자신감 지표&lt;/h2&gt;
&lt;p&gt;Key Results 아래에는 매주 이 목표에 대한 달성 자신감을 0~10 사이의 정수로 나타냅니다. 처음 Key Results를 설정할 때에는, 지금 설정한 이 목표가 달성할 수 있을지, 못할지에 대한 확신이 5:5 여야 합니다. 너무 달성하기 쉬운 목표를 잡으면 의미가 없기 때문이죠. 따라서 분기 시작에 최초의 자신감은 5/10 으로 모두 적습니다. 한주 한주를 거듭하면서 자신감 지표는 업데이트 될 것이고, 목표를 향해 나아가는 팀원들에게 현재 팀 혹은 자신들의 상태를 알 수 있게 해주는 중요한 지표가 될 것입니다.&lt;/p&gt;

&lt;h1 id=&quot;건전성&quot;&gt;건전성&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/health.png&quot; alt=&quot;health&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;건전성&lt;/strong&gt;에는 OKR 달성을 위해 달려나가면서도, 중간 중간 점검해야 할 상태들입니다. 수치화해서 관리를 한다기보단, 매주 건전성 체크 목록에 있는 항목 중, 이번주에 점검해보면 좋겠다라고 꼽힌 2~3가지 정도를 팀이 함께 이야기하면서 현재 건전하게 지켜지고 있는지, 안되고 있다면 어떤 노력을 더 해야할지 정성적으로 이야기합니다.&lt;/p&gt;

&lt;p&gt;이번 분기의 목표를 “고급스런 브랜드 인식 심어주기” 라고 잡았고, 목표를 향해 온 팀이 전념하다보면 자칫하면 코드의 건전성, 수익 구조 와 같은 팀의 건강함을 뒷받침하는 중요한 요소들을 놓칠 수 있습니다. 이런 항목들을 &lt;strong&gt;건전성&lt;/strong&gt; 칸에 배치해두고 매주 점검하는 것은 매우 중요한 일입니다.&lt;/p&gt;

&lt;h1 id=&quot;이번주-해야할-일&quot;&gt;이번주 해야할 일&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/week.png&quot; alt=&quot;week&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이번주 해야할 일&lt;/strong&gt; 칸에는 이번 분기 목표를 달성하기 위해 이번주 해야할 아주 중요한 일들 3가지 만을 적습니다. 중요한 것은, 정보 공유의 목적이 아닌, 반드시 해내야 하는 일들에 대한 경각심을 주기 위한 리스트라는 것입니다. 자신이 무슨 일을 이번주에 집중하고 있는지 다른사람들에게 공유하기 위한 Todo 리스트가 아니기 때문에, 팀이 아무리 많은 일을 이번주에 진행하고 있다고 하더라도 반드시 해야 하는 중요한 3가지 일만 적습니다.&lt;/p&gt;

&lt;h1 id=&quot;4주-내-향후-중요-이벤트-알림&quot;&gt;4주 내 향후 중요 이벤트 알림&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/event.png&quot; alt=&quot;event&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4주 내 향후 중요 이벤트 알림&lt;/strong&gt; 칸은 정보 공유의 목적이 강합니다. 향후 4주 내로 큼지막하고 중요한 이벤트들을 매주 적어놓으면, 다른 부서의 누군가가 갑자기 특수한 요청을 해왔을 때 덜 당황할 수 있고, 다른 부서의 사람들이 요즘 무엇때문에 정신이 없고 매주 외근을 하는지 아는데에 도움이 됩니다.&lt;/p&gt;</content><author><name></name></author><category term="okr" /><category term="google" /><category term="book" /><category term="startup" /><summary type="html">최근 이직 온 회사에서 OKR 을 하고 있다는 것을 알기 전부터 OKR 에 관심이 많았습니다. 이전에 일하던 회사는 10명 남짓한 굉장히 작은 스타트업이었는데, 원하는 목표를 어떻게 하면 달성할 수 있을지 고민하던 찰나에 지인으로부터 OKR 에 대해 듣게 되었습니다. 당시 들었을 때에는, 그저 목표 달성을 위한 좋은 방법론이라 생각했습니다. 하지만 바빠서 자세히 알아보지 못했습니다.</summary></entry><entry><title type="html">How Great Leaders Inspire Actions?</title><link href="http://localhost:4000/post/37" rel="alternate" type="text/html" title="How Great Leaders Inspire Actions?" /><published>2018-12-26T14:10:50+09:00</published><updated>2018-12-26T14:10:50+09:00</updated><id>http://localhost:4000/post/37</id><content type="html" xml:base="http://localhost:4000/post/37">&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.ted.com/talks/simon_sinek_how_great_leaders_inspire_action&quot;&gt;글 제목과 동명의 TED 영상을 시청 한 뒤, 내용을 정리한 글입니다.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apple 과 같은 기업은 같은 전문가, 같은 컨설턴트, 같은 기술, 같은 자원을 사용하는데 다른 IT 기업들과 무엇이 다르길래 사람들의 마음을 사로잡을까?&lt;/p&gt;

&lt;p&gt;마틴 루터 킹은 당시 고통받는 수많은 흑인들과 무엇이 달랐기에 리더가 되고 많은 사람들이 따랐을까?&lt;/p&gt;

&lt;p&gt;비행체 만들기 붐이 일었던 당시에, 라이트 형제는 어떻게 다른 더 많은 자본과 유명세가 있던 다른 경쟁자들과 다르게 비행기를 만드는데에 유일하게 성공하였을까?&lt;/p&gt;

&lt;p&gt;Simon Sinek 은 이들을 가능케 한 Pattern 이 무엇인지 오랜 고민끝에 밝혀냈습니다. 놀랍게도 대부분의 사람들이나 집단은 이 Pattern 과 정확히 정반대로 항상 문제를 접근하고, 오직 사람들에게 Inspire(영감)을 주는 소수의 인물과 집단들만이 이 Pattern 으로 사고합니다.&lt;/p&gt;

&lt;h2 id=&quot;the-golden-circle&quot;&gt;The Golden Circle&lt;/h2&gt;
&lt;p&gt;Simon Sinek 은 이 Pattern 을 &lt;strong&gt;Golden Circle&lt;/strong&gt; 이라고 일컫습니다. 그리고 이것이 &lt;strong&gt;특출난 이들을 특출나게 만드는 바로 그것&lt;/strong&gt; 이라고 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/37/IMG_1334.PNG&quot; alt=&quot;Golden Circle&quot; /&gt;&lt;/p&gt;

&lt;p&gt;대부분의 사람들이나 집단들은 Golden Circle 의 바깥에서 안쪽방향으로 사고합니다. 우리가 무엇을 하고있는지를 (What) 모르는 사람이나 집단은 없기 때문이죠. 어떤 기업은 말합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“우리는 스크린 캡쳐도 가능하고, 당신이 본 방송의 녹화도 자동으로 해주며, Live 생방송을 일시정지했다가 다시 볼 수 있는 엄청난 기능의 TV 를 팝니다. 멋지죠? 어떻게 만들었냐구요? 최고의 기술진들과 최첨단 기술들을 조합하였습니다!”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이를 본 고객들은 말합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;”오 멋진 사실인걸? 그런데 … 와닿지가 않아. (It doesn`t feel right)”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;왜 이런걸까요? 이 기업은 자신들이 무엇을 만드는지, 무엇을 만들고싶은지 정확히 알고있습니다. 어떻게 만들지도 알죠. 하지만 왜 만드는지가 없었습니다. Golden Circle 의 바깥쪽부터 안쪽으로 사고한것이죠. 고객들은 이 제품이 멋진 제품이란것을 부정하진 않지만, 사고싶지 않습니다. 그 이유는 인간의 뇌 또한 Golden Circle 을 닮았고, 인간의 뇌에서 의사결정을 담당하는 부분은 가장 안쪽인 Why 인 부분이기 때문이죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/37/img1234.png&quot; alt=&quot;simon sinek&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사람들은 자신의 뇌의 가장 안쪽인 Why 가 설득되어야 결정을 내립니다. 표면적인 사실들과 지표들은 뇌의 가장  바깥 부분인 What 계층에서 맴돌기만 할 뿐, 아무런 결정에 영향을 끼치지 않습니다.&lt;/p&gt;

&lt;p&gt;영감을 주는 기업이나 인물들은 모두 예외없이 Why-&amp;gt;How-&amp;gt;What 순서로 사고합니다. What 에 도달해 생긴 제품이나 결과물, 부의 축적 등은 이런 사고의 산물로 나온 현상일 뿐이지요. 강력한 Why 로부터 drive 된 무언가는 사람들의 뇌의 Why를 자극해 믿음(Belief), 영감(Inspire) 등을 부여합니다.&lt;/p&gt;

&lt;p&gt;아까 위의 기업이 아래와 같이 사고했다면 어떠하였을까요?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“우리는 세상 모든 사람의 Live 방송 시청 경험을 업그레이드 하고싶은 신념이 있어. 이것을 이루기 위해선 사람들이 Live 방송을 시청하는 디바이스의 개혁이 필요해. 그렇기 때문에 우리는 새로운 기능을 담은 TV 를 만들게 되었어. 한번 사지 않을래?”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;아까보다 보는 소비자, 고객으로 하여금 마음 속의 무언가를 꿈틀이게 하는 힘이 있습니다. 뇌 속의 결정권자 Why 를 자극한 것이죠.&lt;/p&gt;

&lt;p&gt;이와 같은 접근의 차이는 우리 주변에서도 볼 수 있습니다. Apple 아이폰과 삼성 옴니아를 예로 들겠습니다. Apple 은 “We beleive in thinking differently” 라고 말합니다. 이것이 가지는 힘에 대해 강한 신념을 가지고 있습니다. 이러한 Why 로부터 나온 현상들이 iPhone 이기도 하고 iPod 이기도 한 것입니다. 반면 삼성은 어떤 스펙의 스마트폰을 만들지 고민부터 하였을 것입니다. What 부터 사고한 것이죠.  이 차이가 고객들의 구매 의사를 결정지었습니다.&lt;/p&gt;

&lt;p&gt;비단 기업의 이야기만이 아닙니다. 마틴 루터 킹이 당시 유일하게 흑인 인권 운동을 외친 사람이었을까요? 마틴 루터 킹이 한 모든 행동이나 운동이 완전 무결하게 옳은 결정이었을까요? 그렇지 않습니다. 마틴 루터 킹의 가장 유명한 연설에서도 알 수 있듯이, 그는 왜 자신이 이것을 하는지에 대한 신념(Why) 를 강조합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I believe …&lt;/p&gt;

  &lt;p&gt;I believe …&lt;/p&gt;

  &lt;p&gt;I believe …&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이는 수많은 사람들에게 함께하고 싶은 신념, 믿음, 영감을 제시한 것이고, 이에 공감하는 사람들이 함께한 것입니다.&lt;/p&gt;

&lt;p&gt;정치인에 이 Golden Circle 을 대입시켜볼 수도 있겠습니다. 왜 언론에 나오는 수많은 정치인들이 내세우는 공약들이, 분명 멋진 공약들인데 와닿지 않을까요? 정치인들은 왜 시민들의 마음을 사로잡는데에 애를 먹는 것일까요? 아마도 Golden Circle 의 바깥쪽부터 안쪽으로 사고하였기 때문일 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/37/img123.png&quot; alt=&quot;simon sinek 2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;those-who-lead-inspire-us&quot;&gt;Those who lead inspire us&lt;/h2&gt;

&lt;p&gt;Simon Sinek 은, 결국 무언가 Lead 하는 사람, 즉 리더들은 사람들을 inspire 시킨다고 말합니다. 그 사람들에게 공감할 수 있는 Why 를 제시한다는 것이죠. 그 Why 에 공감한다면, 고객이나 직원이나 동료나 시민들이나 리더가 무엇을 하는지(What) 에 크게 동요되지 않을 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;궁금증&quot;&gt;궁금증&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SpaceX 를 추진하는 앨런 머스크는 Why-&amp;gt;What 으로 사고한 것일까?&lt;/li&gt;
  &lt;li&gt;Why-&amp;gt;What 으로 사고하는 Apple 이 겪고 있는 현재 위기는 어떻게 설명되어야 하는 것일까?&lt;/li&gt;
  &lt;li&gt;Golden Circle 의 안쪽에서 바깥쪽으로 사고하는 정치인이 우리나라에 있긴 했을까? 있다면 누구였을까?&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">글 제목과 동명의 TED 영상을 시청 한 뒤, 내용을 정리한 글입니다.</summary></entry><entry><title type="html">[Banksalad Con Salad 세미나] Sesson1 : DevOps</title><link href="http://localhost:4000/post/34" rel="alternate" type="text/html" title="[Banksalad Con Salad 세미나] Sesson1 : DevOps" /><published>2018-10-24T19:01:50+09:00</published><updated>2018-10-24T19:01:50+09:00</updated><id>http://localhost:4000/post/34</id><content type="html" xml:base="http://localhost:4000/post/34">&lt;p&gt;Con Salad 세미나를 들으러 논현역에 있는 Rainist 본사를 놀러갔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/34/2.JPG&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫번째 세션인 DevOps 세션이 개인적으로 가장 관심있는 분야여서 흥미롭게 들었다.&lt;/p&gt;

&lt;p&gt;나중에 들은 내용을 잊어버리지 않기 위해 세션을 들으면서 내용을 간단하고 빠르게 정리해보았다.&lt;/p&gt;

&lt;h1 id=&quot;1-devops-에-관심가지게-된-계기&quot;&gt;1. DevOps 에 관심가지게 된 계기&lt;/h1&gt;
&lt;p&gt;새벽에 zip파일로 파일을 전달받은 다음에, 수동으로 서버에 파일을 업로드하고 서버를 껏다 키는 작업을 하는 동료를 봄&lt;/p&gt;

&lt;p&gt;이것에 충격을 받고, 무중단 배포, CI/CD 등을 연구하다, Docker, Kubernetes 등을 공부하고 적용하게 됨&lt;/p&gt;

&lt;h2 id=&quot;왜-devops-를-하고있는가&quot;&gt;왜 DevOps 를 하고있는가&lt;/h2&gt;
&lt;p&gt;이런 성향을 가지고 있기 때문&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스 개선&lt;/li&gt;
  &lt;li&gt;생산성 향상&lt;/li&gt;
  &lt;li&gt;호기심&lt;/li&gt;
  &lt;li&gt;문제와 씨름&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관심을-가지는-문제들&quot;&gt;관심을 가지는 문제들&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Highly scalable infra&lt;/li&gt;
  &lt;li&gt;Cost effective infra&lt;/li&gt;
  &lt;li&gt;and more …&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;2-실제-rainist-에서-devops-를-뒷받침하는-툴들&quot;&gt;2. 실제 Rainist 에서 devops 를 뒷받침하는 툴들&lt;/h1&gt;

&lt;h2 id=&quot;aws&quot;&gt;AWS&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처 가져가는 중&lt;/p&gt;
&lt;h2 id=&quot;kubernetes&quot;&gt;Kubernetes&lt;/h2&gt;
&lt;p&gt;AWS 위에서 쿠버를 운영하면서, 도커에 서버들을 얹어 MSA 를 효율적으로 manage 하는 중&lt;/p&gt;
&lt;h2 id=&quot;graphana&quot;&gt;Graphana&lt;/h2&gt;
&lt;p&gt;숫자 데이터를 시각화&lt;/p&gt;
&lt;h2 id=&quot;assertible&quot;&gt;Assertible&lt;/h2&gt;
&lt;p&gt;각 퍼블릭 엔드포인트 별로 정상 작동하는지 실시간으로 체크/ 확인&lt;/p&gt;
&lt;h2 id=&quot;kub-ops-view&quot;&gt;Kub-ops-view&lt;/h2&gt;
&lt;p&gt;쿠버 각 노드별 (그리고 그 노드 안의 컨테이너별) 상황을 컬러를 이용하여 실시간으로 한눈에 시각화해주는 툴&lt;/p&gt;
&lt;h2 id=&quot;slack&quot;&gt;Slack&lt;/h2&gt;
&lt;p&gt;위의 모든 툴들의 notification 을 slack 을 통해 받도록 설정&lt;/p&gt;
&lt;h2 id=&quot;helm&quot;&gt;Helm&lt;/h2&gt;
&lt;p&gt;쿠버네티스 패키지 매니저&lt;/p&gt;
&lt;h2 id=&quot;kubeless&quot;&gt;Kubeless&lt;/h2&gt;
&lt;p&gt;쿠버 위에서 서버리스 아키텍처를 쉽게 사용할 수 있게 해주는 툴 (AWS Lamda, Serverless)&lt;/p&gt;
&lt;h2 id=&quot;travis&quot;&gt;Travis&lt;/h2&gt;
&lt;p&gt;빌드 툴&lt;/p&gt;
&lt;h2 id=&quot;직접-개발한-툴&quot;&gt;직접 개발한 툴&lt;/h2&gt;
&lt;h3 id=&quot;deploy-bot-on-slack&quot;&gt;deploy-bot (on slack)&lt;/h3&gt;
&lt;p&gt;배포 자동화 / 반자동화 진행 상황을 slack 에 알려주고, 컨펌이 필요하면 슬랙을 통해 컨펌 후 배포 계속 진행 되도록 돕는 툴&lt;/p&gt;
&lt;h3 id=&quot;galley&quot;&gt;Galley&lt;/h3&gt;
&lt;p&gt;쿠버 노드 안에 환경변수 주입하는 것을 노가다를 줄여주는 툴&lt;/p&gt;</content><author><name></name></author><summary type="html">Con Salad 세미나를 들으러 논현역에 있는 Rainist 본사를 놀러갔다.</summary></entry><entry><title type="html">Jenkins on EC2 AWS</title><link href="http://localhost:4000/post/29" rel="alternate" type="text/html" title="Jenkins on EC2 AWS" /><published>2018-07-13T18:01:50+09:00</published><updated>2018-07-13T18:01:50+09:00</updated><id>http://localhost:4000/post/29</id><content type="html" xml:base="http://localhost:4000/post/29">&lt;h1 id=&quot;01--aws-ec2-instance-띄우기&quot;&gt;01 : AWS EC2 instance 띄우기&lt;/h1&gt;

&lt;p&gt;ubuntu AMI 이용해서 진행하겠다.&lt;/p&gt;

&lt;p&gt;ssh 이용해서 EC2 instance 의 쉘로 진입한다.&lt;/p&gt;

&lt;h1 id=&quot;02--ec2에-jenkins-구동-환경-조성&quot;&gt;02 : EC2에 jenkins 구동 환경 조성&lt;/h1&gt;

&lt;p&gt;jenkins 는 다른 서버용 프로세스들과 마찬가지로 linux 에서 demon(service) 로 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pkg.jenkins.io/debian-stable/&quot;&gt;공식 홈페이지 ubuntu 다운로드 설명&lt;/a&gt; 을 참조한다.&lt;/p&gt;

&lt;h2 id=&quot;add-key-to-use-jenkins-debian-package-repo&quot;&gt;add key to use jenkins` debian package repo&lt;/h2&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;etcaptsourceslist-수정하기&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/apt/sources.list:&lt;/code&gt; 수정하기&lt;/h2&gt;

&lt;p&gt;아래 텍스트를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/apt/sources.list:&lt;/code&gt; 에 추가한다. (&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo vim&lt;/code&gt; 을 사용해야 할 수도)&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deb https://pkg.jenkins.io/debian-stable binary/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;java-7-또는-8-다운로드-java9-미지원&quot;&gt;java 7 또는 8 다운로드 (java9 미지원)&lt;/h2&gt;

&lt;p&gt;jenkins 는 java 9 과 호환되지 않는다.&lt;/p&gt;

&lt;p&gt;java 를 설치해준다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://tecadmin.net/install-oracle-java-8-ubuntu-via-ppa/&quot;&gt;이곳 링크&lt;/a&gt; 에서 ubuntu 에 java 8을 설치하는 법을 자세하게 알려준다.&lt;/p&gt;

&lt;h1 id=&quot;03--apt-get-에서-jenkins-download&quot;&gt;03 : &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt; 에서 jenkins download&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install jenkins  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;04--jenkins-서버-service-demon-가동&quot;&gt;04 : jenkins 서버 service (demon) 가동&lt;/h1&gt;

&lt;p&gt;아래의 명령어로 젠킨스를 실행시킨다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service jenkins start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이후 8080 포트로 웹 브라우저로 접속해 젠킨스 매니져에 진입한다.&lt;/p&gt;

&lt;h1 id=&quot;05--pipeline-만들기&quot;&gt;05 : pipeline 만들기&lt;/h1&gt;

&lt;h2 id=&quot;새-프로젝트-new-pipeline-생성&quot;&gt;새 프로젝트 (new pipeline) 생성&lt;/h2&gt;

&lt;h4 id=&quot;주의&quot;&gt;주의&lt;/h4&gt;
&lt;p&gt;프로젝트 명에 공백이 들어가면 안된다. 나중에 script 로 접근할 때 애먹는다.&lt;/p&gt;

&lt;h4 id=&quot;순서&quot;&gt;순서&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;이름을 정한다.&lt;/li&gt;
  &lt;li&gt;“소스코드 관리 툴”에 GIT 을 선택하고 repository 에 github repo 주소를 적는다.&lt;/li&gt;
  &lt;li&gt;credential 을 새롭게 생성하고, github 아이디 비번을 저장한다.&lt;/li&gt;
  &lt;li&gt;“빌드 유발” 에서 GitHub hook trigger for GITScm polling 를 선택한다.&lt;/li&gt;
  &lt;li&gt;Github 에 푸시가 들어온 이후에 수행할 작업들을 “Build” 탭에 기술한다. (아래 사진 참조)
&lt;img src=&quot;/asset/media/image/post/29/1.png&quot; alt=&quot;img&quot; /&gt;
—
&lt;img src=&quot;/asset/media/image/post/29/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위에서 사용된 script 파일은 아래에 있다.&lt;/p&gt;

&lt;h3 id=&quot;scripts&quot;&gt;scripts&lt;/h3&gt;

&lt;p&gt;github 의 master branch 에 변경사항이 생기면 순차적으로 실행되는 두개의 script 이다.&lt;/p&gt;

&lt;h4 id=&quot;script-1-build-pushsh&quot;&gt;script 1: &lt;code class=&quot;highlighter-rouge&quot;&gt;build-push.sh&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;변경된 소스코드가 jenkins 에 의해 pull 되면 그 코드를 기반으로 docker image 를 새롭게 build 하고 docker hub 에 push 한다.&lt;/p&gt;

&lt;p&gt;docker hub 계정이 있어야한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;


&lt;span class=&quot;nv&quot;&gt;USERNAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;your username&amp;gt;
&lt;span class=&quot;nv&quot;&gt;PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;your password&amp;gt;
&lt;span class=&quot;nv&quot;&gt;IMAGENAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;choose your docker image name&amp;gt;
&lt;span class=&quot;nv&quot;&gt;DIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lib/jenkins/workspace/&amp;lt;pipeline-name&amp;gt;/&amp;lt;Dockerfile name&amp;gt;


sudo docker login -u &lt;span class=&quot;nv&quot;&gt;$USERNAME&lt;/span&gt; -p &lt;span class=&quot;nv&quot;&gt;$PASSWORD&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;---LOGIN SUCCEEDED---&quot;&lt;/span&gt;
sudo docker build -t &lt;span class=&quot;nv&quot;&gt;$USERNAME&lt;/span&gt;/&lt;span class=&quot;nv&quot;&gt;$IMAGENAME&lt;/span&gt; - &amp;lt; &lt;span class=&quot;nv&quot;&gt;$DIR&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;---BUILD SUCCEEDED---&quot;&lt;/span&gt;
sudo docker push &lt;span class=&quot;nv&quot;&gt;$USERNAME&lt;/span&gt;/&lt;span class=&quot;nv&quot;&gt;$IMAGENAME&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;---PUSH SUCCEEDED---&quot;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;tip--jenkins-에서-script-실행시-sudo-명령어-사용-가능하게-설정하는-법&quot;&gt;TIP : jenkins 에서 script 실행시 sudo 명령어 사용 가능하게 설정하는 법&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/hayderimran7/9246dd195f785cf4783d&quot;&gt;이 링크&lt;/a&gt; 에 나와있는대로 조치하면 된다.&lt;/p&gt;

&lt;h4 id=&quot;script-2-deploysh&quot;&gt;script 2: &lt;code class=&quot;highlighter-rouge&quot;&gt;deploy.sh&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;docker hub 의 repository 에 푸시되어있는 새로운 도커 이미지를 원격의 웹서버에 접속해서 pull down 하는 script 이다.&lt;/p&gt;

&lt;p&gt;원격 서버의 key 파일을 jenkins 서버 안에 가지고 있어야한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#/bin/sh&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;EC2_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ubuntu
&lt;span class=&quot;nv&quot;&gt;SERVICE_SERVER_IP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;ip adrress of your service server&amp;gt;
&lt;span class=&quot;nv&quot;&gt;KEY_DIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; /key/jenkins-demo.pem


ssh -i &lt;span class=&quot;nv&quot;&gt;$KEY_DIR&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$EC2_USER&lt;/span&gt;@&lt;span class=&quot;nv&quot;&gt;$SERVICE_SERVER_IP&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&amp;lt;&amp;lt;EOF
	DOCKER_USER=&amp;lt;your username&amp;gt;
	DOCKER_PASSWORD=&amp;lt;your password&amp;gt;
  IMAGENAME=&amp;lt;choose your docker image name&amp;gt;
	CONTAINER=&amp;lt;your container name&amp;gt;

	sudo docker login -u $DOCKER_USER -p $DOCKER_PASSWORD

	sudo docker pull $DOCKER_USER/$IMAGENAME

	sudo docker stop $CONTAINER

	sudo docker run -d --rm  --name $CONTAINER  $DOCKER_USER/$IMAGENAME

EOF
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;06--github-에서-webhook-trigger-유발하게-설정하기&quot;&gt;06 : Github 에서 Webhook Trigger 유발하게 설정하기&lt;/h1&gt;

&lt;p&gt;pipeline 에 연결된 github repository 로 가서 Setting 의 Webhooks 로 들어간다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/29/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 Add Webhook 을 클릭하고&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/29/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;jenkins 서버의 주소 끝에 &lt;code class=&quot;highlighter-rouge&quot;&gt;/github-Webhook/&lt;/code&gt; 을 달아서 트리거 POST request 가 전송될 payload URL 로 지정해준다.&lt;/p&gt;

&lt;p&gt;그 아래에는 어떤 이벤트에서 트리거를 유발할 것인지 설정할 수 있다.&lt;/p&gt;</content><author><name></name></author><category term="CI/CD" /><category term="automation" /><category term="aws" /><category term="jenkins" /><category term="infra" /><category term="ec2" /><summary type="html">01 : AWS EC2 instance 띄우기</summary></entry></feed>