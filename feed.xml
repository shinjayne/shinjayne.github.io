<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="https://shinjayne.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://shinjayne.github.io/" rel="alternate" type="text/html" /><updated>2019-04-19T17:55:04+09:00</updated><id>https://shinjayne.github.io/</id><title type="html">Jayne.who();</title><subtitle>shinjayne`s Developer Blog. 신재인의 개발 블로그. Web / Deep Learning / Android / etc ...</subtitle><entry><title type="html">2018 webRTC 정리</title><link href="https://shinjayne.github.io/post/36" rel="alternate" type="text/html" title="2018 webRTC 정리" /><published>2019-04-19T14:10:50+09:00</published><updated>2019-04-19T14:10:50+09:00</updated><id>https://shinjayne.github.io/post/36</id><content type="html" xml:base="https://shinjayne.github.io/post/36">&lt;blockquote&gt;
  &lt;p&gt;초안 작성은 ‘코딩 실시간 화상 강의실 서비스’ 를 만들던 2018년 12월 18일인데, 한참 뒤인 2019년 4월 19일에 하게 되었네요. 😂 초안을 작성할 땐 webRTC 세계를 담아보겠다는 포부를 가지고 글을 쓰기 시작했는데, 한참 지난 뒤 글을 적으려다보니 다 까먹어서 내용이 처음에 계획했던 것에 비해 많이 단촐해졌습니다. 하하.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;what-is-webrtc&quot;&gt;What is &lt;code class=&quot;highlighter-rouge&quot;&gt;WebRTC&lt;/code&gt;?&lt;/h1&gt;
&lt;p&gt;WebRTC 는 브라우저나 모바일 application 에서 Real Time Communication (RTC) 를 편리하게 할 수 있는 api 를 만들고자 하는 목적으로 시작된 프로젝트입니다. Open Project 이지만 (2018년 12월 기준) Google Chrome Team 의 주도로, Mozilla, Opera 등의 단체의 지원을 받으며 진행되고 있습니다.&lt;/p&gt;

&lt;p&gt;프로젝트의 진행 방식은, WebRTC API 최신 명세 (SPEC) 를 &lt;code class=&quot;highlighter-rouge&quot;&gt;WebRTC M{xx}&lt;/code&gt; 와 같은 이름으로 공개하고, 거의 동시에 Chrome (혹은 Chrome Beta) 에 구현하여 릴리즈하는 것 같습니다. Opera, Safari, Firefox 등의 브라우저들은 이 공개된 명세에 발맞춰 따라옵니다.&lt;/p&gt;

&lt;p&gt;WebRTC 로 할 수 있는 일은 굉장히 많지만, 간단한 p2p 영상/음성 연결, p2p 데이터 교환 등에도 많이 쓰입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://webrtc.org/&quot;&gt;WebRTC 공식 홈페이지 webrtc.org 링크&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;webrtc-의-3가지-api&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WebRTC&lt;/code&gt; 의 3가지 API&lt;/h1&gt;

&lt;p&gt;2018년 말인 현재, 대부분의 브라우저가 &lt;code class=&quot;highlighter-rouge&quot;&gt;webRTC&lt;/code&gt; API 표준을 지원합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MediaStream&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;getUserMedia&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTCDataChannel&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;api-1-mediastream&quot;&gt;API 1. &lt;code class=&quot;highlighter-rouge&quot;&gt;MediaStream&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;사용자의 카메라와 마이크 같은 곳의 데이터 스트림에 접근합니다.&lt;/p&gt;

&lt;h3 id=&quot;api-2-rtcpeerconnection&quot;&gt;API 2. &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;암호화 및 대역폭 관리를 하는 기능을 가지고 있고, 오디오 또는 비디오 연결을 합니다.&lt;/p&gt;

&lt;h3 id=&quot;api-3-rtcdatachannel&quot;&gt;API 3. &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCDataChannel&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;일반적인 데이터 P2P통신&lt;/p&gt;

&lt;h1 id=&quot;webrtc-application-이-수행하는-것&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;webRTC&lt;/code&gt; application 이 수행하는 것&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;Streaming Data (Audio, Video, Text, Data) 를 수집합니다.
    &lt;ul&gt;
      &lt;li&gt;API : &lt;code class=&quot;highlighter-rouge&quot;&gt;MediaStream&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;getUserMedia&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IP주소, Port등의 네트워크 정보를 수집합니다. 그리고 그 정보를 다른 WebRTC Client (=Peer) 와 교환합니다.
    &lt;ul&gt;
      &lt;li&gt;No API offered&lt;/li&gt;
      &lt;li&gt;Need Signaling Server&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;“Error Report”, “Session 초기화”, “Session 종료” 와 같은 신호 통신을 관리해야 합니다.
    &lt;ul&gt;
      &lt;li&gt;No API offered&lt;/li&gt;
      &lt;li&gt;Need Signaling Server&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;해상도와 코덱들 같은 미디어와 클라이언트의 capabilty에 대한 정보를 교환합니다.
    &lt;ul&gt;
      &lt;li&gt;No API offered&lt;/li&gt;
      &lt;li&gt;Need Signaling Server&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스트리밍 오디오, 비디오 또는 데이터를 주고 받아야합니다.
    &lt;ul&gt;
      &lt;li&gt;API : &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCDataChannel&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;크게 나누면 다음과 같은 세단계로 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fetching -&amp;gt; Signaling -&amp;gt; Connection &amp;amp; Communication&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이중 Fetching(1) 과 Connection &amp;amp; Communication(5) 단계는 &lt;code class=&quot;highlighter-rouge&quot;&gt;webRTC&lt;/code&gt; API 를 이용하지만, 가장 번거로운 Signaling 과정(2,3,4) 는 정작 &lt;code class=&quot;highlighter-rouge&quot;&gt;webRTC API&lt;/code&gt; 로 명세되어있지 않습니다. 개발 엔지니어 개인 역량에 따라 구현 형태도 다르고, 정답도 없습니다.&lt;/p&gt;

&lt;h2 id=&quot;signaling-stage&quot;&gt;Signaling Stage&lt;/h2&gt;

&lt;p&gt;Signaling 단계는 서로 다른 두 peer (WebRTC Client) 가 Communication 하기 위한 준비단계로, 3가지 종류의 정보를 교환해야 합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Network 정보를 교환합니다.
    &lt;ul&gt;
      &lt;li&gt;ICE Framework 를 사용해 find candidate =&amp;gt; ip 와 port 를 찾는다&lt;/li&gt;
      &lt;li&gt;내 ip 와 port 정보&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Media Capability 를 교환합니다.
    &lt;ul&gt;
      &lt;li&gt;sdp (Session Description Protocol) 형식을 따르는 blob 인  &lt;code class=&quot;highlighter-rouge&quot;&gt;offer&lt;/code&gt; 와 &lt;code class=&quot;highlighter-rouge&quot;&gt;answer&lt;/code&gt; 를 주고 받으며 교환합니다.&lt;/li&gt;
      &lt;li&gt;내 브라우저와 상대 peer 브라우저가 사용 가능한 코덱들과 해상도들은 무엇일까&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Session Control Messages 교환합니다
    &lt;ul&gt;
      &lt;li&gt;Session (통신연결) 의 초기화,종료&lt;/li&gt;
      &lt;li&gt;Error Report&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-network-정보-ice-candidate-교환하기&quot;&gt;1. Network 정보 (ICE Candidate) 교환하기&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; Object 를 새롭게 생성하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.onicecandidate&lt;/code&gt; 핸들러를 통해 현재 내 client 의 Ice Candidate(Network 정보)  가 확보되면 실행될 callback 을 전달합니다.&lt;/li&gt;
  &lt;li&gt;Ice Candidate (내 네트워크 정보) 가 확보되면, Signaling Channel 을 통해 상대 peer 에게  serialized 된 ice candidate 정보를 전송합니다. (쌍방이 서로에게 합니다.)&lt;/li&gt;
  &lt;li&gt;상대 peer 의 candidate (네트워크 정보) 가 도착하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.addIceCandidate&lt;/code&gt; 를 통해 상대 peer 의 네트워크 정보를 등록합니다. (쌍방이 모두 합니다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2media-capability-교환하기--session-control-message-교환하기&quot;&gt;2.Media Capability 교환하기 + Session Control Message 교환하기&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;A 와 B 가 webRTC 통신을 하려고합니다. 각자 브라우저에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; 객체를 가지고 있고, 서로의 네트워크 정보 (ice candidate) 를 교환 후 각자의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.addIceCandidate&lt;/code&gt; 를 통해 서로의 네트워크 정보를 등록하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;B 가 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.createOffer&lt;/code&gt; 를 호출해 Offer SDP (Session Description Protocol) 을 생성합니다. 여기엔 내 브라우저에서 사용 가능한 코덱이나 해상도에 대한 정보가 들어있습니다.&lt;/li&gt;
  &lt;li&gt;B 가 Offer SDP 를 Signaling Channel 을 통해 전송합니다.&lt;/li&gt;
  &lt;li&gt;A 는 Signaling Channel 에서 Offer SDP 를 받아, &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.setRemoteDescription&lt;/code&gt; 을 수행합니다.&lt;/li&gt;
  &lt;li&gt;A 의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; 객체는 상대 session 에 대한 정보를 알고 있게 되었고, &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.createAnswer&lt;/code&gt; 를 호출하여 Answer SDP 를 생성하여 Signaling Channel 을 통해 B 에게 전달합니다.&lt;/li&gt;
  &lt;li&gt;B 도 마찬가지로 자신의 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.setRemoteDescription&lt;/code&gt; 을 호출해, 전달받은 Answer SDP 를 등록합니다.&lt;/li&gt;
  &lt;li&gt;A, B 각 측에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;setRemoteDescription&lt;/code&gt; 이 성공적으로 수행되었다면, 각 브라우저에서는 서로의 peer 에 대해 인지하고 있는 상태라고 할 수 있고, p2p 연결이 성공적으로 완료되었다고 할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;communication-stage&quot;&gt;Communication Stage&lt;/h2&gt;
&lt;p&gt;보통 webRTC 를 통해서 peer 와 peer 가 주고받는 데이터는 크게 아래의 두가지입니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;video 나 audio 데이터 스트림&lt;/li&gt;
  &lt;li&gt;직렬화된 text 데이터&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;교환의 양상은, 연결이 이루어지기 전에 데아터 stream 이나 채널을 미리 준비하고, 연결이 완료되면 데이터를 받았을 때의 callback 을 통해 받은 데이터를 처리합니다. 조금 더 자세한 내용은 아래와 같습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-video-나-audio-데이터-스트림-의-경우&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1. video 나 audio 데이터 스트림&lt;/code&gt; 의 경우&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;주는 입장&lt;/strong&gt; : 자신의 머신에서  (&lt;code class=&quot;highlighter-rouge&quot;&gt;getUserMedia&lt;/code&gt; 등의 api 를 통해) video/audio 스트림 source 를 취득해 &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection&lt;/code&gt; 을 생성할 당시에 &lt;code class=&quot;highlighter-rouge&quot;&gt;addTrack&lt;/code&gt;(데이터 stream 채널을 연결) 해줍니다. Signaling 을 통해 connection 이 이루어지기 전에 미리 되어야합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;받는 입장&lt;/strong&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.ontrack&lt;/code&gt; 의 callback 을 커스텀하게 설정해서, connection 이 성공적으로 이루어진 후에 상대방의 Track (video/audio stream) 이 감지되면 어떤 동작을 할지 설정할 수 있습니다. 보통 받은 track 의 데이터 스트림을 DOM 의 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;video srcObject={??}/&amp;gt;&lt;/code&gt; element 에 연결해 보여줍니다.&lt;/p&gt;

&lt;h4 id=&quot;2-직렬화된-text-데이터-의-경우&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2. 직렬화된 text 데이터&lt;/code&gt; 의 경우&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;주는 입장&lt;/strong&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.createDataChannel&lt;/code&gt;  을 통해, 특정 이름의 data 전달 채널을 개설할 수 있습니다. 이 또한 Signaling 을 통해 connection 이 이루어지기 전에 미리 되어야합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;받는 입장&lt;/strong&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;RTCPeerConnection.ondatachannel&lt;/code&gt; 의 callback 을 커스텀하게 설정해서, connection 이 성공적으로 이루어진 후에 상대방이 data channel 을 통해 어떤 데이터를 보냈을 때의 동작을 설정할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;참고한-자료들&quot;&gt;참고한 자료들&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Getting Started with webRTC : https://www.html5rocks.com/ko/tutorials/webrtc/basics/&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="webrtc" /><category term="js" /><category term="p2p" /><category term="frontend" /><summary type="html">초안 작성은 ‘코딩 실시간 화상 강의실 서비스’ 를 만들던 2018년 12월 18일인데, 한참 뒤인 2019년 4월 19일에 하게 되었네요. 😂 초안을 작성할 땐 webRTC 세계를 담아보겠다는 포부를 가지고 글을 쓰기 시작했는데, 한참 지난 뒤 글을 적으려다보니 다 까먹어서 내용이 처음에 계획했던 것에 비해 많이 단촐해졌습니다. 하하.</summary></entry><entry><title type="html">구글이 목표를 달성하는 방식, OKR</title><link href="https://shinjayne.github.io/post/38" rel="alternate" type="text/html" title="구글이 목표를 달성하는 방식, OKR" /><published>2019-01-27T21:30:50+09:00</published><updated>2019-01-27T21:30:50+09:00</updated><id>https://shinjayne.github.io/post/38</id><content type="html" xml:base="https://shinjayne.github.io/post/38">&lt;blockquote&gt;
  &lt;p&gt;최근 이직 온 회사에서 OKR 을 하고 있다는 것을 알기 전부터 OKR 에 관심이 많았다. 이전에 일하던 회사는 10명 남짓한 굉장히 작은 스타트업이었는데, 원하는 목표를 어떻게 하면 달성할 수 있을지 고민하던 찰나에 지인으로부터 OKR 에 대해 듣게 되었다. 당시 들었을 때에는, 그저 목표 달성을 위한 좋은 방법론이라 생각했다. 하지만 바빠서 자세히 알아보지 못했다.&lt;/p&gt;

  &lt;p&gt;오늘 우연히 서점에서 이 OKR 책을 발견하고선, 집어들은 자리에서 한숨에 절반을 읽었다. 그동안 목표 달성에 대한 갈증이 컸던 모양이다. 내 인생의 목표 달성에 대한 갈증, 현재 속한 회사의 목표 달성에 대한 갈증, 혹은 미래에 내가 간절히 달성하고프게 될 목표의 달성 방법에 대한 갈증 ? 오늘 이 책에서 얻은 OKR 은 나의 이런 갈증을 꽤나 해소시켜줄 수 있는 무엇이었다. 아니, 사실 완전히 나를 매료시켜버렸다. 당장에라도 다음 분기 내 인생 계획에 오늘 얻은 OKR 탬플릿을 적용시켜 매 주를 보내고싶다.&lt;/p&gt;

  &lt;p&gt;이 책은 해나와 잭이라는 공동 창업자가 자신들의 스타트업에 OKR 를 적용하면서 겪는 일들, 그러면서 OKR 에 대해 더 잘 알게되는 과정을 스토리 형식으로 풀어나간다. 나는 그 스토리에서 알게 된 OKR 탬플릿을 간단히 여기 정리하려고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;okr-전략이-필요한-이유--황금-사과-이야기&quot;&gt;OKR 전략이 필요한 이유 : 황금 사과 이야기&lt;/h1&gt;
&lt;p&gt;책에서 굉장히 인상깊게 읽은 이야기가 있었습니다. 어릴적 한번씩 읽어봤을만한 고대 그리스 로마 신화의 “황금 사과 이야기” 인데, 이 책에서는 OKR 과 같은 목표 달성 전략이 작은 스타트업이나 큰 기업에 왜 필요한지를 설명하기 위해 이 이야기를 소개하고 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 책에 나온 황금사과 이야기입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;아탈란타는 스파르타에서 가장 빨리 달릴 수 있었던 여인으로, 결혼 생각이 없었다. 중세 시대보다 더한 고대 그리스인이었던 아탈란타의 아버지는 딸의 독신 계획을 용납하지 못하고 달리기 시합을 열기로 했다. 이 시합에서 젊은 남성들이 경주를 벌이게 해서 이기는 자에게 딸을 시집보낼 생각이었다. 아탈란타는 자유를 지키기 위해 자신도 경주에 참여하게 해달라고 청했고, 아버지는 딸이 이길 수도 있다는 생각은 하지 못하고 그 청을 받아들였다.&lt;/p&gt;

  &lt;p&gt;경주에서 아탈란타는 놀랍도록 빨랐고 거의 이길 뻔했다. 한 남자, 히포메네스가 황금 사과 세 개를 그녀가 앞지르기 시작할 때마다 하나씩 굴리지만 않았다면 말이다. 아탈란타는 신기한 황금 사과들을 줍느라 중간에 멈춰 서야 했고, 결국 히포메네스가 간발의 차이로 그녀를 이겼다. 아탈란타가 애초에 자신이 세웠던 목표에만 매달렸더라면 아무 데도 매이지 않고 자유로운 삶을 살아갔을 것이다!&lt;/p&gt;

  &lt;p&gt;모든 벤처기업은 아탈란타처럼 그들의 여정에서 온갖 황금 사과들을 만날 것이다. 어떤 중요한 회의에서 주목받을 기회일 수도 있고, 어쩌면 자신을 위해 당신 회사의 소프트웨어를 바꿔달라고 청하는 거물 고객 한 명일 수도 있다. 아니면 당신의 주의를 흐트러뜨리는 독이 든 사과 같은 나쁜 직원일 수도 있다. 벤처기업의 적은 시간이다. 시기적절하게 실행하는 것을 막는 적은 집중을 방해한다.&lt;/p&gt;

  &lt;p&gt;회사는 훌륭한 목표를 세우고 매주 그 목표들을 달성하는 데 전념해야 하며, 그렇게 달성한 목표들을 축하하면서 나아가야지만 비로소 성장할 수 있다. 그 길에 어떤 반짝이는 사과들이 굴러오든 상관하지 말아야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스타트업을 다니면 이런 상황이 종종 발생합니다. 심지어 이 책의 주인공인 잭과 해나도 수많은 황금 사과들을 마주치죠. 현재 회사의 방향성에는 조금 어긋나는 것 같은 찜찜한 느낌이 들지만, 취하면 엄청난 돈이 될 것 같은 기회들.&lt;/p&gt;

&lt;p&gt;OKR 은 스타트업들이 이런 황금사과에 휘둘리지 않고 목표에 전념할 수 있도록 돕습니다. 유저들을 만족시키기 위한 플랫폼을 만들기로 했고, 신규 사용자 획득과 리텐션율을 Key Results 로 잡았다면, 자신들을 위해 만들고 있던 플랫폼을 개조해달라는 거물 고객을 만나도 확실한 판단을 할 수 있겠죠.&lt;/p&gt;

&lt;p&gt;Objective 와 key Results 를 달성하는데 필요하다면 하는 것이고, 필요하지 않다면 빛나는 황금사과라도 지나칠 용기가 필요합니다.&lt;/p&gt;

&lt;p&gt;함께 설정한 OKR 을 달성하는 것이 팀에 가장 건강하고 달콤한 사과이기 때문이죠.&lt;/p&gt;

&lt;h1 id=&quot;실천하기--okr-템플릿&quot;&gt;실천하기 : OKR 템플릿&lt;/h1&gt;

&lt;p&gt;OKR 탬플릿은 4개의 영역으로 나뉩니다. Objective 와 Key Results 를 설정하는 부분인 &lt;strong&gt;목표&lt;/strong&gt;, 목표를 달성하면서도 항상 점검해야할 항목들인 &lt;strong&gt;건전성&lt;/strong&gt;, 목표를 달성하기 위해 &lt;strong&gt;이번주 해야할 일&lt;/strong&gt;, 그리고 OKR 을 달성하면서 항상 인지하고 있어야 할 &lt;strong&gt;4주 내 향후 중요 이벤트&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/okr1.png&quot; alt=&quot;okr1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 그림에서 초록색 글씨는 한 분기에 한번 정하는 것이고, 붉은색 글씨는 매주 한번씩 수정하는 것입니다.&lt;/p&gt;

&lt;h1 id=&quot;목표&quot;&gt;목표&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/objective.png&quot; alt=&quot;objective&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;objective--key-results&quot;&gt;Objective &amp;amp; Key Results&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;목표&lt;/strong&gt; 칸에는 Objective &amp;amp; Key Results 를 적습니다. Objective 는 조금 추상적일수도 있는 이번 분기에 달성하고픈 목표이고, Key Results 는 그 목표의 달성 여부를 확인할 수 있는 수치들입니다. Key Results 를 모두 달성했다면 Objective 를 달성했다고 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;자신감-지표&quot;&gt;자신감 지표&lt;/h2&gt;
&lt;p&gt;Key Results 아래에는 매주 이 목표에 대한 달성 자신감을 0~10 사이의 정수로 나타냅니다. 처음 Key Results를 설정할 때에는, 지금 설정한 이 목표가 달성할 수 있을지, 못할지에 대한 확신이 5:5 여야 합니다. 너무 달성하기 쉬운 목표를 잡으면 의미가 없기 때문이죠. 따라서 분기 시작에 최초의 자신감은 5/10 으로 모두 적습니다. 한주 한주를 거듭하면서 자신감 지표는 업데이트 될 것이고, 목표를 향해 나아가는 팀원들에게 현재 팀 혹은 자신들의 상태를 알 수 있게 해주는 중요한 지표가 될 것입니다.&lt;/p&gt;

&lt;h1 id=&quot;건전성&quot;&gt;건전성&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/health.png&quot; alt=&quot;health&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;건전성&lt;/strong&gt;에는 OKR 달성을 위해 달려나가면서도, 중간 중간 점검해야 할 상태들입니다. 수치화해서 관리를 한다기보단, 매주 건전성 체크 목록에 있는 항목 중, 이번주에 점검해보면 좋겠다라고 꼽힌 2~3가지 정도를 팀이 함께 이야기하면서 현재 건전하게 지켜지고 있는지, 안되고 있다면 어떤 노력을 더 해야할지 정성적으로 이야기합니다.&lt;/p&gt;

&lt;p&gt;이번 분기의 목표를 “고급스런 브랜드 인식 심어주기” 라고 잡았고, 목표를 향해 온 팀이 전념하다보면 자칫하면 코드의 건전성, 수익 구조 와 같은 팀의 건강함을 뒷받침하는 중요한 요소들을 놓칠 수 있습니다. 이런 항목들을 &lt;strong&gt;건전성&lt;/strong&gt; 칸에 배치해두고 매주 점검하는 것은 매우 중요한 일입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/bi-health-check.svg&quot; alt=&quot;bi-health-check&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;이번주-해야할-일&quot;&gt;이번주 해야할 일&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/week.png&quot; alt=&quot;week&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이번주 해야할 일&lt;/strong&gt; 칸에는 이번 분기 목표를 달성하기 위해 이번주 해야할 아주 중요한 일들 3가지 만을 적습니다. 중요한 것은, 정보 공유의 목적이 아닌, 반드시 해내야 하는 일들에 대한 경각심을 주기 위한 리스트라는 것입니다. 자신이 무슨 일을 이번주에 집중하고 있는지 다른사람들에게 공유하기 위한 Todo 리스트가 아니기 때문에, 팀이 아무리 많은 일을 이번주에 진행하고 있다고 하더라도 반드시 해야 하는 중요한 3가지 일만 적습니다.&lt;/p&gt;

&lt;h1 id=&quot;4주-내-향후-중요-이벤트-알림&quot;&gt;4주 내 향후 중요 이벤트 알림&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/38/event.png&quot; alt=&quot;event&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4주 내 향후 중요 이벤트 알림&lt;/strong&gt; 칸은 정보 공유의 목적이 강합니다. 향후 4주 내로 큼지막하고 중요한 이벤트들을 매주 적어놓으면, 다른 부서의 누군가가 갑자기 특수한 요청을 해왔을 때 덜 당황할 수 있고, 다른 부서의 사람들이 요즘 무엇때문에 정신이 없고 매주 외근을 하는지 아는데에 도움이 됩니다.&lt;/p&gt;</content><author><name></name></author><category term="okr" /><category term="google" /><category term="book" /><category term="startup" /><summary type="html">최근 이직 온 회사에서 OKR 을 하고 있다는 것을 알기 전부터 OKR 에 관심이 많았다. 이전에 일하던 회사는 10명 남짓한 굉장히 작은 스타트업이었는데, 원하는 목표를 어떻게 하면 달성할 수 있을지 고민하던 찰나에 지인으로부터 OKR 에 대해 듣게 되었다. 당시 들었을 때에는, 그저 목표 달성을 위한 좋은 방법론이라 생각했다. 하지만 바빠서 자세히 알아보지 못했다. 오늘 우연히 서점에서 이 OKR 책을 발견하고선, 집어들은 자리에서 한숨에 절반을 읽었다. 그동안 목표 달성에 대한 갈증이 컸던 모양이다. 내 인생의 목표 달성에 대한 갈증, 현재 속한 회사의 목표 달성에 대한 갈증, 혹은 미래에 내가 간절히 달성하고프게 될 목표의 달성 방법에 대한 갈증 ? 오늘 이 책에서 얻은 OKR 은 나의 이런 갈증을 꽤나 해소시켜줄 수 있는 무엇이었다. 아니, 사실 완전히 나를 매료시켜버렸다. 당장에라도 다음 분기 내 인생 계획에 오늘 얻은 OKR 탬플릿을 적용시켜 매 주를 보내고싶다. 이 책은 해나와 잭이라는 공동 창업자가 자신들의 스타트업에 OKR 를 적용하면서 겪는 일들, 그러면서 OKR 에 대해 더 잘 알게되는 과정을 스토리 형식으로 풀어나간다. 나는 그 스토리에서 알게 된 OKR 탬플릿을 간단히 여기 정리하려고 한다.</summary></entry><entry><title type="html">How Great Leaders Inspire Actions?</title><link href="https://shinjayne.github.io/post/37" rel="alternate" type="text/html" title="How Great Leaders Inspire Actions?" /><published>2018-12-26T14:10:50+09:00</published><updated>2018-12-26T14:10:50+09:00</updated><id>https://shinjayne.github.io/post/37</id><content type="html" xml:base="https://shinjayne.github.io/post/37">&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.ted.com/talks/simon_sinek_how_great_leaders_inspire_action&quot;&gt;글 제목과 동명의 TED 영상을 시청 한 뒤, 내용을 정리한 글입니다.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apple 과 같은 기업은 같은 전문가, 같은 컨설턴트, 같은 기술, 같은 자원을 사용하는데 다른 IT 기업들과 무엇이 다르길래 사람들의 마음을 사로잡을까?&lt;/p&gt;

&lt;p&gt;마틴 루터 킹은 당시 고통받는 수많은 흑인들과 무엇이 달랐기에 리더가 되고 많은 사람들이 따랐을까?&lt;/p&gt;

&lt;p&gt;비행체 만들기 붐이 일었던 당시에, 라이트 형제는 어떻게 다른 더 많은 자본과 유명세가 있던 다른 경쟁자들과 다르게 비행기를 만드는데에 유일하게 성공하였을까?&lt;/p&gt;

&lt;p&gt;Simon Sinek 은 이들을 가능케 한 Pattern 이 무엇인지 오랜 고민끝에 밝혀냈습니다. 놀랍게도 대부분의 사람들이나 집단은 이 Pattern 과 정확히 정반대로 항상 문제를 접근하고, 오직 사람들에게 Inspire(영감)을 주는 소수의 인물과 집단들만이 이 Pattern 으로 사고합니다.&lt;/p&gt;

&lt;h2 id=&quot;the-golden-circle&quot;&gt;The Golden Circle&lt;/h2&gt;
&lt;p&gt;Simon Sinek 은 이 Pattern 을 &lt;strong&gt;Golden Circle&lt;/strong&gt; 이라고 일컫습니다. 그리고 이것이 &lt;strong&gt;특출난 이들을 특출나게 만드는 바로 그것&lt;/strong&gt; 이라고 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/37/IMG_1334.PNG&quot; alt=&quot;Golden Circle&quot; /&gt;&lt;/p&gt;

&lt;p&gt;대부분의 사람들이나 집단들은 Golden Circle 의 바깥에서 안쪽방향으로 사고합니다. 우리가 무엇을 하고있는지를 (What) 모르는 사람이나 집단은 없기 때문이죠. 어떤 기업은 말합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“우리는 스크린 캡쳐도 가능하고, 당신이 본 방송의 녹화도 자동으로 해주며, Live 생방송을 일시정지했다가 다시 볼 수 있는 엄청난 기능의 TV 를 팝니다. 멋지죠? 어떻게 만들었냐구요? 최고의 기술진들과 최첨단 기술들을 조합하였습니다!”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이를 본 고객들은 말합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;”오 멋진 사실인걸? 그런데 … 와닿지가 않아. (It doesn`t feel right)”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;왜 이런걸까요? 이 기업은 자신들이 무엇을 만드는지, 무엇을 만들고싶은지 정확히 알고있습니다. 어떻게 만들지도 알죠. 하지만 왜 만드는지가 없었습니다. Golden Circle 의 바깥쪽부터 안쪽으로 사고한것이죠. 고객들은 이 제품이 멋진 제품이란것을 부정하진 않지만, 사고싶지 않습니다. 그 이유는 인간의 뇌 또한 Golden Circle 을 닮았고, 인간의 뇌에서 의사결정을 담당하는 부분은 가장 안쪽인 Why 인 부분이기 때문이죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/37/img1234.png&quot; alt=&quot;simon sinek&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사람들은 자신의 뇌의 가장 안쪽인 Why 가 설득되어야 결정을 내립니다. 표면적인 사실들과 지표들은 뇌의 가장  바깥 부분인 What 계층에서 맴돌기만 할 뿐, 아무런 결정에 영향을 끼치지 않습니다.&lt;/p&gt;

&lt;p&gt;영감을 주는 기업이나 인물들은 모두 예외없이 Why-&amp;gt;How-&amp;gt;What 순서로 사고합니다. What 에 도달해 생긴 제품이나 결과물, 부의 축적 등은 이런 사고의 산물로 나온 현상일 뿐이지요. 강력한 Why 로부터 drive 된 무언가는 사람들의 뇌의 Why를 자극해 믿음(Belief), 영감(Inspire) 등을 부여합니다.&lt;/p&gt;

&lt;p&gt;아까 위의 기업이 아래와 같이 사고했다면 어떠하였을까요?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“우리는 세상 모든 사람의 Live 방송 시청 경험을 업그레이드 하고싶은 신념이 있어. 이것을 이루기 위해선 사람들이 Live 방송을 시청하는 디바이스의 개혁이 필요해. 그렇기 때문에 우리는 새로운 기능을 담은 TV 를 만들게 되었어. 한번 사지 않을래?”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;아까보다 보는 소비자, 고객으로 하여금 마음 속의 무언가를 꿈틀이게 하는 힘이 있습니다. 뇌 속의 결정권자 Why 를 자극한 것이죠.&lt;/p&gt;

&lt;p&gt;이와 같은 접근의 차이는 우리 주변에서도 볼 수 있습니다. Apple 아이폰과 삼성 옴니아를 예로 들겠습니다. Apple 은 “We beleive in thinking differently” 라고 말합니다. 이것이 가지는 힘에 대해 강한 신념을 가지고 있습니다. 이러한 Why 로부터 나온 현상들이 iPhone 이기도 하고 iPod 이기도 한 것입니다. 반면 삼성은 어떤 스펙의 스마트폰을 만들지 고민부터 하였을 것입니다. What 부터 사고한 것이죠.  이 차이가 고객들의 구매 의사를 결정지었습니다.&lt;/p&gt;

&lt;p&gt;비단 기업의 이야기만이 아닙니다. 마틴 루터 킹이 당시 유일하게 흑인 인권 운동을 외친 사람이었을까요? 마틴 루터 킹이 한 모든 행동이나 운동이 완전 무결하게 옳은 결정이었을까요? 그렇지 않습니다. 마틴 루터 킹의 가장 유명한 연설에서도 알 수 있듯이, 그는 왜 자신이 이것을 하는지에 대한 신념(Why) 를 강조합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I believe …&lt;/p&gt;

  &lt;p&gt;I believe …&lt;/p&gt;

  &lt;p&gt;I believe …&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이는 수많은 사람들에게 함께하고 싶은 신념, 믿음, 영감을 제시한 것이고, 이에 공감하는 사람들이 함께한 것입니다.&lt;/p&gt;

&lt;p&gt;정치인에 이 Golden Circle 을 대입시켜볼 수도 있겠습니다. 왜 언론에 나오는 수많은 정치인들이 내세우는 공약들이, 분명 멋진 공약들인데 와닿지 않을까요? 정치인들은 왜 시민들의 마음을 사로잡는데에 애를 먹는 것일까요? 아마도 Golden Circle 의 바깥쪽부터 안쪽으로 사고하였기 때문일 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/37/img123.png&quot; alt=&quot;simon sinek 2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;those-who-lead-inspire-us&quot;&gt;Those who lead inspire us&lt;/h2&gt;

&lt;p&gt;Simon Sinek 은, 결국 무언가 Lead 하는 사람, 즉 리더들은 사람들을 inspire 시킨다고 말합니다. 그 사람들에게 공감할 수 있는 Why 를 제시한다는 것이죠. 그 Why 에 공감한다면, 고객이나 직원이나 동료나 시민들이나 리더가 무엇을 하는지(What) 에 크게 동요되지 않을 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;궁금증&quot;&gt;궁금증&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SpaceX 를 추진하는 앨런 머스크는 Why-&amp;gt;What 으로 사고한 것일까?&lt;/li&gt;
  &lt;li&gt;Why-&amp;gt;What 으로 사고하는 Apple 이 겪고 있는 현재 위기는 어떻게 설명되어야 하는 것일까?&lt;/li&gt;
  &lt;li&gt;Golden Circle 의 안쪽에서 바깥쪽으로 사고하는 정치인이 우리나라에 있긴 했을까? 있다면 누구였을까?&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">글 제목과 동명의 TED 영상을 시청 한 뒤, 내용을 정리한 글입니다.</summary></entry><entry><title type="html">[Banksalad Con Salad 세미나] Sesson1 : DevOps</title><link href="https://shinjayne.github.io/post/34" rel="alternate" type="text/html" title="[Banksalad Con Salad 세미나] Sesson1 : DevOps" /><published>2018-10-24T19:01:50+09:00</published><updated>2018-10-24T19:01:50+09:00</updated><id>https://shinjayne.github.io/post/34</id><content type="html" xml:base="https://shinjayne.github.io/post/34">&lt;p&gt;Con Salad 세미나를 들으러 논현역에 있는 Rainist 본사를 놀러갔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/34/2.JPG&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫번째 세션인 DevOps 세션이 개인적으로 가장 관심있는 분야여서 흥미롭게 들었다.&lt;/p&gt;

&lt;p&gt;나중에 들은 내용을 잊어버리지 않기 위해 세션을 들으면서 내용을 간단하고 빠르게 정리해보았다.&lt;/p&gt;

&lt;h1 id=&quot;1-devops-에-관심가지게-된-계기&quot;&gt;1. DevOps 에 관심가지게 된 계기&lt;/h1&gt;
&lt;p&gt;새벽에 zip파일로 파일을 전달받은 다음에, 수동으로 서버에 파일을 업로드하고 서버를 껏다 키는 작업을 하는 동료를 봄&lt;/p&gt;

&lt;p&gt;이것에 충격을 받고, 무중단 배포, CI/CD 등을 연구하다, Docker, Kubernetes 등을 공부하고 적용하게 됨&lt;/p&gt;

&lt;h2 id=&quot;왜-devops-를-하고있는가&quot;&gt;왜 DevOps 를 하고있는가&lt;/h2&gt;
&lt;p&gt;이런 성향을 가지고 있기 때문&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스 개선&lt;/li&gt;
  &lt;li&gt;생산성 향상&lt;/li&gt;
  &lt;li&gt;호기심&lt;/li&gt;
  &lt;li&gt;문제와 씨름&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관심을-가지는-문제들&quot;&gt;관심을 가지는 문제들&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Highly scalable infra&lt;/li&gt;
  &lt;li&gt;Cost effective infra&lt;/li&gt;
  &lt;li&gt;and more …&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;2-실제-rainist-에서-devops-를-뒷받침하는-툴들&quot;&gt;2. 실제 Rainist 에서 devops 를 뒷받침하는 툴들&lt;/h1&gt;

&lt;h2 id=&quot;aws&quot;&gt;AWS&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처 가져가는 중&lt;/p&gt;
&lt;h2 id=&quot;kubernetes&quot;&gt;Kubernetes&lt;/h2&gt;
&lt;p&gt;AWS 위에서 쿠버를 운영하면서, 도커에 서버들을 얹어 MSA 를 효율적으로 manage 하는 중&lt;/p&gt;
&lt;h2 id=&quot;graphana&quot;&gt;Graphana&lt;/h2&gt;
&lt;p&gt;숫자 데이터를 시각화&lt;/p&gt;
&lt;h2 id=&quot;assertible&quot;&gt;Assertible&lt;/h2&gt;
&lt;p&gt;각 퍼블릭 엔드포인트 별로 정상 작동하는지 실시간으로 체크/ 확인&lt;/p&gt;
&lt;h2 id=&quot;kub-ops-view&quot;&gt;Kub-ops-view&lt;/h2&gt;
&lt;p&gt;쿠버 각 노드별 (그리고 그 노드 안의 컨테이너별) 상황을 컬러를 이용하여 실시간으로 한눈에 시각화해주는 툴&lt;/p&gt;
&lt;h2 id=&quot;slack&quot;&gt;Slack&lt;/h2&gt;
&lt;p&gt;위의 모든 툴들의 notification 을 slack 을 통해 받도록 설정&lt;/p&gt;
&lt;h2 id=&quot;helm&quot;&gt;Helm&lt;/h2&gt;
&lt;p&gt;쿠버네티스 패키지 매니저&lt;/p&gt;
&lt;h2 id=&quot;kubeless&quot;&gt;Kubeless&lt;/h2&gt;
&lt;p&gt;쿠버 위에서 서버리스 아키텍처를 쉽게 사용할 수 있게 해주는 툴 (AWS Lamda, Serverless)&lt;/p&gt;
&lt;h2 id=&quot;travis&quot;&gt;Travis&lt;/h2&gt;
&lt;p&gt;빌드 툴&lt;/p&gt;
&lt;h2 id=&quot;직접-개발한-툴&quot;&gt;직접 개발한 툴&lt;/h2&gt;
&lt;h3 id=&quot;deploy-bot-on-slack&quot;&gt;deploy-bot (on slack)&lt;/h3&gt;
&lt;p&gt;배포 자동화 / 반자동화 진행 상황을 slack 에 알려주고, 컨펌이 필요하면 슬랙을 통해 컨펌 후 배포 계속 진행 되도록 돕는 툴&lt;/p&gt;
&lt;h3 id=&quot;galley&quot;&gt;Galley&lt;/h3&gt;
&lt;p&gt;쿠버 노드 안에 환경변수 주입하는 것을 노가다를 줄여주는 툴&lt;/p&gt;</content><author><name></name></author><summary type="html">Con Salad 세미나를 들으러 논현역에 있는 Rainist 본사를 놀러갔다.</summary></entry><entry><title type="html">Jenkins on EC2 AWS</title><link href="https://shinjayne.github.io/post/29" rel="alternate" type="text/html" title="Jenkins on EC2 AWS" /><published>2018-07-13T18:01:50+09:00</published><updated>2018-07-13T18:01:50+09:00</updated><id>https://shinjayne.github.io/post/29</id><content type="html" xml:base="https://shinjayne.github.io/post/29">&lt;h1 id=&quot;01--aws-ec2-instance-띄우기&quot;&gt;01 : AWS EC2 instance 띄우기&lt;/h1&gt;

&lt;p&gt;ubuntu AMI 이용해서 진행하겠다.&lt;/p&gt;

&lt;p&gt;ssh 이용해서 EC2 instance 의 쉘로 진입한다.&lt;/p&gt;

&lt;h1 id=&quot;02--ec2에-jenkins-구동-환경-조성&quot;&gt;02 : EC2에 jenkins 구동 환경 조성&lt;/h1&gt;

&lt;p&gt;jenkins 는 다른 서버용 프로세스들과 마찬가지로 linux 에서 demon(service) 로 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pkg.jenkins.io/debian-stable/&quot;&gt;공식 홈페이지 ubuntu 다운로드 설명&lt;/a&gt; 을 참조한다.&lt;/p&gt;

&lt;h2 id=&quot;add-key-to-use-jenkins-debian-package-repo&quot;&gt;add key to use jenkins` debian package repo&lt;/h2&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;etcaptsourceslist-수정하기&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/apt/sources.list:&lt;/code&gt; 수정하기&lt;/h2&gt;

&lt;p&gt;아래 텍스트를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/apt/sources.list:&lt;/code&gt; 에 추가한다. (&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo vim&lt;/code&gt; 을 사용해야 할 수도)&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deb https://pkg.jenkins.io/debian-stable binary/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;java-7-또는-8-다운로드-java9-미지원&quot;&gt;java 7 또는 8 다운로드 (java9 미지원)&lt;/h2&gt;

&lt;p&gt;jenkins 는 java 9 과 호환되지 않는다.&lt;/p&gt;

&lt;p&gt;java 를 설치해준다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://tecadmin.net/install-oracle-java-8-ubuntu-via-ppa/&quot;&gt;이곳 링크&lt;/a&gt; 에서 ubuntu 에 java 8을 설치하는 법을 자세하게 알려준다.&lt;/p&gt;

&lt;h1 id=&quot;03--apt-get-에서-jenkins-download&quot;&gt;03 : &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt; 에서 jenkins download&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install jenkins  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;04--jenkins-서버-service-demon-가동&quot;&gt;04 : jenkins 서버 service (demon) 가동&lt;/h1&gt;

&lt;p&gt;아래의 명령어로 젠킨스를 실행시킨다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service jenkins start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이후 8080 포트로 웹 브라우저로 접속해 젠킨스 매니져에 진입한다.&lt;/p&gt;

&lt;h1 id=&quot;05--pipeline-만들기&quot;&gt;05 : pipeline 만들기&lt;/h1&gt;

&lt;h2 id=&quot;새-프로젝트-new-pipeline-생성&quot;&gt;새 프로젝트 (new pipeline) 생성&lt;/h2&gt;

&lt;h4 id=&quot;주의&quot;&gt;주의&lt;/h4&gt;
&lt;p&gt;프로젝트 명에 공백이 들어가면 안된다. 나중에 script 로 접근할 때 애먹는다.&lt;/p&gt;

&lt;h4 id=&quot;순서&quot;&gt;순서&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;이름을 정한다.&lt;/li&gt;
  &lt;li&gt;“소스코드 관리 툴”에 GIT 을 선택하고 repository 에 github repo 주소를 적는다.&lt;/li&gt;
  &lt;li&gt;credential 을 새롭게 생성하고, github 아이디 비번을 저장한다.&lt;/li&gt;
  &lt;li&gt;“빌드 유발” 에서 GitHub hook trigger for GITScm polling 를 선택한다.&lt;/li&gt;
  &lt;li&gt;Github 에 푸시가 들어온 이후에 수행할 작업들을 “Build” 탭에 기술한다. (아래 사진 참조)
&lt;img src=&quot;/asset/media/image/post/29/1.png&quot; alt=&quot;img&quot; /&gt;
—
&lt;img src=&quot;/asset/media/image/post/29/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위에서 사용된 script 파일은 아래에 있다.&lt;/p&gt;

&lt;h3 id=&quot;scripts&quot;&gt;scripts&lt;/h3&gt;

&lt;p&gt;github 의 master branch 에 변경사항이 생기면 순차적으로 실행되는 두개의 script 이다.&lt;/p&gt;

&lt;h4 id=&quot;script-1-build-pushsh&quot;&gt;script 1: &lt;code class=&quot;highlighter-rouge&quot;&gt;build-push.sh&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;변경된 소스코드가 jenkins 에 의해 pull 되면 그 코드를 기반으로 docker image 를 새롭게 build 하고 docker hub 에 push 한다.&lt;/p&gt;

&lt;p&gt;docker hub 계정이 있어야한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;


&lt;span class=&quot;nv&quot;&gt;USERNAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;your username&amp;gt;
&lt;span class=&quot;nv&quot;&gt;PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;your password&amp;gt;
&lt;span class=&quot;nv&quot;&gt;IMAGENAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;choose your docker image name&amp;gt;
&lt;span class=&quot;nv&quot;&gt;DIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lib/jenkins/workspace/&amp;lt;pipeline-name&amp;gt;/&amp;lt;Dockerfile name&amp;gt;


sudo docker login -u &lt;span class=&quot;nv&quot;&gt;$USERNAME&lt;/span&gt; -p &lt;span class=&quot;nv&quot;&gt;$PASSWORD&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;---LOGIN SUCCEEDED---&quot;&lt;/span&gt;
sudo docker build -t &lt;span class=&quot;nv&quot;&gt;$USERNAME&lt;/span&gt;/&lt;span class=&quot;nv&quot;&gt;$IMAGENAME&lt;/span&gt; - &amp;lt; &lt;span class=&quot;nv&quot;&gt;$DIR&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;---BUILD SUCCEEDED---&quot;&lt;/span&gt;
sudo docker push &lt;span class=&quot;nv&quot;&gt;$USERNAME&lt;/span&gt;/&lt;span class=&quot;nv&quot;&gt;$IMAGENAME&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;---PUSH SUCCEEDED---&quot;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;tip--jenkins-에서-script-실행시-sudo-명령어-사용-가능하게-설정하는-법&quot;&gt;TIP : jenkins 에서 script 실행시 sudo 명령어 사용 가능하게 설정하는 법&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/hayderimran7/9246dd195f785cf4783d&quot;&gt;이 링크&lt;/a&gt; 에 나와있는대로 조치하면 된다.&lt;/p&gt;

&lt;h4 id=&quot;script-2-deploysh&quot;&gt;script 2: &lt;code class=&quot;highlighter-rouge&quot;&gt;deploy.sh&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;docker hub 의 repository 에 푸시되어있는 새로운 도커 이미지를 원격의 웹서버에 접속해서 pull down 하는 script 이다.&lt;/p&gt;

&lt;p&gt;원격 서버의 key 파일을 jenkins 서버 안에 가지고 있어야한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#/bin/sh&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;EC2_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ubuntu
&lt;span class=&quot;nv&quot;&gt;SERVICE_SERVER_IP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;ip adrress of your service server&amp;gt;
&lt;span class=&quot;nv&quot;&gt;KEY_DIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; /key/jenkins-demo.pem


ssh -i &lt;span class=&quot;nv&quot;&gt;$KEY_DIR&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$EC2_USER&lt;/span&gt;@&lt;span class=&quot;nv&quot;&gt;$SERVICE_SERVER_IP&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&amp;lt;&amp;lt;EOF
	DOCKER_USER=&amp;lt;your username&amp;gt;
	DOCKER_PASSWORD=&amp;lt;your password&amp;gt;
  IMAGENAME=&amp;lt;choose your docker image name&amp;gt;
	CONTAINER=&amp;lt;your container name&amp;gt;

	sudo docker login -u $DOCKER_USER -p $DOCKER_PASSWORD

	sudo docker pull $DOCKER_USER/$IMAGENAME

	sudo docker stop $CONTAINER

	sudo docker run -d --rm  --name $CONTAINER  $DOCKER_USER/$IMAGENAME

EOF
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;06--github-에서-webhook-trigger-유발하게-설정하기&quot;&gt;06 : Github 에서 Webhook Trigger 유발하게 설정하기&lt;/h1&gt;

&lt;p&gt;pipeline 에 연결된 github repository 로 가서 Setting 의 Webhooks 로 들어간다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/29/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 Add Webhook 을 클릭하고&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/29/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;jenkins 서버의 주소 끝에 &lt;code class=&quot;highlighter-rouge&quot;&gt;/github-Webhook/&lt;/code&gt; 을 달아서 트리거 POST request 가 전송될 payload URL 로 지정해준다.&lt;/p&gt;

&lt;p&gt;그 아래에는 어떤 이벤트에서 트리거를 유발할 것인지 설정할 수 있다.&lt;/p&gt;</content><author><name></name></author><category term="CI/CD" /><category term="automation" /><category term="aws" /><category term="jenkins" /><category term="infra" /><category term="ec2" /><summary type="html">01 : AWS EC2 instance 띄우기</summary></entry><entry><title type="html">IP 와 Subnet</title><link href="https://shinjayne.github.io/post/28" rel="alternate" type="text/html" title="IP 와 Subnet" /><published>2018-07-13T14:19:50+09:00</published><updated>2018-07-13T14:19:50+09:00</updated><id>https://shinjayne.github.io/post/28</id><content type="html" xml:base="https://shinjayne.github.io/post/28">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.joinc.co.kr/w/Site/Network_Programing/Documents/SubNetWorking&quot;&gt;참고링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ip-번호&quot;&gt;ip 번호&lt;/h2&gt;

&lt;p&gt;ip 번호는 internet network 에 연결된 주체들이 부여받은 유일(unique)한 값이다.&lt;/p&gt;

&lt;h2 id=&quot;network-interface&quot;&gt;network interface&lt;/h2&gt;

&lt;p&gt;ip 주소는 반드시 network interface 에 할당된다. (host 가 직접 ip주소를 할당받는 것이 아니다.)&lt;/p&gt;

&lt;p&gt;ip 주소를 할당받은 것 처럼 보이는 서버는 사실 자신과 연결된 network interface 에 ip 주소를 할당받은 것이다. (AWS 의 EC2 에 Elastic ip 를 고정할당하여도, 사실은 EC2 instance 생성과 동시에 만들어지는 default interface 에 할당되는 것이다.)&lt;/p&gt;

&lt;p&gt;하나의 host 는 여러개의 interface 와 연결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;예약된-ip-번호&quot;&gt;예약된 ip 번호&lt;/h2&gt;

&lt;p&gt;ip 주소는 실제 외부 인터넷 네트워크와 연결에서 쓰이는 public ip주소와, 사설망(private network) 에서 쓰이는 private ip주소가 있다.&lt;/p&gt;

&lt;p&gt;private ip에 사용되는 주소 범위와 public ip에 사용되는 주소 범위가 겹치면 사설망 내부의 주체들은 혼란스럽다.&lt;/p&gt;

&lt;p&gt;따라서 전체 사용가능한 ip 주소중 일부는 각 사설망의 private ip 사용성을 위해 남겨두었다. 그것을 &lt;strong&gt;예약된 ip 주소&lt;/strong&gt; 라고도 한다.&lt;/p&gt;

&lt;p&gt;다음은 실제 세상에서의 예약된 ip 주소 이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;IP 클래스&lt;/th&gt;
      &lt;th&gt;예약된 주소&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;10.0.0.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;172.16.0.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;192.168.0.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;subnet&quot;&gt;subnet&lt;/h2&gt;

&lt;p&gt;subnet 이 필요한 상황은 다음과 같이 관리해야할 ip 주소가 아주 많은 상황이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;보통 기관이나 대형 네트워크 사업자들은 public ip 주소를 달랑 하나가 아니라 일부 대역 전체를 빌려오는데, 수많은 ip 주소들을 그룹화시켜 관리할 필요성이 있다.&lt;/li&gt;
  &lt;li&gt;사설망 내에서 사용할 수 있는 private ip 주소가 엄청난데, 그 수많은 ip 주소들을 그룹화시켜 관리할 필요성이 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와같은 이유로 가상의 그룹인 subnet 으로 자신이 관리하는 ip 주소들을 세부 그룹으로 나누어 관리하고 접근한다.&lt;/p&gt;

&lt;p&gt;subnet 을 나누고, 특정 ip 가 어떤 subnet 에 속해있는지 판단하는 규칙이 바로 subnet mask 이다.&lt;/p&gt;

&lt;h2 id=&quot;subnet-mask&quot;&gt;subnet mask&lt;/h2&gt;

&lt;p&gt;subnet mask 는 특정 ip 주소가 어떤 subnet 에 속하는지 판단하는 기준이 된다.&lt;/p&gt;

&lt;h2 id=&quot;cidr-표기법&quot;&gt;CIDR 표기법&lt;/h2&gt;

&lt;p&gt;subnet mask 는 2진수 표기로 판단해야하서 사람 입장에서 가독성이 떨어진다.&lt;/p&gt;

&lt;p&gt;그래서 등장한 것이 CIDR 표기법이다. CIDR 표기법은 subnet mask 의 2진 표기에서 1이 연속으로 등장하는 비트 수 까지의 숫자를 10진표기의 subnet mask 뒤에 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; 와 함께 표기한다.&lt;/p&gt;

&lt;p&gt;CIDR 표기만 보면 쉽게 고유의 subnet mask 를 구별할 수 있다.&lt;/p&gt;

&lt;p&gt;CIDR 표기의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; 뒤 숫자가 클수록 subnet 의 범위가 좁다는 것이고, subnet 안의 host 갯수가 적다는 뜻이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/28/3.png&quot; alt=&quot;img3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/28/2.png&quot; alt=&quot;img2&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="network" /><category term="ip" /><category term="subnet" /><summary type="html">참고링크</summary></entry><entry><title type="html">주식회사 개론</title><link href="https://shinjayne.github.io/post/27" rel="alternate" type="text/html" title="주식회사 개론" /><published>2018-06-24T10:11:50+09:00</published><updated>2018-06-24T10:11:50+09:00</updated><id>https://shinjayne.github.io/post/27</id><content type="html" xml:base="https://shinjayne.github.io/post/27">&lt;p&gt;회사설립의 첫 걸음&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;법인 등기&lt;/li&gt;
  &lt;li&gt;사업자 등록&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1법인-등록&quot;&gt;1.법인 등록&lt;/h3&gt;
&lt;p&gt;사람이 출생신고를 하는것처럼, 회사도 가상의 경제 주체이기 때문에 회사도 일종의 출생신고를 해야하는데 그것이 법인등기이다.&lt;/p&gt;

&lt;p&gt;법인등기을 할 때에 법인의 type(유형) 을 정할 수 있다.&lt;/p&gt;

&lt;p&gt;사업을 하다가 망했을 때, 채무 (직원월급, 회사가 빌린 돈, 거래처가 못받은 돈 등) 을 누가 질 것인지에 대한 책임소재를 중심으로 법인에는 4가지 유형이 있다.&lt;/p&gt;

&lt;h4 id=&quot;합명&quot;&gt;합명&lt;/h4&gt;
&lt;p&gt;법인등록에 명시된 몇명의 사람들(사원)이 채무에 대한 책임을 전적으로 모두 진다.
즉 모두가 무한책임사원.&lt;/p&gt;
&lt;h4 id=&quot;합자&quot;&gt;합자&lt;/h4&gt;
&lt;p&gt;유한과 합명의 중간. 유한책임사원과 무한책임사원이 공존하고, 채무에 대해 유한책임사원은 공시된 범위까지만 책임을 지고 나머지는 무한책임사원이 책임을 진다.&lt;/p&gt;
&lt;h4 id=&quot;유한&quot;&gt;유한&lt;/h4&gt;
&lt;p&gt;법인등록에 명시된 몇명의 사람들(사원)이 미리 공시된 한정된 금액에 대해서만 책임을 진다.
즉 모두가 유한책임사원.
주식의 양도만으로 주주가 변경되는 주식회사와 달리 유한책임사원을 변경하기 위해서는 사원총회의 특별결의가 있어야 한다.&lt;/p&gt;
&lt;h4 id=&quot;주식&quot;&gt;주식&lt;/h4&gt;
&lt;p&gt;자본을 출자한 주주로 구성되는데 각 주주는 자신의 출자가액 범위까지만 책임을 부담한다. 주주의 변경이 매우 용이한 것이 특징.&lt;/p&gt;

&lt;p&gt;합명에서 주식까지 아래로 내려올수록 &lt;strong&gt;현실 구성원들이 지는 책임의 범위는 점점 낮아지고&lt;/strong&gt;, 가상의 경제주체인 법인이 구성원들로부터 독립성을 가지게된다.&lt;/p&gt;

&lt;h5 id=&quot;주식이란&quot;&gt;주식이란&lt;/h5&gt;
&lt;p&gt;두가지 의미&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;회사에 대한 주주의 권리를 의미하는 주주권&lt;/li&gt;
  &lt;li&gt;회사의 자본금을 이루는 개별단위로서 주식 (주권의 액면금 * 주식수 = 자본금)&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;주주란&quot;&gt;주주란&lt;/h5&gt;
&lt;p&gt;주식을 가지고 있는 사람. 주식법인의 구성원.&lt;/p&gt;

&lt;h5 id=&quot;이사회란&quot;&gt;이사회란&lt;/h5&gt;
&lt;p&gt;주식회사는 기본적으로 주주(주식을 보유한 사람)이면 모두 의사 결정권이 있다. 하지만 회사주요결정건마다 모든 주주가 모일 수 없기 때문에, 우리가 국회의원을 뽑듯이, 주주들은 이사회를 선정해 이사들에게 결정권을 위임한다. 그리고 이 이사들은 법인등기 할 때 법인등기부에 적게되어있다.&lt;/p&gt;

&lt;p&gt;이사회의 구성원인 이사가 반드시 주주일 필요는 없고, 주주가 반드시 이사일 필요도 없다. (둘은 독립적)&lt;/p&gt;

&lt;h3 id=&quot;2사업자등록&quot;&gt;2.사업자등록&lt;/h3&gt;
&lt;p&gt;거래를 할 때 &lt;strong&gt;세법을 어기지 않기 위해서 등록&lt;/strong&gt; 해야한다. 개인이건 법인이건 장사를 한다면 등록해야하만 국세청에서 세금을 합법적으로 징수 가능.
(영리행위를 하는 자연인이나 법인에게는 국세청에 사업자등록을 할 의무가 있다. 회사는 그 정의가 ‘영리를 목적으로 하는 법인’이므로 사업자등록을 해야 한다.)&lt;/p&gt;

&lt;p&gt;정리하자면, &lt;strong&gt;법인 등기를 하지 않으면 법적으로 권리의무의 주체가 될 수 없고, 사업자등록을 하지 않으면 세법위반이 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-주식-가격--발행&quot;&gt;3. 주식 가격 &amp;amp; 발행&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.lawtalk.co.kr/posts/10145-스타트업-벤처기업의-자금조달-방법-주식발행-1편&quot;&gt; 참고링크 &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;주식 발행은 크게 2가지 경우이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;설립 시 초기 주식발행&lt;/li&gt;
  &lt;li&gt;중간 자금 조달을 위한 신주발행 (할증발행, 할인발행)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;또, 주식에는 2가지 핵심 가격개념이 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;액면가 : 법인 등기부에 공시된 주식 1주의 기준가격.&lt;/li&gt;
  &lt;li&gt;발행가 (=인수가) : 주식이 실제로 거래되는 가격. 액면가보다 높다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;회사를 설립할 때 액면가를 산정한다. 그리고 최초의 주식발행 때 발행가는 통상 액면가를 따른다. (설립 멤버들끼리만 보유한 주식이므로)&lt;/p&gt;

&lt;p&gt;액면가는 앞으로 &lt;strong&gt;주식수*액면가 = 회사자본금&lt;/strong&gt; 이라는 의미에서 초기 산정이 중요하다.&lt;/p&gt;

&lt;p&gt;새로운 투자를 받기 위해 신주를 발행할 때에는, 발행한 신주의 거래가(발행가) 가 기존 주식의 액면가보다 높게 산정된다. (주식의 거래가, 발행가는 회사의 가치평가 valuation 의 결과물이다.)&lt;/p&gt;

&lt;p&gt;주식의 액면가가 500 원인 법인이 발행가 700원인 신주 1,000 주를 발행한다면,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;자본금의 증가 : 500원(액면가) * 1,000 = 500,000 원&lt;/li&gt;
  &lt;li&gt;자본 잉여금 -&amp;gt; 주식발행 초과금 : 200원(발행가-액면가) * 1,000 = 200,000 원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;액면가를 조정할 수 있는 방법도 존재한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;액면 분할 : 같은 자본금에서 현재의 주식을 분할한다. 주당 액면가가 낮아진다.&lt;/li&gt;
  &lt;li&gt;액면 병합 : 같은 자본금에서 현재의 주식을 합병한다. 주당 액면가가 높아진다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;자본잉여금&quot;&gt;자본잉여금&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://valuefocus.tistory.com/75&quot;&gt;재무재표 참고링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자본잉여금은 회사의 재무상태를 나타내는 재무재표표의 중요 구성요소 중 하나이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/27/1.png&quot; alt=&quot;img1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자본잉여금에는 다음과 같은 항목이 존재한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;자본잉여금&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;주식발행초과금&lt;/td&gt;
      &lt;td&gt;신주 발행시 거래가와 액면가의 차액은 자본금이 아닌 자본잉여금 중 주식발행초과금으로 재무재표에 기록됨&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;재평가 적립금&lt;/td&gt;
      &lt;td&gt;회사가 보유한 유형자산은 원칙적으로 초기 취득에 지불한 금액으로 재무재표에 기록하는 것이 원칙이지만, 유형자산의 가치가 급증하여 원칙으로는 회사 자산가치를 정확히 평가할 수 없을 때, 유형자산의 현재 시가를 이용해 재평가를 하게되는데, 재평가를 통해 상승한 자본금은 재평가 적립금으로 기록됨.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;시나리오
—
1. 사람 3이 모여서 법인(주식회사)설립후 자기돈으로 자본금 2000만원을 모았다.
2. 자본금 2000만원을 기준으로 주식수와 액면가를 10000주/2000원 으로 결정했다.
3. vc 가 나타나서 우리 회사를 1억으로 pre valuation 했고,  1억을 투자해 post value 를 2억이라고 산정했다.
4. 이제 우리 회사의 자본금은 1억 2천 인 상황.  
—

결과
- 주식수 2만주
- 주당가 1만원
- 지분  : vc 50% | 창업자 3인 50%
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name></name></author><category term="company" /><category term="valuation" /><category term="stock" /><category term="money" /><summary type="html">회사설립의 첫 걸음 법인 등기 사업자 등록</summary></entry><entry><title type="html">Javascript Runtime 의 구조</title><link href="https://shinjayne.github.io/post/25" rel="alternate" type="text/html" title="Javascript Runtime 의 구조" /><published>2018-05-17T19:11:50+09:00</published><updated>2018-05-17T19:11:50+09:00</updated><id>https://shinjayne.github.io/post/25</id><content type="html" xml:base="https://shinjayne.github.io/post/25">&lt;p&gt;javascript 언어는 다른 많은 언어들과 다르게 굉장히 다양한 Runtime(=실행환경) 속에서 실행된다.&lt;/p&gt;

&lt;p&gt;다른 언어 예를 들자면, python 은 python 공식 interpreter 가 주기적으로 업데이트되며, 모든 파이썬 코드 작성자는 python 공식 interpreter 를 이용한다. java 는 oracle 에서 JDE 를 공식 배포 및 관리하고, java 언어 사용자들은 모두 같은 java Runtime 을 이용하고 개발한다.&lt;/p&gt;

&lt;p&gt;반면에 javascript 는 개발자가 코드를 짜도, Runtime 에 따라 작동 양상이 다를 수 있다.&lt;/p&gt;

&lt;p&gt;그럼에도 모든 javascript Runtime 들은 비슷한 구조와 동작방식을 가지고 있다. 가장 대중적인 js runtime 인 nodejs 부터 브라우저에 내장된 runtime 까지, 기본 틀은 비슷하다.&lt;/p&gt;

&lt;p&gt;그리고 javascript runtime 들의 공통적인 동작방식을 아는 것은 javascript 코드를 짜는데에 매우 도움이 된다. 만약 callback Pattern 의 코드에서 Promise, async function, await Pattern 의 코드로 넘어가고 싶어도, javascript runtime 의 동작방식을 모르면 쉽사리 넘어갈 수 없다.&lt;/p&gt;

&lt;p&gt;그래서 이번 글에서는 Javascript Runtime 의 공통적인 구조를 파악해보려고 한다.&lt;/p&gt;

&lt;h1 id=&quot;runtime-기본-4-요소&quot;&gt;Runtime 기본 4 요소&lt;/h1&gt;

&lt;p&gt;Javascript Runtime 는 큰 4가지 요소로 나눌 수 있는데 이는 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Javascript Engine ( Call Stack , Memory Heap )&lt;/li&gt;
  &lt;li&gt;Background&lt;/li&gt;
  &lt;li&gt;여러 Task Queues 집단 ( Task Queue, Micro Task Queue, + Animation Frame 등 )&lt;/li&gt;
  &lt;li&gt;Event Loop&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;javascript-engine--코드-인터프리터&quot;&gt;Javascript Engine : 코드 인터프리터&lt;/h2&gt;

&lt;p&gt;JS Engine 은 &lt;code class=&quot;highlighter-rouge&quot;&gt;.js&lt;/code&gt;파일을 읽으면서 Call stack 을 채우고, Call stack 에 있는 작업들을 수행하기를 반복한다.&lt;/p&gt;

&lt;p&gt;엔진에 따라 외부 모듈을 읽어들이는 과정도 (&lt;code class=&quot;highlighter-rouge&quot;&gt;require('https')&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;import 'https'&lt;/code&gt;) 수행한다.&lt;/p&gt;

&lt;h2 id=&quot;background--수많은-작업을-하는-멀티-thread&quot;&gt;Background : 수많은 작업을 하는 멀티 Thread&lt;/h2&gt;

&lt;p&gt;JS Engine 에서 코드를 수행하다가, 다음과 같은 Background API 를 호출하게 되면, Background 작업이 시작된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Timer 작업 (&lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout(cb, 10 , ...args)&lt;/code&gt; 등으로 호출)&lt;/li&gt;
  &lt;li&gt;eventListener 작업 (&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick(cb, ...args)&lt;/code&gt; 등으로 호출)&lt;/li&gt;
  &lt;li&gt;Promise&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;각 Background 작업을 마치면, API가 호출될 때 전달받은 callback(Task) 을 Task Queue 에 삽입하기 위해 Event Loop 에게 전달한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;작업&lt;/th&gt;
      &lt;th&gt;callback 전달&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Timer 작업&lt;/td&gt;
      &lt;td&gt;timer 동작이 끝나면 함께 전달받은 callback 을 전달한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eventListener 작업&lt;/td&gt;
      &lt;td&gt;이벤트를 감지하면 전달받은 callback 을 전달한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Promise&lt;/td&gt;
      &lt;td&gt;Promise 안에 담긴 작업을 수행 완료하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;.then()&lt;/code&gt; 로 전달받은 callback 을 전달한다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Promise 의 동작은 따로 정리하는 것이 좋을 것 같아서 대강 설명하였다.&lt;/p&gt;

&lt;p&gt;바로 다음 post 에서 정리하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/25/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;event-loop--call-stack-과-background-의-중개자&quot;&gt;Event Loop : call stack 과 background 의 중개자&lt;/h2&gt;

&lt;p&gt;이번엔 Event Loop 가 하는 일을 알아보겠다. Event Loop 는 Javascript Runtime 의 중심에서 Call Stack 과 Background 간의 업무 처리를 돕는 중개자 역할을 한다.&lt;/p&gt;

&lt;p&gt;무한 루프를 돌면서 Callback(Task) 를 Background 에서 Task Queue 로, Task Queue 에서 Engine 의 Call stack 으로 적절히 전달한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/25/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;참고--단일멀티-thread&quot;&gt;참고 : 단일/멀티 Thread&lt;/h3&gt;
&lt;p&gt;Javascript Engine 은 단일 Thread 이다.&lt;/p&gt;

&lt;p&gt;“단일 Thread” 라는 말과 “Call Stack 이 하나” 라는 말은 같은 말이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;요소&lt;/th&gt;
      &lt;th&gt;Thread&lt;/th&gt;
      &lt;th&gt;특징&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Javascript Engine&lt;/td&gt;
      &lt;td&gt;단일 Thread&lt;/td&gt;
      &lt;td&gt;javascript 코드를 한 줄씩 읽으면서 작업을 수행한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Background&lt;/td&gt;
      &lt;td&gt;(일종의) 멀티 Thread&lt;/td&gt;
      &lt;td&gt;Engine 이 코드를 수행하는 동안, API 호출을 통해 전달받은 작업을 멀티 Thread 에서 동시다발적으로 수행한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Event Loop&lt;/td&gt;
      &lt;td&gt;단일 Thread&lt;/td&gt;
      &lt;td&gt;단일 Thread 위에서 무한 루프가 돌며 나머지 3요소를 관리한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;promise-로-부터-전달된-micro-task-는-우선-처리&quot;&gt;Promise 로 부터 전달된 Micro Task 는 우선 처리&lt;/h1&gt;

&lt;p&gt;Task Queue 부분은 여러 종류의 Task Queue 를 가지고 있는데, Javascript 의 Promise 문법을 지원하는 최근의 javascript runtime 들은 Micro Task Queue 를 가진다.&lt;/p&gt;

&lt;p&gt;Background 의 Promise 로부터 전달된 callback(task)는 Micro Task Queue 에 쌓이고, JS Engine 의 Call Stack 이 비었을 때 Task Queue 보다 우선적으로 Micro Task Queue 의 task 를 먼저 수행한다.&lt;/p&gt;

&lt;p&gt;아래는 그 예시이다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;setTimeout&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;promise1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;promise2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이 코드를 실행시키면 콘솔엔 아래와 같이 찍힌다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;1
2
3
promise1
promise2
setTimeout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1,2,3 가 먼저 찍힌 것은 javascript engine 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt; 이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.resolve().then(...)&lt;/code&gt; 처럼 Background 의 작업을 기다리지 않고 (비동기적) 다음 코드를 우선적으로 실행하는 것을 보여준다.&lt;/p&gt;

&lt;p&gt;코드가 실행되는 동안 event loop 와 background 에서는 열심히 timer 작업과 promise 작업을 수행할 것이고, call stack 이 다 비워진 시점에 micro task queue 와 task queue 는 아래와 같을 것이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Micro Task Queue&lt;/th&gt;
      &lt;th&gt;Task Queue&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_ =&amp;gt; {console.log(&quot;promise1&quot;);}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_ =&amp;gt;{console.log(&quot;setTimeout&quot;);}&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_ =&amp;gt; {console.log(&quot;promise2&quot;);}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 때 micro task queue 에 있는 task(callback) 들이 우선적으로 engine 의 call stack 으로 (event loop 에 의해) 전달되고, 우선적으로 수행된다.&lt;/p&gt;

&lt;p&gt;micro task queue 가 다 비워진 후에는 task queue 의 작업들이 옮겨지고 수행된다.&lt;/p&gt;</content><author><name></name></author><category term="javascript" /><category term="nodejs" /><category term="runtime" /><category term="promise" /><category term="eventloop" /><summary type="html">javascript 언어는 다른 많은 언어들과 다르게 굉장히 다양한 Runtime(=실행환경) 속에서 실행된다.</summary></entry><entry><title type="html">Docker 공식문서 에서 제시하는 개발-배포 Flow 따라가기 (Docker Swarm 사용하기)</title><link href="https://shinjayne.github.io/post/21" rel="alternate" type="text/html" title="Docker 공식문서 에서 제시하는 개발-배포 Flow 따라가기 (Docker Swarm 사용하기)" /><published>2018-02-09T21:04:50+09:00</published><updated>2018-02-09T21:04:50+09:00</updated><id>https://shinjayne.github.io/post/21</id><content type="html" xml:base="https://shinjayne.github.io/post/21">&lt;blockquote&gt;
  &lt;h5 id=&quot;pre-requisite&quot;&gt;pre-requisite&lt;/h5&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-machine&lt;/code&gt; 이 세가지 프로그램이 설치되어야 한다.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://store.docker.com/search?type=edition&amp;amp;offering=community&quot;&gt;Docker Store(링크)&lt;/a&gt; 에서 설치 가능하다. 자신의 OS 에 맞는 Docker 를 설치하자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;서론&quot;&gt;서론&lt;/h5&gt;
&lt;p&gt;그동안 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt; 를 사용하여 웹 서버 개발을 하고 있었지만, Docker 공식 문서를 오랜만에 들어가보니 그곳에서 추구하는 개발-배포 flow 는 나의 그것과 사뭇 달랐다.&lt;/p&gt;

&lt;p&gt;나의 방식보다 훨씬 깔끔하고 스마트했다. 그래서 한번 제대로 익혀놓고, 앞으로 이렇게 개발-배포 하자 라고 마음먹으며 이 글을 쓴다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“Docker 에서 제시하는 개발-배포 Flow 는 AWS 나 Azure 에서 자사 제품들을 이용하여 제시하는 개발-배포 Flow 의 대체가 될 수 있을 것 같다.”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;새로운 개발 배포 flow를 익히면서 중점적인 이슈로 둔 부분은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 초기구축 : 초기 서비스 그룹(DB, WAS, Web Server 등) 구축이 쉬운가&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 스케일 조정 : Load Balancing 설정이 쉽고, Scale 조정이 쉬운가&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 코드 배포 : 추후 앱의 로직 코드 변경시 배포가 편리한가&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클라우드를 제공하는 AWS 나 AZURE 는 자신들이 만들어놓은 여러 제품들을 이용하면 위 세가지를 편리하게 실현할 수 있게 하였다. (AWS 의 ELB-elastic load balancer 를 이용하면 로드밸런싱이 쉽게 가능한 것 처럼 …)&lt;/p&gt;

&lt;p&gt;과연 Docker 를 이용한 서버 개발-배포 flow 도 위의 세가지가 가능할까? Docker 공식 문서를 읽고 난 후 나의 생각은 ‘yes’ 이다.&lt;/p&gt;

&lt;h1 id=&quot;docker-에서-제시하는-개발-배포-flow&quot;&gt;Docker 에서 제시하는 개발-배포 Flow&lt;/h1&gt;

&lt;h2 id=&quot;1-초기-구축&quot;&gt;1. 초기 구축&lt;/h2&gt;
&lt;p&gt;초기 구축이란, 코드가 배포될 클라우드의 인프라를 구축하는 일을 말한다.&lt;/p&gt;

&lt;p&gt;Docker를 이용한 개발-배포 Flow 에서, 초기 구축은 두 단계로 나뉜다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Swarm(Docker Machine Cluster) 를 구축한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; 로 Stack 구성하고 실행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-1swarm-구축&quot;&gt;1-1.Swarm 구축&lt;/h3&gt;

&lt;p&gt;Swarm 이란 여러 Docker Macine들이 마치 하나의 Docker 실행환경처럼 작동하는 Virtual Macine Cluster 를 말한다.&lt;/p&gt;

&lt;p&gt;아래 그림처럼 Swarm 이 클라우드 서버 상의 두대의 Docker Machine 으로 구성되어 있다면, 우리가 제공하고자 하는 앱에 필요한 컨테이너들이 두 가상머신에 적절한 수로 배치된다.&lt;/p&gt;

&lt;h4 id=&quot;manager-node-와-worker-node&quot;&gt;Manager node 와 Worker node&lt;/h4&gt;
&lt;p&gt;Swarm 의 각 Docker Machine 들은 Node 라고 부르며, 하나의 Manager Node와 다수의 Worker Node 로 이루어져있다. 오직 Manager node 만이 다른 node 에 접근하고 제어할 수 있다. 우리는 이 모든 노드에 접속해 일일히 동작을 제어할 필요 없이, Manager Node 의 Shell 에 접속해서 마치 swarm 이 하나의 Docker 실행환경이라고 생각하고 docker 명령어를 실행하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.docker.com/get-started/images/visualizer-with-redis.png&quot; alt=&quot;swarm&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;manager--worker-설정&quot;&gt;Manager / Worker 설정&lt;/h4&gt;

&lt;p&gt;우선 접속 가능한 docker machine 리스트를 확인한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;docker-machine ls
NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
myvm1   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.06.2-ce   
myvm2   -        virtualbox   Running   tcp://192.168.99.101:2376           v17.06.2-ce   

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이 중 manager 로 삼을 docker machine 을 골라 아래와 같이 수행한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;docker-machine ssh myvm1 &lt;span class=&quot;s2&quot;&gt;&quot;docker swarm init --advertise-addr &amp;lt;myvm1 ip&amp;gt;&quot;&lt;/span&gt;
Swarm initialized: current node &amp;lt;node ID&amp;gt; is now a manager.

To add a worker to this swarm, run the following &lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt;:

  docker swarm join &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --token &amp;lt;token&amp;gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &amp;lt;myvm ip&amp;gt;:&amp;lt;port&amp;gt;

To add a manager to this swarm, run &lt;span class=&quot;s1&quot;&gt;'docker swarm join-token manager'&lt;/span&gt; and follow the instructions.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;위를 완료했다면
worker 로 삼을 docker machine 에서 아래와 같이 수행한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;docker-machine ssh myvm2 &lt;span class=&quot;s2&quot;&gt;&quot;docker swarm join &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
--token &amp;lt;token&amp;gt; &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
&amp;lt;ip&amp;gt;:2377&quot;&lt;/span&gt;

This node joined a swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;이때 주의 할 점은 반드시 2377 포트를 이용해 swarm 통신을 해야한다는 것이다. 2376 이 절대 아니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 Manager Node 에서 모든 docker 명령을 수행하면 되는데, 첫번째 docker 명령으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker node ls&lt;/code&gt; 으로 모든 클러스터 노드들을 확인해보자.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;docker-machine ssh myvm1 &lt;span class=&quot;s2&quot;&gt;&quot;docker node ls&quot;&lt;/span&gt;
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS
brtu9urxwfd5j0zrmkubhpkbd     myvm2               Ready               Active
rihwohkh3ph38fhillhhb84sk &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;   myvm1               Ready               Active              Leader
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;이렇게 Swarm 구축은 끝났고, 이 swarm 의 노드들을 Azure 나 Aws 의 클라우드 가상 머신으로 설정만 한다면 클라우드 서버 인프라 구축의 시작점이 되는 것이다.&lt;/p&gt;

&lt;p&gt;참고 1: &lt;a href=&quot;https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/docker-machine&quot;&gt;Azure 에서 Docker Machine 만드는 법&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;참고 2: &lt;a href=&quot;https://docs.docker.com/machine/drivers/aws/&quot;&gt;AWS 에서 Docker Machine 만드는 법&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;참고 3: &lt;a href=&quot;https://docs.docker.com/machine/drivers/&quot;&gt;Docker machine 에서 지원하는 가상머신 드라이버들&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;참고 4: &lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/windows/hardware/ff554678(v=vs.85).aspx&quot;&gt;driver 란?  Microsoft&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-2-docker-composeyml-로-stack-구성하고-실행&quot;&gt;1-2. &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; 로 Stack 구성하고 실행&lt;/h3&gt;

&lt;p&gt;Docker-Compose 는 컨테이너를 Stack-Service-Task 라는 세가지 가상 계층으로 구분해 관리한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Stack : 하나의 앱. (Facebook, Youtube 처럼 큰 단위)&lt;/li&gt;
  &lt;li&gt;Service : 앱을 구성하는 하나의 역할. (Django서버, mySQL서버, Nginx서버 등 앱을 작동하기 위한 구성요소들)&lt;/li&gt;
  &lt;li&gt;Task : Service 를 이루는 컨테이너들&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결국 우리가 만들고자 하는 것은 하나의 Stack 이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt;은 Stack 을 정의할 수 있는 파일이다.&lt;/p&gt;

&lt;h4 id=&quot;docker-composeyml-작성-예시&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; 작성 예시&lt;/h4&gt;
&lt;p&gt;아래는 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; 의 예시이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;web&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;visualizer&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt; 라는 세개의 Service 가 이 Stack 을 이루고, &lt;code class=&quot;highlighter-rouge&quot;&gt;web&lt;/code&gt; Service 는 5개의 Task(Container) 로 이루어져있다.&lt;/p&gt;

&lt;p&gt;5개의 Task 로 이루어진 &lt;code class=&quot;highlighter-rouge&quot;&gt;web&lt;/code&gt;서비스의 주소 80 port 로 접속이 들어오면, docker 는 round-robin 방식으로 load balancing 을 수행한다.&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;3&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;web&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# replace username/repo:tag with your name and image details&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;username/repo:tag&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;80:80&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;deploy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;5&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;restart_policy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;on-failure&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;limits&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;cpus&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;0.1&quot;&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;memory&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;50M&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;networks&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;webnet&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;visualizer&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;dockersamples/visualizer:stable&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;8080:8080&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/var/run/docker.sock:/var/run/docker.sock&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;deploy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;placement&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;constraints&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;node.role == manager&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;networks&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;webnet&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;redis&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;redis&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;6379:6379&quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# ports 대신 expose:-&quot;6379&quot; 을 사용하면 docker network 상에서만 접근 가능하고, 실제 외부 포트로 연결은 되지 않는다.&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;redis-data-vol:/data&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;deploy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;placement&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;constraints&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;node.role == manager&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;redis-server --appendonly yes&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;networks&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;webnet&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;networks&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;webnet&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;redis-data-vol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;대략 하나의 서비스를 기술 할 때,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;image&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ports&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;expose&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;volumes&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;networks&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;command&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;deploy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등이 필수적인 설정값인듯 하다.&lt;/p&gt;

&lt;p&gt;참고로 docker swarm 을 이용해 개발-배포 한다면 network driver 의 기본 설정값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;overlay&lt;/code&gt; 이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;overlay&lt;/code&gt; 는 여러대의 docker-machine 에 나누어진 container들이 마치 하나의 network 상에 존재하는 것처럼 접속 가능하게 해준다.&lt;/p&gt;

&lt;p&gt;참고 1 : &lt;a href=&quot;https://docs.docker.com/compose/compose-file/#network-configuration-reference&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;networks&lt;/code&gt; top-level key 설정 관하여&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;참고 2 : &lt;a href=&quot;https://docs.docker.com/compose/compose-file/#volume-configuration-reference&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;volumes&lt;/code&gt; top-level key 설정 관하여&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;참고 3 : &lt;a href=&quot;https://docs.docker.com/compose/compose-file/#deploy&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;deploy&lt;/code&gt; service-level key 설정 관하여&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;참고 4 : &lt;a href=&quot;https://docs.docker.com/network/network-tutorial-overlay/&quot;&gt;Docker 의 overlay network 에 대하여&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;stack-실행하기&quot;&gt;Stack 실행하기&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; 로 하나의 Stack 을 정의했으니, 이제 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; 파일을 Manager Node 에 업로드하고&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker-machine scp /local/docker-compose.yml myvm1:/path/to/docker-compose.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Manager Node 에서 Stack 을 실행한다. 이때 stack 정의에 참고할 Compose file 도 &lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt; 옵션으로 적어준다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker stack deploy -c ./docker-compose.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;1-3-docker-compose-와-docker-machine&quot;&gt;1-3. Docker Compose 와 Docker Machine&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;h4 id=&quot;docker-compose-가-하는-역할&quot;&gt;Docker Compose 가 하는 역할&lt;/h4&gt;
  &lt;ol&gt;
    &lt;li&gt;Stack-Service-Task 계층 구조를 확립시키고, 컨테이너를 효율적으로 관리하고 연결시킨다.&lt;/li&gt;
    &lt;li&gt;원본 Image 가 변경되어서 컨테이너가 recreate 될 때에도, 이전 컨테이너 내용을 복사해서 붙여넣어주므로 데이터 연속성과 유지력을 보완시켜준다. (&lt;strong&gt;기본적으로 컨테이너가 recreate 되면 read-write 계층 파일은 모두 사라진다.&lt;/strong&gt; ) (&lt;a href=&quot;http://judekim.tistory.com/15&quot;&gt;참고블로그링크&lt;/a&gt;)
&lt;img src=&quot;http://cfile25.uf.tistory.com/image/2567453B5214F0D815C008&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;li&gt;불필요한 container recreate 를 줄여준다. 이미지의 변경이 없을 시 컨테이너를 그대로 유지한다.&lt;/li&gt;
    &lt;li&gt;Docker Swarm 의 로드밸런싱 규칙을 설정한다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;docker-machine-이-하는-역할&quot;&gt;Docker Machine 이 하는 역할&lt;/h4&gt;
  &lt;p&gt;docker 실행 환경이 조성된 가상 머신을 생성하고 관리한다. Docker Swarm 을 구축하고 관리할 때 필수적이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-스케일-조정&quot;&gt;2. 스케일 조정&lt;/h2&gt;

&lt;h3 id=&quot;2-1-docker-로드밸런싱부하분산---두가지-패러다임&quot;&gt;2-1. docker 로드밸런싱(부하분산) :  두가지 패러다임&lt;/h3&gt;

&lt;p&gt;위의 초기 구축 단계를 따라오다보면 두가지 로드밸런싱의 패러다임을 발견할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;첫번째&lt;/strong&gt; : Cluster 의 worker node 를 추가함으로써 부하분산을 취하는 방식&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;두번째&lt;/strong&gt; :  Service 의 Task Container 수 (&lt;code class=&quot;highlighter-rouge&quot;&gt;replicas : 5&lt;/code&gt;)를 늘림으로써 부하분산을 취하는 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두가지 방식 모두 유용하다. 스케일 조정 참 쉽다.&lt;/p&gt;

&lt;h3 id=&quot;2-2-swarm-cluster-의-로드밸런싱&quot;&gt;2-2. Swarm Cluster 의 로드밸런싱&lt;/h3&gt;
&lt;p&gt;Swarm 의 각 노드 Machine 주소로 접속한다면?&lt;/p&gt;

&lt;p&gt;결국 각 노드에 존재하는 swarm loadbalancer 가 하나의 docker 실행환경처럼 작동해서 필요한 적절한 컨테이너로 연결해준다.
&lt;img src=&quot;https://docs.docker.com/engine/swarm/images/ingress-routing-mesh.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 어떠한 가상머신(node)이 서비스를 제공하는지 숨기고 싶은 경우, 통상적인 방식대로 Swarm 앞에 로드밸런서를 하나 더 두어야한다. &lt;a href=&quot;https://www.upcloud.com/support/load-balancing-docker-swarm-mode/&quot;&gt;Load Balancing 을 수행하는 Proxy 서버로 Nginx 를 Swarm 앞에 사용하는 tutorial 관련 게시글&lt;/a&gt; 을 참조하면 이러한 시도들을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;이전 nginx 관련 포스트에서 설명했던 바와 같이, nginx 에는 기본 로드밸런서 기능이 내장되어있다.&lt;/p&gt;

&lt;p&gt;관련글 -&amp;gt; &lt;a href=&quot;http://jaynewho.com/post/18&quot;&gt;jayneWho();  &amp;gt; Post &amp;gt;   Nginx 에 대하여 (Nginx Basic Usage)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.upcloud.com/support/wp-content/uploads/2016/10/Load-balancing-docker-swarm.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/swarm/ingress/#configure-an-external-load-balancer&quot;&gt;또한 Docker Documentation 에도 Swarm 앞에 External Load Balancer 로 HAProxy 를 두는 법을 설명하고 있다.&lt;/a&gt; 아래 그림을 참고하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.docker.com/engine/swarm/images/ingress-lb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-코드-배포&quot;&gt;3. 코드 배포&lt;/h2&gt;

&lt;p&gt;위와 같이 클라우드 인프라를 구축해놓았다면, 코드를 배포하는 일은 너무나 쉽다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;소스 코드 수정 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker image build&lt;/code&gt; 하기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Docker Hub Repository 에 새로 만든 이미지 push 하기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; 파일 또는 swarm 에 bind-mount 파일 변경되었다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-machine scp&lt;/code&gt; 로 전송\&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-machine ssh myvm1 &quot;docker stack deploy -c ./docker-compose.yml&quot;&lt;/code&gt; 로 Stack 재배포하면, Repository 에서 이미지 새로 끌어와서 업데이트된 컨테이너가 구축됨&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/asset/media/image/post/21/1.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-1-local-에서-개발-테스트&quot;&gt;3-1. local 에서 개발 테스트&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose-dev.yml&lt;/code&gt; 파일을 작성해서, 로컬에서 돌릴만한 Stack 구성을 작성해 local 의 docker engine 에서 이미지와 컨테이너가 잘 작동하는지 테스트하며 개발할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이로써 초기 구축, 스케일조정, 코드배포 까지 개발-배포 과정에서 docker 를 이용하는 방식을 살펴보았다. docker 공식 문서에 충실하게 말이다.&lt;/p&gt;

&lt;h5 id=&quot;좋은-refernece-발견&quot;&gt;좋은 refernece 발견&lt;/h5&gt;
&lt;p&gt;위와 같은 배포 flow 대로 충실히 수행한 toy-project 를 github 에서 발견하였다. 실제 코드가 보고싶을 때 &lt;a href=&quot;https://github.com/sophilabs/sample-django-docker-swarm&quot;&gt;“이 프로젝트 Github 링크”&lt;/a&gt; 로 들어가 프로젝트 코드를 살피면 좋을 듯 하다. backend service (django)(3 replicas) + frontend service (nginx)(2 replicas) 로 간단하게 구성되어있다. 이 곳에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker stack deploy -c docker-swarm.yml&lt;/code&gt; 을 해야한다.&lt;/p&gt;

&lt;h5 id=&quot;뭔가-아쉽다면&quot;&gt;뭔가 아쉽다면&lt;/h5&gt;
&lt;p&gt;그런데 뭔가 배포한 Swarm 과 Stack 에 관한 시각화와 관리 툴이 있으면 좋겠다는 생각이 든다. 그 때 발견한 것이 Docker Cloud 이다.&lt;/p&gt;

&lt;h1 id=&quot;docker-cloud-web-console-이용하여-swarm-관리&quot;&gt;Docker Cloud Web Console 이용하여 Swarm 관리&lt;/h1&gt;

&lt;p&gt;Docker Cloud 를 이용하면 자신의 Swarm 과 그 위에 돌아가는 Stack, Service, Task Container 들을 관리할 수 있다. 자세한 spec 설정까지 가능하다.&lt;/p&gt;

&lt;p&gt;자신의 Docker Hub Repository 에 있는 image 들도 불러와 관리할 수 있고, AutoBuild 기능으로 코드에 변화가 생겼을 때 바로바로 image 를 자동 재생성하는 기능 또한 갖췄다.&lt;/p&gt;

&lt;p&gt;심지어 새로운 Swarm 이나 이미지를 웹 상에서 만드는 것도 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/sophilabs/sample-django-docker-swarm/raw/master/create-swarm.png&quot; alt=&quot;&quot; /&gt;
(docker-machine 드라이버를 제공하는 다른 cloud hosting 서비스 업체들은 많지만, swarm 만들기를 지원하는건 아직 amazon 과 azure 뿐인가보다. 다른 서비스업체를 이용할 경우 직접 위 방식대로 swarm 을 만들어야겠다.)&lt;/p&gt;

&lt;p&gt;매우 간단한 UI 이므로, 직접 사용해보는 것을 추천한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/docker-cloud/&quot;&gt;Docker Cloud Documentation&lt;/a&gt; 의 Manage Swarms 를 보면서 사용하면 좋을 듯 하다.&lt;/p&gt;</content><author><name></name></author><category term="docker" /><category term="swarm" /><category term="stack" /><category term="service" /><category term="container" /><category term="image" /><category term="deploy" /><summary type="html">pre-requisite docker, docker-compose, docker-machine 이 세가지 프로그램이 설치되어야 한다. Docker Store(링크) 에서 설치 가능하다. 자신의 OS 에 맞는 Docker 를 설치하자.</summary></entry><entry><title type="html">AngularJS 와 Django Template Tag 충돌 해결</title><link href="https://shinjayne.github.io/post/20" rel="alternate" type="text/html" title="AngularJS 와 Django Template Tag 충돌 해결" /><published>2018-01-26T13:10:50+09:00</published><updated>2018-01-26T13:10:50+09:00</updated><id>https://shinjayne.github.io/post/20</id><content type="html" xml:base="https://shinjayne.github.io/post/20">&lt;h4 id=&quot;notice&quot;&gt;notice!&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;이 글은 현재 널리 쓰이는 Angular 가 아닌 그의 전신 AngularJS(v1) 를 다루고 있습니다. 과거 기술에 기반한 내용이니 참고해주시기 바랍니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AngularJS 는 웹 앱의 프런트엔드 부분을 만드는 Javascipt Framework 이고, Django 의 Template Engine 은 백엔드 Framework 에서 동적으로 html 문서를 생성해주는 시스템이다.&lt;/p&gt;

&lt;p&gt;이 두개를 함께 쓰려하면 한가지 문제가 생긴다. AngularJS 에서 Model(내부변수들)을 View(HTML 문서) 에 bind 할 때 사용하는 Symbol 과 Django Tempate Engine 에서 사용하는 Tag Symbol 이 동일하기 때문에, 함께 사용하면 AngularJS 의 Bind Symbol 이 작동하지 않는다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위한 방법은 여러가지 있는데, 그중 내가 사용해보려고 하는 방법은 AngularJS  module 의 설정(config) 중 하나인 &lt;code class=&quot;highlighter-rouge&quot;&gt;$interpolateProvider&lt;/code&gt; 를 조정하는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;interpolateprovider-조정하기&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$interpolateProvider&lt;/code&gt; 조정하기&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.angularjs.org/api/ng/provider/$interpolateProvider&quot;&gt;AngularJS 의 공식 Documentation&lt;/a&gt; 에 자세한 사용법이 나온다.&lt;/p&gt;

&lt;p&gt;아래의 예시는 기존의 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;/code&gt; 와 &lt;code class=&quot;highlighter-rouge&quot;&gt;} }&lt;/code&gt; 이던 Binding Symbol 을 &lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt; 와 &lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt; 로 변경한다.&lt;/p&gt;

&lt;p&gt;다만 이 설정은 config 설정을 조정한 해당 앱 내에서만 작동한다.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;customInterpolationApp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;angular&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'customInterpolationApp'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]);&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;customInterpolationApp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$interpolateProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$interpolateProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;startSymbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'//'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$interpolateProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;endSymbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'//'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;


  &lt;span class=&quot;nx&quot;&gt;customInterpolationApp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;controller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'DemoController'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;This binding is brought you by // interpolation symbols.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ng-controller=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;DemoController as demo&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    //demo.label//
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name></name></author><category term="django" /><category term="angular" /><category term="backend" /><category term="frontend" /><category term="javascript" /><summary type="html">notice! 이 글은 현재 널리 쓰이는 Angular 가 아닌 그의 전신 AngularJS(v1) 를 다루고 있습니다. 과거 기술에 기반한 내용이니 참고해주시기 바랍니다.</summary></entry></feed>